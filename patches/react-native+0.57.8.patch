patch-package
new file mode 100644
Binary files /dev/null and b/node_modules/react-native/.DS_Store differ
new file mode 100644
Binary files /dev/null and b/node_modules/react-native/Libraries/.DS_Store differ
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-dev.js
@@ -4113,9 +4113,8 @@ function setCurrentPhase(lifeCyclePhase) {
 var debugRenderPhaseSideEffects = false;
 var debugRenderPhaseSideEffectsForStrictMode = false;
 var enableUserTimingAPI = true;
-var enableHooks = false;
-var warnAboutDeprecatedLifecycles = false;
 var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
+var warnAboutDeprecatedLifecycles = false;
 var enableProfilerTimer = true;
 var enableSchedulerTracing = true;
 
@@ -5116,7 +5115,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.memoizedProps = null;
   this.updateQueue = null;
   this.memoizedState = null;
-  this.firstContextDependency = null;
+  this.contextDependencies = null;
 
   this.mode = mode;
 
@@ -5133,14 +5132,16 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.alternate = null;
 
   if (enableProfilerTimer) {
-    // Note: The following is done to avoid a v8 deopt.
+    // Note: The following is done to avoid a v8 performance cliff.
     //
-    // It is important to initialize the fields below with doubles.
-    // Otherwise Fibers will deopt and end up having separate shapes when
-    // doubles are later assigned to fields that initially contained smis.
-    // This is a bug in v8 having something to do with Object.preventExtension().
+    // Initializing the fields below to smis and later updating them with
+    // double values will cause Fibers to end up having separate shapes.
+    // This behavior/bug has something to do with Object.preventExtension().
+    // Fortunately this only impacts DEV builds.
+    // Unfortunately it makes React unusably slow for some applications.
+    // To work around this, initialize the fields below with doubles.
     //
-    // Learn more about this deopt here:
+    // Learn more about this here:
     // https://github.com/facebook/react/issues/14365
     // https://bugs.chromium.org/p/v8/issues/detail?id=8538
     this.actualDuration = Number.NaN;
@@ -5149,7 +5150,8 @@ function FiberNode(tag, pendingProps, key, mode) {
     this.treeBaseDuration = Number.NaN;
 
     // It's okay to replace the initial doubles with smis after initialization.
-    // This simplifies other profiler code and doesn't trigger the deopt.
+    // This won't trigger the performance cliff mentioned above,
+    // and it simplifies other profiler code (including DevTools).
     this.actualDuration = 0;
     this.actualStartTime = -1;
     this.selfBaseDuration = 0;
@@ -5270,7 +5272,7 @@ function createWorkInProgress(current, pendingProps, expirationTime) {
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.firstContextDependency = current.firstContextDependency;
+  workInProgress.contextDependencies = current.contextDependencies;
 
   // These will be overridden during the parent's reconciliation
   workInProgress.sibling = current.sibling;
@@ -5536,7 +5538,7 @@ function assignFiberPropertiesInDEV(target, source) {
   target.memoizedProps = source.memoizedProps;
   target.updateQueue = source.updateQueue;
   target.memoizedState = source.memoizedState;
-  target.firstContextDependency = source.firstContextDependency;
+  target.contextDependencies = source.contextDependencies;
   target.mode = source.mode;
   target.effectTag = source.effectTag;
   target.nextEffect = source.nextEffect;
@@ -5589,6 +5591,8 @@ function createFiberRoot(containerInfo, isConcurrent, hydrate) {
       latestSuspendedTime: NoWork,
       latestPingedTime: NoWork,
 
+      pingCache: null,
+
       didError: false,
 
       pendingCommitExpirationTime: NoWork,
@@ -5612,6 +5616,8 @@ function createFiberRoot(containerInfo, isConcurrent, hydrate) {
       containerInfo: containerInfo,
       pendingChildren: null,
 
+      pingCache: null,
+
       earliestPendingTime: NoWork,
       latestPendingTime: NoWork,
       earliestSuspendedTime: NoWork,
@@ -5761,7 +5767,7 @@ var ReactStrictModeWarnings = {
       lifecycleWarningsMap,
       strictRoot
     ) {
-      var lifecyclesWarningMesages = [];
+      var lifecyclesWarningMessages = [];
 
       Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {
         var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
@@ -5776,7 +5782,7 @@ var ReactStrictModeWarnings = {
           var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
           var sortedComponentNames = setToSortedString(componentNames);
 
-          lifecyclesWarningMesages.push(
+          lifecyclesWarningMessages.push(
             formatted +
               ": Please update the following components to use " +
               (suggestion + " instead: " + sortedComponentNames)
@@ -5784,7 +5790,7 @@ var ReactStrictModeWarnings = {
         }
       });
 
-      if (lifecyclesWarningMesages.length > 0) {
+      if (lifecyclesWarningMessages.length > 0) {
         var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
 
         warningWithoutStack$1(
@@ -5794,7 +5800,7 @@ var ReactStrictModeWarnings = {
             "\n\nLearn more about this warning here:" +
             "\nhttps://fb.me/react-strict-mode-warnings",
           strictRootComponentStack,
-          lifecyclesWarningMesages.join("\n\n")
+          lifecyclesWarningMessages.join("\n\n")
         );
       }
     });
@@ -6095,6 +6101,10 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
     return;
   }
 
+  if (earliestRemainingTime < root.latestPingedTime) {
+    root.latestPingedTime = NoWork;
+  }
+
   // Let's see if the previous latest known pending level was just flushed.
   var latestPendingTime = root.latestPendingTime;
   if (latestPendingTime !== NoWork) {
@@ -6230,10 +6240,8 @@ function markPingedPriorityLevel(root, pingedTime) {
 }
 
 function clearPing(root, completedTime) {
-  // TODO: Track whether the root was pinged during the render phase. If so,
-  // we need to make sure we don't lose track of it.
   var latestPingedTime = root.latestPingedTime;
-  if (latestPingedTime !== NoWork && latestPingedTime >= completedTime) {
+  if (latestPingedTime >= completedTime) {
     root.latestPingedTime = NoWork;
   }
 }
@@ -6297,10 +6305,10 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
 // UpdateQueue is a linked list of prioritized updates.
 //
 // Like fibers, update queues come in pairs: a current queue, which represents
-// the visible state of the screen, and a work-in-progress queue, which is
-// can be mutated and processed asynchronously before it is committed — a form
-// of double buffering. If a work-in-progress render is discarded before
-// finishing, we create a new work-in-progress by cloning the current queue.
+// the visible state of the screen, and a work-in-progress queue, which can be
+// mutated and processed asynchronously before it is committed — a form of
+// double buffering. If a work-in-progress render is discarded before finishing,
+// we create a new work-in-progress by cloning the current queue.
 //
 // Both queues share a persistent, singly-linked list structure. To schedule an
 // update, we append it to the end of both queues. Each queue maintains a
@@ -6886,3575 +6894,3612 @@ var warning = warningWithoutStack$1;
 
 var warning$1 = warning;
 
-var valueCursor = createCursor(null);
-
-var rendererSigil = void 0;
-{
-  // Use this to detect multiple renderers using the same context
-  rendererSigil = {};
+/**
+ * inlined Object.is polyfill to avoid requiring consumers ship their own
+ * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+ */
+function is(x, y) {
+  return (
+    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
+  );
 }
 
-var currentlyRenderingFiber = null;
-var lastContextDependency = null;
-var lastContextWithAllBitsObserved = null;
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 
-function resetContextDependences() {
-  // This is called right before React yields execution, to ensure `readContext`
-  // cannot be called outside the render phase.
-  currentlyRenderingFiber = null;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
-}
+/**
+ * Performs equality by iterating through keys on an object and returning false
+ * when any key has values which are not strictly equal between the arguments.
+ * Returns true when the values of all keys are strictly equal.
+ */
+function shallowEqual(objA, objB) {
+  if (is(objA, objB)) {
+    return true;
+  }
 
-function pushProvider(providerFiber, nextValue) {
-  var context = providerFiber.type._context;
+  if (
+    typeof objA !== "object" ||
+    objA === null ||
+    typeof objB !== "object" ||
+    objB === null
+  ) {
+    return false;
+  }
 
-  if (isPrimaryRenderer) {
-    push(valueCursor, context._currentValue, providerFiber);
+  var keysA = Object.keys(objA);
+  var keysB = Object.keys(objB);
 
-    context._currentValue = nextValue;
-    {
-      !(
-        context._currentRenderer === undefined ||
-        context._currentRenderer === null ||
-        context._currentRenderer === rendererSigil
-      )
-        ? warningWithoutStack$1(
-            false,
-            "Detected multiple renderers concurrently rendering the " +
-              "same context provider. This is currently unsupported."
-          )
-        : void 0;
-      context._currentRenderer = rendererSigil;
-    }
-  } else {
-    push(valueCursor, context._currentValue2, providerFiber);
+  if (keysA.length !== keysB.length) {
+    return false;
+  }
 
-    context._currentValue2 = nextValue;
-    {
-      !(
-        context._currentRenderer2 === undefined ||
-        context._currentRenderer2 === null ||
-        context._currentRenderer2 === rendererSigil
-      )
-        ? warningWithoutStack$1(
-            false,
-            "Detected multiple renderers concurrently rendering the " +
-              "same context provider. This is currently unsupported."
-          )
-        : void 0;
-      context._currentRenderer2 = rendererSigil;
+  // Test for A's keys different from B.
+  for (var i = 0; i < keysA.length; i++) {
+    if (
+      !hasOwnProperty.call(objB, keysA[i]) ||
+      !is(objA[keysA[i]], objB[keysA[i]])
+    ) {
+      return false;
     }
   }
-}
 
-function popProvider(providerFiber) {
-  var currentValue = valueCursor.current;
-
-  pop(valueCursor, providerFiber);
+  return true;
+}
 
-  var context = providerFiber.type._context;
-  if (isPrimaryRenderer) {
-    context._currentValue = currentValue;
-  } else {
-    context._currentValue2 = currentValue;
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    // Resolve default props. Taken from ReactElement
+    var props = Object.assign({}, baseProps);
+    var defaultProps = Component.defaultProps;
+    for (var propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
+    }
+    return props;
   }
+  return baseProps;
 }
 
-function calculateChangedBits(context, newValue, oldValue) {
-  // Use Object.is to compare the new context value to the old value. Inlined
-  // Object.is polyfill.
-  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-  if (
-    (oldValue === newValue &&
-      (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||
-    (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare
-  ) {
-    // No change
-    return 0;
-  } else {
-    var changedBits =
-      typeof context._calculateChangedBits === "function"
-        ? context._calculateChangedBits(oldValue, newValue)
-        : maxSigned31BitInt;
-
-    {
-      !((changedBits & maxSigned31BitInt) === changedBits)
-        ? warning$1(
-            false,
-            "calculateChangedBits: Expected the return value to be a " +
-              "31-bit integer. Instead received: %s",
-            changedBits
-          )
-        : void 0;
+function readLazyComponentType(lazyComponent) {
+  var status = lazyComponent._status;
+  var result = lazyComponent._result;
+  switch (status) {
+    case Resolved: {
+      var Component = result;
+      return Component;
+    }
+    case Rejected: {
+      var error = result;
+      throw error;
+    }
+    case Pending: {
+      var thenable = result;
+      throw thenable;
+    }
+    default: {
+      lazyComponent._status = Pending;
+      var ctor = lazyComponent._ctor;
+      var _thenable = ctor();
+      _thenable.then(
+        function(moduleObject) {
+          if (lazyComponent._status === Pending) {
+            var defaultExport = moduleObject.default;
+            {
+              if (defaultExport === undefined) {
+                warning$1(
+                  false,
+                  "lazy: Expected the result of a dynamic import() call. " +
+                    "Instead received: %s\n\nYour code should look like: \n  " +
+                    "const MyComponent = lazy(() => import('./MyComponent'))",
+                  moduleObject
+                );
+              }
+            }
+            lazyComponent._status = Resolved;
+            lazyComponent._result = defaultExport;
+          }
+        },
+        function(error) {
+          if (lazyComponent._status === Pending) {
+            lazyComponent._status = Rejected;
+            lazyComponent._result = error;
+          }
+        }
+      );
+      // Handle synchronous thenables.
+      switch (lazyComponent._status) {
+        case Resolved:
+          return lazyComponent._result;
+        case Rejected:
+          throw lazyComponent._result;
+      }
+      lazyComponent._result = _thenable;
+      throw _thenable;
     }
-    return changedBits | 0;
   }
 }
 
-function propagateContextChange(
-  workInProgress,
-  context,
-  changedBits,
-  renderExpirationTime
-) {
-  var fiber = workInProgress.child;
-  if (fiber !== null) {
-    // Set the return pointer of the child to the work-in-progress fiber.
-    fiber.return = workInProgress;
-  }
-  while (fiber !== null) {
-    var nextFiber = void 0;
+var fakeInternalInstance = {};
+var isArray$1 = Array.isArray;
 
-    // Visit this fiber.
-    var dependency = fiber.firstContextDependency;
-    if (dependency !== null) {
-      do {
-        // Check if the context matches.
-        if (
-          dependency.context === context &&
-          (dependency.observedBits & changedBits) !== 0
-        ) {
-          // Match! Schedule an update on this fiber.
+// React.Component uses a shared frozen object by default.
+// We'll use it to determine whether we need to initialize legacy refs.
+var emptyRefsObject = new React.Component().refs;
 
-          if (fiber.tag === ClassComponent) {
-            // Schedule a force update on the work-in-progress.
-            var update = createUpdate(renderExpirationTime);
-            update.tag = ForceUpdate;
-            // TODO: Because we don't have a work-in-progress, this will add the
-            // update to the current fiber, too, which means it will persist even if
-            // this render is thrown away. Since it's a race condition, not sure it's
-            // worth fixing.
-            enqueueUpdate(fiber, update);
-          }
+var didWarnAboutStateAssignmentForComponent = void 0;
+var didWarnAboutUninitializedState = void 0;
+var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
+var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
+var didWarnAboutUndefinedDerivedState = void 0;
+var warnOnUndefinedDerivedState = void 0;
+var warnOnInvalidCallback = void 0;
+var didWarnAboutDirectlyAssigningPropsToState = void 0;
+var didWarnAboutContextTypeAndContextTypes = void 0;
+var didWarnAboutInvalidateContextType = void 0;
 
-          if (fiber.expirationTime < renderExpirationTime) {
-            fiber.expirationTime = renderExpirationTime;
-          }
-          var alternate = fiber.alternate;
-          if (
-            alternate !== null &&
-            alternate.expirationTime < renderExpirationTime
-          ) {
-            alternate.expirationTime = renderExpirationTime;
-          }
-          // Update the child expiration time of all the ancestors, including
-          // the alternates.
-          var node = fiber.return;
-          while (node !== null) {
-            alternate = node.alternate;
-            if (node.childExpirationTime < renderExpirationTime) {
-              node.childExpirationTime = renderExpirationTime;
-              if (
-                alternate !== null &&
-                alternate.childExpirationTime < renderExpirationTime
-              ) {
-                alternate.childExpirationTime = renderExpirationTime;
-              }
-            } else if (
-              alternate !== null &&
-              alternate.childExpirationTime < renderExpirationTime
-            ) {
-              alternate.childExpirationTime = renderExpirationTime;
-            } else {
-              // Neither alternate was updated, which means the rest of the
-              // ancestor path already has sufficient priority.
-              break;
-            }
-            node = node.return;
-          }
-        }
-        nextFiber = fiber.child;
-        dependency = dependency.next;
-      } while (dependency !== null);
-    } else if (fiber.tag === ContextProvider) {
-      // Don't scan deeper if this is a matching provider
-      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
-    } else {
-      // Traverse down.
-      nextFiber = fiber.child;
-    }
-
-    if (nextFiber !== null) {
-      // Set the return pointer of the child to the work-in-progress fiber.
-      nextFiber.return = fiber;
-    } else {
-      // No child. Traverse to next sibling.
-      nextFiber = fiber;
-      while (nextFiber !== null) {
-        if (nextFiber === workInProgress) {
-          // We're back to the root of this subtree. Exit.
-          nextFiber = null;
-          break;
-        }
-        var sibling = nextFiber.sibling;
-        if (sibling !== null) {
-          // Set the return pointer of the sibling to the work-in-progress fiber.
-          sibling.return = nextFiber.return;
-          nextFiber = sibling;
-          break;
-        }
-        // No more siblings. Traverse up.
-        nextFiber = nextFiber.return;
-      }
-    }
-    fiber = nextFiber;
-  }
-}
-
-function prepareToReadContext(workInProgress, renderExpirationTime) {
-  currentlyRenderingFiber = workInProgress;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
+{
+  didWarnAboutStateAssignmentForComponent = new Set();
+  didWarnAboutUninitializedState = new Set();
+  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
+  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
+  didWarnAboutDirectlyAssigningPropsToState = new Set();
+  didWarnAboutUndefinedDerivedState = new Set();
+  didWarnAboutContextTypeAndContextTypes = new Set();
+  didWarnAboutInvalidateContextType = new Set();
 
-  // Reset the work-in-progress list
-  workInProgress.firstContextDependency = null;
-}
+  var didWarnOnInvalidCallback = new Set();
 
-function readContext(context, observedBits) {
-  if (lastContextWithAllBitsObserved === context) {
-    // Nothing to do. We already observe everything in this context.
-  } else if (observedBits === false || observedBits === 0) {
-    // Do not observe any updates.
-  } else {
-    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
-    if (
-      typeof observedBits !== "number" ||
-      observedBits === maxSigned31BitInt
-    ) {
-      // Observe all updates.
-      lastContextWithAllBitsObserved = context;
-      resolvedObservedBits = maxSigned31BitInt;
-    } else {
-      resolvedObservedBits = observedBits;
+  warnOnInvalidCallback = function(callback, callerName) {
+    if (callback === null || typeof callback === "function") {
+      return;
+    }
+    var key = callerName + "_" + callback;
+    if (!didWarnOnInvalidCallback.has(key)) {
+      didWarnOnInvalidCallback.add(key);
+      warningWithoutStack$1(
+        false,
+        "%s(...): Expected the last optional `callback` argument to be a " +
+          "function. Instead received: %s.",
+        callerName,
+        callback
+      );
     }
+  };
 
-    var contextItem = {
-      context: context,
-      observedBits: resolvedObservedBits,
-      next: null
-    };
+  warnOnUndefinedDerivedState = function(type, partialState) {
+    if (partialState === undefined) {
+      var componentName = getComponentName(type) || "Component";
+      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
+        didWarnAboutUndefinedDerivedState.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " +
+            "You have returned undefined.",
+          componentName
+        );
+      }
+    }
+  };
 
-    if (lastContextDependency === null) {
+  // This is so gross but it's at least non-critical and can be removed if
+  // it causes problems. This is meant to give a nicer error message for
+  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
+  // ...)) which otherwise throws a "_processChildContext is not a function"
+  // exception.
+  Object.defineProperty(fakeInternalInstance, "_processChildContext", {
+    enumerable: false,
+    value: function() {
       invariant(
-        currentlyRenderingFiber !== null,
-        "Context can only be read while React is " +
-          "rendering, e.g. inside the render method or getDerivedStateFromProps."
+        false,
+        "_processChildContext is not available in React 16+. This likely " +
+          "means you have multiple copies of React and are attempting to nest " +
+          "a React 15 tree inside a React 16 tree using " +
+          "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
+          "to make sure you have only one copy of React (and ideally, switch " +
+          "to ReactDOM.createPortal)."
       );
-      // This is the first dependency in the list
-      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
-    } else {
-      // Append a new context item.
-      lastContextDependency = lastContextDependency.next = contextItem;
     }
-  }
-  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+  });
+  Object.freeze(fakeInternalInstance);
 }
 
-var NoEffect$1 = /*             */ 0;
-var UnmountSnapshot = /*      */ 2;
-var UnmountMutation = /*      */ 4;
-var MountMutation = /*        */ 8;
-var UnmountLayout = /*        */ 16;
-var MountLayout = /*          */ 32;
-var MountPassive = /*         */ 64;
-var UnmountPassive = /*       */ 128;
+function applyDerivedStateFromProps(
+  workInProgress,
+  ctor,
+  getDerivedStateFromProps,
+  nextProps
+) {
+  var prevState = workInProgress.memoizedState;
 
-function areHookInputsEqual(arr1, arr2) {
-  // Don't bother comparing lengths in prod because these arrays should be
-  // passed inline.
   {
-    !(arr1.length === arr2.length)
-      ? warning$1(
-          false,
-          "Detected a variable number of hook dependencies. The length of the " +
-            "dependencies array should be constant between renders.\n\n" +
-            "Previous: %s\n" +
-            "Incoming: %s",
-          arr1.join(", "),
-          arr2.join(", ")
-        )
-      : void 0;
-  }
-  for (var i = 0; i < arr1.length; i++) {
-    // Inlined Object.is polyfill.
-    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-    var val1 = arr1[i];
-    var val2 = arr2[i];
     if (
-      (val1 === val2 && (val1 !== 0 || 1 / val1 === 1 / val2)) ||
-      (val1 !== val1 && val2 !== val2) // eslint-disable-line no-self-compare
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
     ) {
-      continue;
+      // Invoke the function an extra time to help detect side-effects.
+      getDerivedStateFromProps(nextProps, prevState);
     }
-    return false;
   }
-  return true;
-}
-
-// These are set right before calling the component.
-var renderExpirationTime = NoWork;
-// The work-in-progress fiber. I've named it differently to distinguish it from
-// the work-in-progress hook.
-var currentlyRenderingFiber$1 = null;
-
-// Hooks are stored as a linked list on the fiber's memoizedState field. The
-// current hook list is the list that belongs to the current fiber. The
-// work-in-progress hook list is a new list that will be added to the
-// work-in-progress fiber.
-var firstCurrentHook = null;
-var currentHook = null;
-var firstWorkInProgressHook = null;
-var workInProgressHook = null;
-
-var remainingExpirationTime = NoWork;
-var componentUpdateQueue = null;
-
-// Updates scheduled during render will trigger an immediate re-render at the
-// end of the current pass. We can't store these updates on the normal queue,
-// because if the work is aborted, they should be discarded. Because this is
-// a relatively rare case, we also don't want to add an additional field to
-// either the hook or queue object types. So we store them in a lazily create
-// map of queue -> render-phase updates, which are discarded once the component
-// completes without re-rendering.
-
-// Whether the work-in-progress hook is a re-rendered hook
-var isReRender = false;
-// Whether an update was scheduled during the currently executing render pass.
-var didScheduleRenderPhaseUpdate = false;
-// Lazily created map of render-phase updates
-var renderPhaseUpdates = null;
-// Counter to prevent infinite loops.
-var numberOfReRenders = 0;
-var RE_RENDER_LIMIT = 25;
 
-function resolveCurrentlyRenderingFiber() {
-  invariant(
-    currentlyRenderingFiber$1 !== null,
-    "Hooks can only be called inside the body of a function component."
-  );
-  return currentlyRenderingFiber$1;
-}
+  var partialState = getDerivedStateFromProps(nextProps, prevState);
 
-function prepareToUseHooks(current, workInProgress, nextRenderExpirationTime) {
-  if (!enableHooks) {
-    return;
+  {
+    warnOnUndefinedDerivedState(ctor, partialState);
   }
-  renderExpirationTime = nextRenderExpirationTime;
-  currentlyRenderingFiber$1 = workInProgress;
-  firstCurrentHook = current !== null ? current.memoizedState : null;
-
-  // The following should have already been reset
-  // currentHook = null;
-  // workInProgressHook = null;
-
-  // remainingExpirationTime = NoWork;
-  // componentUpdateQueue = null;
-
-  // isReRender = false;
-  // didScheduleRenderPhaseUpdate = false;
-  // renderPhaseUpdates = null;
-  // numberOfReRenders = 0;
-}
+  // Merge the partial state and the previous state.
+  var memoizedState =
+    partialState === null || partialState === undefined
+      ? prevState
+      : Object.assign({}, prevState, partialState);
+  workInProgress.memoizedState = memoizedState;
 
-function finishHooks(Component, props, children, refOrContext) {
-  if (!enableHooks) {
-    return children;
+  // Once the update queue is empty, persist the derived state onto the
+  // base state.
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
+    updateQueue.baseState = memoizedState;
   }
+}
 
-  // This must be called after every function component to prevent hooks from
-  // being used in classes.
+var classComponentUpdater = {
+  isMounted: isMounted,
+  enqueueSetState: function(inst, payload, callback) {
+    var fiber = get$1(inst);
+    var currentTime = requestCurrentTime();
+    var expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-  while (didScheduleRenderPhaseUpdate) {
-    // Updates were scheduled during the render phase. They are stored in
-    // the `renderPhaseUpdates` map. Call the component again, reusing the
-    // work-in-progress hooks and applying the additional updates on top. Keep
-    // restarting until no more updates are scheduled.
-    didScheduleRenderPhaseUpdate = false;
-    numberOfReRenders += 1;
+    var update = createUpdate(expirationTime);
+    update.payload = payload;
+    if (callback !== undefined && callback !== null) {
+      {
+        warnOnInvalidCallback(callback, "setState");
+      }
+      update.callback = callback;
+    }
 
-    // Start over from the beginning of the list
-    currentHook = null;
-    workInProgressHook = null;
-    componentUpdateQueue = null;
-
-    children = Component(props, refOrContext);
-  }
-  renderPhaseUpdates = null;
-  numberOfReRenders = 0;
-
-  var renderedWork = currentlyRenderingFiber$1;
-
-  renderedWork.memoizedState = firstWorkInProgressHook;
-  renderedWork.expirationTime = remainingExpirationTime;
-  renderedWork.updateQueue = componentUpdateQueue;
-
-  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
-
-  renderExpirationTime = NoWork;
-  currentlyRenderingFiber$1 = null;
-
-  firstCurrentHook = null;
-  currentHook = null;
-  firstWorkInProgressHook = null;
-  workInProgressHook = null;
+    flushPassiveEffects();
+    enqueueUpdate(fiber, update);
+    scheduleWork(fiber, expirationTime);
+  },
+  enqueueReplaceState: function(inst, payload, callback) {
+    var fiber = get$1(inst);
+    var currentTime = requestCurrentTime();
+    var expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-  remainingExpirationTime = NoWork;
-  componentUpdateQueue = null;
+    var update = createUpdate(expirationTime);
+    update.tag = ReplaceState;
+    update.payload = payload;
 
-  // Always set during createWorkInProgress
-  // isReRender = false;
+    if (callback !== undefined && callback !== null) {
+      {
+        warnOnInvalidCallback(callback, "replaceState");
+      }
+      update.callback = callback;
+    }
 
-  // These were reset above
-  // didScheduleRenderPhaseUpdate = false;
-  // renderPhaseUpdates = null;
-  // numberOfReRenders = 0;
+    flushPassiveEffects();
+    enqueueUpdate(fiber, update);
+    scheduleWork(fiber, expirationTime);
+  },
+  enqueueForceUpdate: function(inst, callback) {
+    var fiber = get$1(inst);
+    var currentTime = requestCurrentTime();
+    var expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-  invariant(
-    !didRenderTooFewHooks,
-    "Rendered fewer hooks than expected. This may be caused by an accidental " +
-      "early return statement."
-  );
+    var update = createUpdate(expirationTime);
+    update.tag = ForceUpdate;
 
-  return children;
-}
+    if (callback !== undefined && callback !== null) {
+      {
+        warnOnInvalidCallback(callback, "forceUpdate");
+      }
+      update.callback = callback;
+    }
 
-function resetHooks() {
-  if (!enableHooks) {
-    return;
+    flushPassiveEffects();
+    enqueueUpdate(fiber, update);
+    scheduleWork(fiber, expirationTime);
   }
+};
 
-  // This is called instead of `finishHooks` if the component throws. It's also
-  // called inside mountIndeterminateComponent if we determine the component
-  // is a module-style component.
-  renderExpirationTime = NoWork;
-  currentlyRenderingFiber$1 = null;
-
-  firstCurrentHook = null;
-  currentHook = null;
-  firstWorkInProgressHook = null;
-  workInProgressHook = null;
-
-  remainingExpirationTime = NoWork;
-  componentUpdateQueue = null;
-
-  // Always set during createWorkInProgress
-  // isReRender = false;
+function checkShouldComponentUpdate(
+  workInProgress,
+  ctor,
+  oldProps,
+  newProps,
+  oldState,
+  newState,
+  nextContext
+) {
+  var instance = workInProgress.stateNode;
+  if (typeof instance.shouldComponentUpdate === "function") {
+    startPhaseTimer(workInProgress, "shouldComponentUpdate");
+    var shouldUpdate = instance.shouldComponentUpdate(
+      newProps,
+      newState,
+      nextContext
+    );
+    stopPhaseTimer();
 
-  didScheduleRenderPhaseUpdate = false;
-  renderPhaseUpdates = null;
-  numberOfReRenders = 0;
-}
+    {
+      !(shouldUpdate !== undefined)
+        ? warningWithoutStack$1(
+            false,
+            "%s.shouldComponentUpdate(): Returned undefined instead of a " +
+              "boolean value. Make sure to return true or false.",
+            getComponentName(ctor) || "Component"
+          )
+        : void 0;
+    }
 
-function createHook() {
-  return {
-    memoizedState: null,
+    return shouldUpdate;
+  }
 
-    baseState: null,
-    queue: null,
-    baseUpdate: null,
+  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
+    return (
+      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
+    );
+  }
 
-    next: null
-  };
+  return true;
 }
 
-function cloneHook(hook) {
-  return {
-    memoizedState: hook.memoizedState,
-
-    baseState: hook.baseState,
-    queue: hook.queue,
-    baseUpdate: hook.baseUpdate,
-
-    next: null
-  };
-}
+function checkClassInstance(workInProgress, ctor, newProps) {
+  var instance = workInProgress.stateNode;
+  {
+    var name = getComponentName(ctor) || "Component";
+    var renderPresent = instance.render;
 
-function createWorkInProgressHook() {
-  if (workInProgressHook === null) {
-    // This is the first hook in the list
-    if (firstWorkInProgressHook === null) {
-      isReRender = false;
-      currentHook = firstCurrentHook;
-      if (currentHook === null) {
-        // This is a newly mounted hook
-        workInProgressHook = createHook();
-      } else {
-        // Clone the current hook.
-        workInProgressHook = cloneHook(currentHook);
-      }
-      firstWorkInProgressHook = workInProgressHook;
-    } else {
-      // There's already a work-in-progress. Reuse it.
-      isReRender = true;
-      currentHook = firstCurrentHook;
-      workInProgressHook = firstWorkInProgressHook;
-    }
-  } else {
-    if (workInProgressHook.next === null) {
-      isReRender = false;
-      var hook = void 0;
-      if (currentHook === null) {
-        // This is a newly mounted hook
-        hook = createHook();
+    if (!renderPresent) {
+      if (ctor.prototype && typeof ctor.prototype.render === "function") {
+        warningWithoutStack$1(
+          false,
+          "%s(...): No `render` method found on the returned component " +
+            "instance: did you accidentally return an object from the constructor?",
+          name
+        );
       } else {
-        currentHook = currentHook.next;
-        if (currentHook === null) {
-          // This is a newly mounted hook
-          hook = createHook();
-        } else {
-          // Clone the current hook.
-          hook = cloneHook(currentHook);
-        }
+        warningWithoutStack$1(
+          false,
+          "%s(...): No `render` method found on the returned component " +
+            "instance: you may have forgotten to define `render`.",
+          name
+        );
       }
-      // Append to the end of the list
-      workInProgressHook = workInProgressHook.next = hook;
-    } else {
-      // There's already a work-in-progress. Reuse it.
-      isReRender = true;
-      workInProgressHook = workInProgressHook.next;
-      currentHook = currentHook !== null ? currentHook.next : null;
     }
-  }
-  return workInProgressHook;
-}
-
-function createFunctionComponentUpdateQueue() {
-  return {
-    lastEffect: null
-  };
-}
-
-function basicStateReducer(state, action) {
-  return typeof action === "function" ? action(state) : action;
-}
-
-function useContext(context, observedBits) {
-  // Ensure we're in a function component (class components support only the
-  // .unstable_read() form)
-  resolveCurrentlyRenderingFiber();
-  return readContext(context, observedBits);
-}
-
-function useState(initialState) {
-  return useReducer(
-    basicStateReducer,
-    // useReducer has a special case to support lazy useState initializers
-    initialState
-  );
-}
-
-function useReducer(reducer, initialState, initialAction) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
-  var queue = workInProgressHook.queue;
-  if (queue !== null) {
-    // Already have a queue, so this is an update.
-    if (isReRender) {
-      // This is a re-render. Apply the new render phase updates to the previous
-      var _dispatch2 = queue.dispatch;
-      if (renderPhaseUpdates !== null) {
-        // Render phase updates are stored in a map of queue -> linked list
-        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
-        if (firstRenderPhaseUpdate !== undefined) {
-          renderPhaseUpdates.delete(queue);
-          var newState = workInProgressHook.memoizedState;
-          var update = firstRenderPhaseUpdate;
-          do {
-            // Process this render phase update. We don't have to check the
-            // priority because it will always be the same as the current
-            // render's.
-            var _action = update.action;
-            newState = reducer(newState, _action);
-            update = update.next;
-          } while (update !== null);
-
-          workInProgressHook.memoizedState = newState;
 
-          // Don't persist the state accumlated from the render phase updates to
-          // the base state unless the queue is empty.
-          // TODO: Not sure if this is the desired semantics, but it's what we
-          // do for gDSFP. I can't remember why.
-          if (workInProgressHook.baseUpdate === queue.last) {
-            workInProgressHook.baseState = newState;
-          }
+    var noGetInitialStateOnES6 =
+      !instance.getInitialState ||
+      instance.getInitialState.isReactClassApproved ||
+      instance.state;
+    !noGetInitialStateOnES6
+      ? warningWithoutStack$1(
+          false,
+          "getInitialState was defined on %s, a plain JavaScript class. " +
+            "This is only supported for classes created using React.createClass. " +
+            "Did you mean to define a state property instead?",
+          name
+        )
+      : void 0;
+    var noGetDefaultPropsOnES6 =
+      !instance.getDefaultProps ||
+      instance.getDefaultProps.isReactClassApproved;
+    !noGetDefaultPropsOnES6
+      ? warningWithoutStack$1(
+          false,
+          "getDefaultProps was defined on %s, a plain JavaScript class. " +
+            "This is only supported for classes created using React.createClass. " +
+            "Use a static property to define defaultProps instead.",
+          name
+        )
+      : void 0;
+    var noInstancePropTypes = !instance.propTypes;
+    !noInstancePropTypes
+      ? warningWithoutStack$1(
+          false,
+          "propTypes was defined as an instance property on %s. Use a static " +
+            "property to define propTypes instead.",
+          name
+        )
+      : void 0;
+    var noInstanceContextType = !instance.contextType;
+    !noInstanceContextType
+      ? warningWithoutStack$1(
+          false,
+          "contextType was defined as an instance property on %s. Use a static " +
+            "property to define contextType instead.",
+          name
+        )
+      : void 0;
+    var noInstanceContextTypes = !instance.contextTypes;
+    !noInstanceContextTypes
+      ? warningWithoutStack$1(
+          false,
+          "contextTypes was defined as an instance property on %s. Use a static " +
+            "property to define contextTypes instead.",
+          name
+        )
+      : void 0;
 
-          return [newState, _dispatch2];
-        }
-      }
-      return [workInProgressHook.memoizedState, _dispatch2];
+    if (
+      ctor.contextType &&
+      ctor.contextTypes &&
+      !didWarnAboutContextTypeAndContextTypes.has(ctor)
+    ) {
+      didWarnAboutContextTypeAndContextTypes.add(ctor);
+      warningWithoutStack$1(
+        false,
+        "%s declares both contextTypes and contextType static properties. " +
+          "The legacy contextTypes property will be ignored.",
+        name
+      );
     }
 
-    // The last update in the entire queue
-    var _last = queue.last;
-    // The last update that is part of the base state.
-    var _baseUpdate = workInProgressHook.baseUpdate;
-
-    // Find the first unprocessed update.
-    var first = void 0;
-    if (_baseUpdate !== null) {
-      if (_last !== null) {
-        // For the first update, the queue is a circular linked list where
-        // `queue.last.next = queue.first`. Once the first update commits, and
-        // the `baseUpdate` is no longer empty, we can unravel the list.
-        _last.next = null;
-      }
-      first = _baseUpdate.next;
-    } else {
-      first = _last !== null ? _last.next : null;
+    var noComponentShouldUpdate =
+      typeof instance.componentShouldUpdate !== "function";
+    !noComponentShouldUpdate
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
+            "The name is phrased as a question because the function is " +
+            "expected to return a value.",
+          name
+        )
+      : void 0;
+    if (
+      ctor.prototype &&
+      ctor.prototype.isPureReactComponent &&
+      typeof instance.shouldComponentUpdate !== "undefined"
+    ) {
+      warningWithoutStack$1(
+        false,
+        "%s has a method called shouldComponentUpdate(). " +
+          "shouldComponentUpdate should not be used when extending React.PureComponent. " +
+          "Please extend React.Component if shouldComponentUpdate is used.",
+        getComponentName(ctor) || "A pure component"
+      );
     }
-    if (first !== null) {
-      var _newState = workInProgressHook.baseState;
-      var newBaseState = null;
-      var newBaseUpdate = null;
-      var prevUpdate = _baseUpdate;
-      var _update = first;
-      var didSkip = false;
-      do {
-        var updateExpirationTime = _update.expirationTime;
-        if (updateExpirationTime < renderExpirationTime) {
-          // Priority is insufficient. Skip this update. If this is the first
-          // skipped update, the previous update/state is the new base
-          // update/state.
-          if (!didSkip) {
-            didSkip = true;
-            newBaseUpdate = prevUpdate;
-            newBaseState = _newState;
-          }
-          // Update the remaining priority in the queue.
-          if (updateExpirationTime > remainingExpirationTime) {
-            remainingExpirationTime = updateExpirationTime;
-          }
-        } else {
-          // Process this update.
-          var _action2 = _update.action;
-          _newState = reducer(_newState, _action2);
-        }
-        prevUpdate = _update;
-        _update = _update.next;
-      } while (_update !== null && _update !== first);
-
-      if (!didSkip) {
-        newBaseUpdate = prevUpdate;
-        newBaseState = _newState;
-      }
+    var noComponentDidUnmount =
+      typeof instance.componentDidUnmount !== "function";
+    !noComponentDidUnmount
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentDidUnmount(). But there is no such lifecycle method. " +
+            "Did you mean componentWillUnmount()?",
+          name
+        )
+      : void 0;
+    var noComponentDidReceiveProps =
+      typeof instance.componentDidReceiveProps !== "function";
+    !noComponentDidReceiveProps
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentDidReceiveProps(). But there is no such lifecycle method. " +
+            "If you meant to update the state in response to changing props, " +
+            "use componentWillReceiveProps(). If you meant to fetch data or " +
+            "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
+          name
+        )
+      : void 0;
+    var noComponentWillRecieveProps =
+      typeof instance.componentWillRecieveProps !== "function";
+    !noComponentWillRecieveProps
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
+          name
+        )
+      : void 0;
+    var noUnsafeComponentWillRecieveProps =
+      typeof instance.UNSAFE_componentWillRecieveProps !== "function";
+    !noUnsafeComponentWillRecieveProps
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
+          name
+        )
+      : void 0;
+    var hasMutatedProps = instance.props !== newProps;
+    !(instance.props === undefined || !hasMutatedProps)
+      ? warningWithoutStack$1(
+          false,
+          "%s(...): When calling super() in `%s`, make sure to pass " +
+            "up the same props that your component's constructor was passed.",
+          name,
+          name
+        )
+      : void 0;
+    var noInstanceDefaultProps = !instance.defaultProps;
+    !noInstanceDefaultProps
+      ? warningWithoutStack$1(
+          false,
+          "Setting defaultProps as an instance property on %s is not supported and will be ignored." +
+            " Instead, define defaultProps as a static property on %s.",
+          name,
+          name
+        )
+      : void 0;
 
-      workInProgressHook.memoizedState = _newState;
-      workInProgressHook.baseUpdate = newBaseUpdate;
-      workInProgressHook.baseState = newBaseState;
+    if (
+      typeof instance.getSnapshotBeforeUpdate === "function" &&
+      typeof instance.componentDidUpdate !== "function" &&
+      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
+    ) {
+      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
+      warningWithoutStack$1(
+        false,
+        "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " +
+          "This component defines getSnapshotBeforeUpdate() only.",
+        getComponentName(ctor)
+      );
     }
 
-    var _dispatch = queue.dispatch;
-    return [workInProgressHook.memoizedState, _dispatch];
+    var noInstanceGetDerivedStateFromProps =
+      typeof instance.getDerivedStateFromProps !== "function";
+    !noInstanceGetDerivedStateFromProps
+      ? warningWithoutStack$1(
+          false,
+          "%s: getDerivedStateFromProps() is defined as an instance method " +
+            "and will be ignored. Instead, declare it as a static method.",
+          name
+        )
+      : void 0;
+    var noInstanceGetDerivedStateFromCatch =
+      typeof instance.getDerivedStateFromError !== "function";
+    !noInstanceGetDerivedStateFromCatch
+      ? warningWithoutStack$1(
+          false,
+          "%s: getDerivedStateFromError() is defined as an instance method " +
+            "and will be ignored. Instead, declare it as a static method.",
+          name
+        )
+      : void 0;
+    var noStaticGetSnapshotBeforeUpdate =
+      typeof ctor.getSnapshotBeforeUpdate !== "function";
+    !noStaticGetSnapshotBeforeUpdate
+      ? warningWithoutStack$1(
+          false,
+          "%s: getSnapshotBeforeUpdate() is defined as a static method " +
+            "and will be ignored. Instead, declare it as an instance method.",
+          name
+        )
+      : void 0;
+    var _state = instance.state;
+    if (_state && (typeof _state !== "object" || isArray$1(_state))) {
+      warningWithoutStack$1(
+        false,
+        "%s.state: must be set to an object or null",
+        name
+      );
+    }
+    if (typeof instance.getChildContext === "function") {
+      !(typeof ctor.childContextTypes === "object")
+        ? warningWithoutStack$1(
+            false,
+            "%s.getChildContext(): childContextTypes must be defined in order to " +
+              "use getChildContext().",
+            name
+          )
+        : void 0;
+    }
   }
+}
 
-  // There's no existing queue, so this is the initial render.
-  if (reducer === basicStateReducer) {
-    // Special case for `useState`.
-    if (typeof initialState === "function") {
-      initialState = initialState();
-    }
-  } else if (initialAction !== undefined && initialAction !== null) {
-    initialState = reducer(initialState, initialAction);
+function adoptClassInstance(workInProgress, instance) {
+  instance.updater = classComponentUpdater;
+  workInProgress.stateNode = instance;
+  // The instance needs access to the fiber so that it can schedule updates
+  set(instance, workInProgress);
+  {
+    instance._reactInternalInstance = fakeInternalInstance;
   }
-  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
-  queue = workInProgressHook.queue = {
-    last: null,
-    dispatch: null
-  };
-  var dispatch = (queue.dispatch = dispatchAction.bind(
-    null,
-    currentlyRenderingFiber$1,
-    queue
-  ));
-  return [workInProgressHook.memoizedState, dispatch];
 }
 
-function pushEffect(tag, create, destroy, inputs) {
-  var effect = {
-    tag: tag,
-    create: create,
-    destroy: destroy,
-    inputs: inputs,
-    // Circular
-    next: null
-  };
-  if (componentUpdateQueue === null) {
-    componentUpdateQueue = createFunctionComponentUpdateQueue();
-    componentUpdateQueue.lastEffect = effect.next = effect;
+function constructClassInstance(
+  workInProgress,
+  ctor,
+  props,
+  renderExpirationTime
+) {
+  var isLegacyContextConsumer = false;
+  var unmaskedContext = emptyContextObject;
+  var context = null;
+  var contextType = ctor.contextType;
+  if (typeof contextType === "object" && contextType !== null) {
+    {
+      if (
+        contextType.$$typeof !== REACT_CONTEXT_TYPE &&
+        !didWarnAboutInvalidateContextType.has(ctor)
+      ) {
+        didWarnAboutInvalidateContextType.add(ctor);
+        warningWithoutStack$1(
+          false,
+          "%s defines an invalid contextType. " +
+            "contextType should point to the Context object returned by React.createContext(). " +
+            "Did you accidentally pass the Context.Provider instead?",
+          getComponentName(ctor) || "Component"
+        );
+      }
+    }
+
+    context = readContext(contextType);
   } else {
-    var _lastEffect = componentUpdateQueue.lastEffect;
-    if (_lastEffect === null) {
-      componentUpdateQueue.lastEffect = effect.next = effect;
-    } else {
-      var firstEffect = _lastEffect.next;
-      _lastEffect.next = effect;
-      effect.next = firstEffect;
-      componentUpdateQueue.lastEffect = effect;
+    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
+    var contextTypes = ctor.contextTypes;
+    isLegacyContextConsumer =
+      contextTypes !== null && contextTypes !== undefined;
+    context = isLegacyContextConsumer
+      ? getMaskedContext(workInProgress, unmaskedContext)
+      : emptyContextObject;
+  }
+
+  // Instantiate twice to help detect side-effects.
+  {
+    if (
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
+    ) {
+      new ctor(props, context); // eslint-disable-line no-new
     }
   }
-  return effect;
-}
 
-function useRef(initialValue) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
-  var ref = void 0;
+  var instance = new ctor(props, context);
+  var state = (workInProgress.memoizedState =
+    instance.state !== null && instance.state !== undefined
+      ? instance.state
+      : null);
+  adoptClassInstance(workInProgress, instance);
 
-  if (workInProgressHook.memoizedState === null) {
-    ref = { current: initialValue };
-    {
-      Object.seal(ref);
+  {
+    if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
+      var componentName = getComponentName(ctor) || "Component";
+      if (!didWarnAboutUninitializedState.has(componentName)) {
+        didWarnAboutUninitializedState.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "`%s` uses `getDerivedStateFromProps` but its initial state is " +
+            "%s. This is not recommended. Instead, define the initial state by " +
+            "assigning an object to `this.state` in the constructor of `%s`. " +
+            "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
+          componentName,
+          instance.state === null ? "null" : "undefined",
+          componentName
+        );
+      }
+    }
+
+    // If new component APIs are defined, "unsafe" lifecycles won't be called.
+    // Warn about these lifecycles if they are present.
+    // Don't warn about react-lifecycles-compat polyfilled methods though.
+    if (
+      typeof ctor.getDerivedStateFromProps === "function" ||
+      typeof instance.getSnapshotBeforeUpdate === "function"
+    ) {
+      var foundWillMountName = null;
+      var foundWillReceivePropsName = null;
+      var foundWillUpdateName = null;
+      if (
+        typeof instance.componentWillMount === "function" &&
+        instance.componentWillMount.__suppressDeprecationWarning !== true
+      ) {
+        foundWillMountName = "componentWillMount";
+      } else if (typeof instance.UNSAFE_componentWillMount === "function") {
+        foundWillMountName = "UNSAFE_componentWillMount";
+      }
+      if (
+        typeof instance.componentWillReceiveProps === "function" &&
+        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
+      ) {
+        foundWillReceivePropsName = "componentWillReceiveProps";
+      } else if (
+        typeof instance.UNSAFE_componentWillReceiveProps === "function"
+      ) {
+        foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
+      }
+      if (
+        typeof instance.componentWillUpdate === "function" &&
+        instance.componentWillUpdate.__suppressDeprecationWarning !== true
+      ) {
+        foundWillUpdateName = "componentWillUpdate";
+      } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
+        foundWillUpdateName = "UNSAFE_componentWillUpdate";
+      }
+      if (
+        foundWillMountName !== null ||
+        foundWillReceivePropsName !== null ||
+        foundWillUpdateName !== null
+      ) {
+        var _componentName = getComponentName(ctor) || "Component";
+        var newApiName =
+          typeof ctor.getDerivedStateFromProps === "function"
+            ? "getDerivedStateFromProps()"
+            : "getSnapshotBeforeUpdate()";
+        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
+          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
+          warningWithoutStack$1(
+            false,
+            "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
+              "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
+              "The above lifecycles should be removed. Learn more about this warning here:\n" +
+              "https://fb.me/react-async-component-lifecycle-hooks",
+            _componentName,
+            newApiName,
+            foundWillMountName !== null ? "\n  " + foundWillMountName : "",
+            foundWillReceivePropsName !== null
+              ? "\n  " + foundWillReceivePropsName
+              : "",
+            foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : ""
+          );
+        }
+      }
     }
-    workInProgressHook.memoizedState = ref;
-  } else {
-    ref = workInProgressHook.memoizedState;
   }
-  return ref;
-}
 
-function useLayoutEffect(create, inputs) {
-  useEffectImpl(Update, UnmountMutation | MountLayout, create, inputs);
-}
+  // Cache unmasked context so we can avoid recreating masked context unless necessary.
+  // ReactFiberContext usually updates this cache but can't for newly-created instances.
+  if (isLegacyContextConsumer) {
+    cacheContext(workInProgress, unmaskedContext, context);
+  }
 
-function useEffect(create, inputs) {
-  useEffectImpl(
-    Update | Passive,
-    UnmountPassive | MountPassive,
-    create,
-    inputs
-  );
+  return instance;
 }
 
-function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
+function callComponentWillMount(workInProgress, instance) {
+  startPhaseTimer(workInProgress, "componentWillMount");
+  var oldState = instance.state;
 
-  var nextInputs = inputs !== undefined && inputs !== null ? inputs : [create];
-  var destroy = null;
-  if (currentHook !== null) {
-    var prevEffect = currentHook.memoizedState;
-    destroy = prevEffect.destroy;
-    if (areHookInputsEqual(nextInputs, prevEffect.inputs)) {
-      pushEffect(NoEffect$1, create, destroy, nextInputs);
-      return;
-    }
+  if (typeof instance.componentWillMount === "function") {
+    instance.componentWillMount();
+  }
+  if (typeof instance.UNSAFE_componentWillMount === "function") {
+    instance.UNSAFE_componentWillMount();
   }
 
-  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
-  workInProgressHook.memoizedState = pushEffect(
-    hookEffectTag,
-    create,
-    destroy,
-    nextInputs
-  );
+  stopPhaseTimer();
+
+  if (oldState !== instance.state) {
+    {
+      warningWithoutStack$1(
+        false,
+        "%s.componentWillMount(): Assigning directly to this.state is " +
+          "deprecated (except inside a component's " +
+          "constructor). Use setState instead.",
+        getComponentName(workInProgress.type) || "Component"
+      );
+    }
+    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+  }
 }
 
-function useImperativeMethods(ref, create, inputs) {
-  // TODO: If inputs are provided, should we skip comparing the ref itself?
-  var nextInputs =
-    inputs !== null && inputs !== undefined
-      ? inputs.concat([ref])
-      : [ref, create];
+function callComponentWillReceiveProps(
+  workInProgress,
+  instance,
+  newProps,
+  nextContext
+) {
+  var oldState = instance.state;
+  startPhaseTimer(workInProgress, "componentWillReceiveProps");
+  if (typeof instance.componentWillReceiveProps === "function") {
+    instance.componentWillReceiveProps(newProps, nextContext);
+  }
+  if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
+    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
+  }
+  stopPhaseTimer();
 
-  // TODO: I've implemented this on top of useEffect because it's almost the
-  // same thing, and it would require an equal amount of code. It doesn't seem
-  // like a common enough use case to justify the additional size.
-  useLayoutEffect(function() {
-    if (typeof ref === "function") {
-      var refCallback = ref;
-      var _inst = create();
-      refCallback(_inst);
-      return function() {
-        return refCallback(null);
-      };
-    } else if (ref !== null && ref !== undefined) {
-      var refObject = ref;
-      var _inst2 = create();
-      refObject.current = _inst2;
-      return function() {
-        refObject.current = null;
-      };
+  if (instance.state !== oldState) {
+    {
+      var componentName = getComponentName(workInProgress.type) || "Component";
+      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
+        didWarnAboutStateAssignmentForComponent.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "%s.componentWillReceiveProps(): Assigning directly to " +
+            "this.state is deprecated (except inside a component's " +
+            "constructor). Use setState instead.",
+          componentName
+        );
+      }
     }
-  }, nextInputs);
+    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+  }
 }
 
-function useCallback(callback, inputs) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
+// Invokes the mount life-cycles on a previously never rendered instance.
+function mountClassInstance(
+  workInProgress,
+  ctor,
+  newProps,
+  renderExpirationTime
+) {
+  {
+    checkClassInstance(workInProgress, ctor, newProps);
+  }
 
-  var nextInputs =
-    inputs !== undefined && inputs !== null ? inputs : [callback];
+  var instance = workInProgress.stateNode;
+  instance.props = newProps;
+  instance.state = workInProgress.memoizedState;
+  instance.refs = emptyRefsObject;
 
-  var prevState = workInProgressHook.memoizedState;
-  if (prevState !== null) {
-    var prevInputs = prevState[1];
-    if (areHookInputsEqual(nextInputs, prevInputs)) {
-      return prevState[0];
-    }
+  var contextType = ctor.contextType;
+  if (typeof contextType === "object" && contextType !== null) {
+    instance.context = readContext(contextType);
+  } else {
+    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
+    instance.context = getMaskedContext(workInProgress, unmaskedContext);
   }
-  workInProgressHook.memoizedState = [callback, nextInputs];
-  return callback;
-}
 
-function useMemo(nextCreate, inputs) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
+  {
+    if (instance.state === newProps) {
+      var componentName = getComponentName(ctor) || "Component";
+      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
+        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "%s: It is not recommended to assign props directly to state " +
+            "because updates to props won't be reflected in state. " +
+            "In most cases, it is better to use props directly.",
+          componentName
+        );
+      }
+    }
 
-  var nextInputs =
-    inputs !== undefined && inputs !== null ? inputs : [nextCreate];
+    if (workInProgress.mode & StrictMode) {
+      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
+        workInProgress,
+        instance
+      );
 
-  var prevState = workInProgressHook.memoizedState;
-  if (prevState !== null) {
-    var prevInputs = prevState[1];
-    if (areHookInputsEqual(nextInputs, prevInputs)) {
-      return prevState[0];
+      ReactStrictModeWarnings.recordLegacyContextWarning(
+        workInProgress,
+        instance
+      );
+    }
+
+    if (warnAboutDeprecatedLifecycles) {
+      ReactStrictModeWarnings.recordDeprecationWarnings(
+        workInProgress,
+        instance
+      );
     }
   }
 
-  var nextValue = nextCreate();
-  workInProgressHook.memoizedState = [nextValue, nextInputs];
-  return nextValue;
-}
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null) {
+    processUpdateQueue(
+      workInProgress,
+      updateQueue,
+      newProps,
+      instance,
+      renderExpirationTime
+    );
+    instance.state = workInProgress.memoizedState;
+  }
 
-function dispatchAction(fiber, queue, action) {
-  invariant(
-    numberOfReRenders < RE_RENDER_LIMIT,
-    "Too many re-renders. React limits the number of renders to prevent " +
-      "an infinite loop."
-  );
+  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
+  if (typeof getDerivedStateFromProps === "function") {
+    applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      newProps
+    );
+    instance.state = workInProgress.memoizedState;
+  }
 
-  var alternate = fiber.alternate;
+  // In order to support react-lifecycles-compat polyfilled components,
+  // Unsafe lifecycles should not be invoked for components using the new APIs.
   if (
-    fiber === currentlyRenderingFiber$1 ||
-    (alternate !== null && alternate === currentlyRenderingFiber$1)
+    typeof ctor.getDerivedStateFromProps !== "function" &&
+    typeof instance.getSnapshotBeforeUpdate !== "function" &&
+    (typeof instance.UNSAFE_componentWillMount === "function" ||
+      typeof instance.componentWillMount === "function")
   ) {
-    // This is a render phase update. Stash it in a lazily-created map of
-    // queue -> linked list of updates. After this render pass, we'll restart
-    // and apply the stashed updates on top of the work-in-progress hook.
-    didScheduleRenderPhaseUpdate = true;
-    var update = {
-      expirationTime: renderExpirationTime,
-      action: action,
-      next: null
-    };
-    if (renderPhaseUpdates === null) {
-      renderPhaseUpdates = new Map();
-    }
-    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
-    if (firstRenderPhaseUpdate === undefined) {
-      renderPhaseUpdates.set(queue, update);
-    } else {
-      // Append the update to the end of the list.
-      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
-      while (lastRenderPhaseUpdate.next !== null) {
-        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
-      }
-      lastRenderPhaseUpdate.next = update;
-    }
-  } else {
-    var currentTime = requestCurrentTime();
-    var _expirationTime = computeExpirationForFiber(currentTime, fiber);
-    var _update2 = {
-      expirationTime: _expirationTime,
-      action: action,
-      next: null
-    };
-    flushPassiveEffects();
-    // Append the update to the end of the list.
-    var _last2 = queue.last;
-    if (_last2 === null) {
-      // This is the first update. Create a circular list.
-      _update2.next = _update2;
-    } else {
-      var first = _last2.next;
-      if (first !== null) {
-        // Still circular.
-        _update2.next = first;
-      }
-      _last2.next = _update2;
+    callComponentWillMount(workInProgress, instance);
+    // If we had additional state updates during this life-cycle, let's
+    // process them now.
+    updateQueue = workInProgress.updateQueue;
+    if (updateQueue !== null) {
+      processUpdateQueue(
+        workInProgress,
+        updateQueue,
+        newProps,
+        instance,
+        renderExpirationTime
+      );
+      instance.state = workInProgress.memoizedState;
     }
-    queue.last = _update2;
-    scheduleWork(fiber, _expirationTime);
   }
-}
-
-var NO_CONTEXT = {};
-
-var contextStackCursor$1 = createCursor(NO_CONTEXT);
-var contextFiberStackCursor = createCursor(NO_CONTEXT);
-var rootInstanceStackCursor = createCursor(NO_CONTEXT);
-
-function requiredContext(c) {
-  invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug " +
-      "in React. Please file an issue."
-  );
-  return c;
-}
 
-function getRootHostContainer() {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  return rootInstance;
+  if (typeof instance.componentDidMount === "function") {
+    workInProgress.effectTag |= Update;
+  }
 }
 
-function pushHostContainer(fiber, nextRootInstance) {
-  // Push current root instance onto the stack;
-  // This allows us to reset root when portals are popped.
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
+function resumeMountClassInstance(
+  workInProgress,
+  ctor,
+  newProps,
+  renderExpirationTime
+) {
+  var instance = workInProgress.stateNode;
 
-  // Finally, we need to push the host context to the stack.
-  // However, we can't just call getRootHostContext() and push it because
-  // we'd have a different number of entries on the stack depending on
-  // whether getRootHostContext() throws somewhere in renderer code or not.
-  // So we push an empty value first. This lets us safely unwind on errors.
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  var nextRootContext = getRootHostContext(nextRootInstance);
-  // Now that we know this function doesn't throw, replace it.
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, nextRootContext, fiber);
-}
+  var oldProps = workInProgress.memoizedProps;
+  instance.props = oldProps;
 
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
-}
+  var oldContext = instance.context;
+  var contextType = ctor.contextType;
+  var nextContext = void 0;
+  if (typeof contextType === "object" && contextType !== null) {
+    nextContext = readContext(contextType);
+  } else {
+    var nextLegacyUnmaskedContext = getUnmaskedContext(
+      workInProgress,
+      ctor,
+      true
+    );
+    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
+  }
 
-function getHostContext() {
-  var context = requiredContext(contextStackCursor$1.current);
-  return context;
-}
+  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
+  var hasNewLifecycles =
+    typeof getDerivedStateFromProps === "function" ||
+    typeof instance.getSnapshotBeforeUpdate === "function";
 
-function pushHostContext(fiber) {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+  // Note: During these life-cycles, instance.props/instance.state are what
+  // ever the previously attempted to render - not the "current". However,
+  // during componentDidUpdate we pass the "current" props.
 
-  // Don't push this Fiber's context unless it's unique.
-  if (context === nextContext) {
-    return;
+  // In order to support react-lifecycles-compat polyfilled components,
+  // Unsafe lifecycles should not be invoked for components using the new APIs.
+  if (
+    !hasNewLifecycles &&
+    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
+      typeof instance.componentWillReceiveProps === "function")
+  ) {
+    if (oldProps !== newProps || oldContext !== nextContext) {
+      callComponentWillReceiveProps(
+        workInProgress,
+        instance,
+        newProps,
+        nextContext
+      );
+    }
   }
 
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, nextContext, fiber);
-}
+  resetHasForceUpdateBeforeProcessing();
 
-function popHostContext(fiber) {
-  // Do not pop unless this Fiber provided the current context.
-  // pushHostContext() only pushes Fibers that provide unique contexts.
-  if (contextFiberStackCursor.current !== fiber) {
-    return;
+  var oldState = workInProgress.memoizedState;
+  var newState = (instance.state = oldState);
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null) {
+    processUpdateQueue(
+      workInProgress,
+      updateQueue,
+      newProps,
+      instance,
+      renderExpirationTime
+    );
+    newState = workInProgress.memoizedState;
+  }
+  if (
+    oldProps === newProps &&
+    oldState === newState &&
+    !hasContextChanged() &&
+    !checkHasForceUpdateAfterProcessing()
+  ) {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidMount === "function") {
+      workInProgress.effectTag |= Update;
+    }
+    return false;
   }
 
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-}
-
-var commitTime = 0;
-var profilerStartTime = -1;
+  if (typeof getDerivedStateFromProps === "function") {
+    applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      newProps
+    );
+    newState = workInProgress.memoizedState;
+  }
 
-function getCommitTime() {
-  return commitTime;
-}
+  var shouldUpdate =
+    checkHasForceUpdateAfterProcessing() ||
+    checkShouldComponentUpdate(
+      workInProgress,
+      ctor,
+      oldProps,
+      newProps,
+      oldState,
+      newState,
+      nextContext
+    );
 
-function recordCommitTime() {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  commitTime = now$$1();
-}
+  if (shouldUpdate) {
+    // In order to support react-lifecycles-compat polyfilled components,
+    // Unsafe lifecycles should not be invoked for components using the new APIs.
+    if (
+      !hasNewLifecycles &&
+      (typeof instance.UNSAFE_componentWillMount === "function" ||
+        typeof instance.componentWillMount === "function")
+    ) {
+      startPhaseTimer(workInProgress, "componentWillMount");
+      if (typeof instance.componentWillMount === "function") {
+        instance.componentWillMount();
+      }
+      if (typeof instance.UNSAFE_componentWillMount === "function") {
+        instance.UNSAFE_componentWillMount();
+      }
+      stopPhaseTimer();
+    }
+    if (typeof instance.componentDidMount === "function") {
+      workInProgress.effectTag |= Update;
+    }
+  } else {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidMount === "function") {
+      workInProgress.effectTag |= Update;
+    }
 
-function startProfilerTimer(fiber) {
-  if (!enableProfilerTimer) {
-    return;
+    // If shouldComponentUpdate returned false, we should still update the
+    // memoized state to indicate that this work can be reused.
+    workInProgress.memoizedProps = newProps;
+    workInProgress.memoizedState = newState;
   }
 
-  profilerStartTime = now$$1();
+  // Update the existing instance's state, props, and context pointers even
+  // if shouldComponentUpdate returns false.
+  instance.props = newProps;
+  instance.state = newState;
+  instance.context = nextContext;
 
-  if (fiber.actualStartTime < 0) {
-    fiber.actualStartTime = now$$1();
-  }
+  return shouldUpdate;
 }
 
-function stopProfilerTimerIfRunning(fiber) {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  profilerStartTime = -1;
-}
+// Invokes the update life-cycles and returns false if it shouldn't rerender.
+function updateClassInstance(
+  current,
+  workInProgress,
+  ctor,
+  newProps,
+  renderExpirationTime
+) {
+  var instance = workInProgress.stateNode;
 
-function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
-  if (!enableProfilerTimer) {
-    return;
-  }
+  var oldProps = workInProgress.memoizedProps;
+  instance.props =
+    workInProgress.type === workInProgress.elementType
+      ? oldProps
+      : resolveDefaultProps(workInProgress.type, oldProps);
 
-  if (profilerStartTime >= 0) {
-    var elapsedTime = now$$1() - profilerStartTime;
-    fiber.actualDuration += elapsedTime;
-    if (overrideBaseTime) {
-      fiber.selfBaseDuration = elapsedTime;
-    }
-    profilerStartTime = -1;
+  var oldContext = instance.context;
+  var contextType = ctor.contextType;
+  var nextContext = void 0;
+  if (typeof contextType === "object" && contextType !== null) {
+    nextContext = readContext(contextType);
+  } else {
+    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
+    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
   }
-}
 
-/*eslint-disable no-self-compare */
+  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
+  var hasNewLifecycles =
+    typeof getDerivedStateFromProps === "function" ||
+    typeof instance.getSnapshotBeforeUpdate === "function";
 
-var hasOwnProperty = Object.prototype.hasOwnProperty;
+  // Note: During these life-cycles, instance.props/instance.state are what
+  // ever the previously attempted to render - not the "current". However,
+  // during componentDidUpdate we pass the "current" props.
 
-/**
- * inlined Object.is polyfill to avoid requiring consumers ship their own
- * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
- */
-function is(x, y) {
-  // SameValue algorithm
-  if (x === y) {
-    // Steps 1-5, 7-10
-    // Steps 6.b-6.e: +0 != -0
-    // Added the nonzero y check to make Flow happy, but it is redundant
-    return x !== 0 || y !== 0 || 1 / x === 1 / y;
-  } else {
-    // Step 6.a: NaN == NaN
-    return x !== x && y !== y;
+  // In order to support react-lifecycles-compat polyfilled components,
+  // Unsafe lifecycles should not be invoked for components using the new APIs.
+  if (
+    !hasNewLifecycles &&
+    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
+      typeof instance.componentWillReceiveProps === "function")
+  ) {
+    if (oldProps !== newProps || oldContext !== nextContext) {
+      callComponentWillReceiveProps(
+        workInProgress,
+        instance,
+        newProps,
+        nextContext
+      );
+    }
   }
-}
 
-/**
- * Performs equality by iterating through keys on an object and returning false
- * when any key has values which are not strictly equal between the arguments.
- * Returns true when the values of all keys are strictly equal.
- */
-function shallowEqual(objA, objB) {
-  if (is(objA, objB)) {
-    return true;
+  resetHasForceUpdateBeforeProcessing();
+
+  var oldState = workInProgress.memoizedState;
+  var newState = (instance.state = oldState);
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null) {
+    processUpdateQueue(
+      workInProgress,
+      updateQueue,
+      newProps,
+      instance,
+      renderExpirationTime
+    );
+    newState = workInProgress.memoizedState;
   }
 
   if (
-    typeof objA !== "object" ||
-    objA === null ||
-    typeof objB !== "object" ||
-    objB === null
+    oldProps === newProps &&
+    oldState === newState &&
+    !hasContextChanged() &&
+    !checkHasForceUpdateAfterProcessing()
   ) {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Update;
+      }
+    }
+    if (typeof instance.getSnapshotBeforeUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Snapshot;
+      }
+    }
     return false;
   }
 
-  var keysA = Object.keys(objA);
-  var keysB = Object.keys(objB);
-
-  if (keysA.length !== keysB.length) {
-    return false;
+  if (typeof getDerivedStateFromProps === "function") {
+    applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      newProps
+    );
+    newState = workInProgress.memoizedState;
   }
 
-  // Test for A's keys different from B.
-  for (var i = 0; i < keysA.length; i++) {
+  var shouldUpdate =
+    checkHasForceUpdateAfterProcessing() ||
+    checkShouldComponentUpdate(
+      workInProgress,
+      ctor,
+      oldProps,
+      newProps,
+      oldState,
+      newState,
+      nextContext
+    );
+
+  if (shouldUpdate) {
+    // In order to support react-lifecycles-compat polyfilled components,
+    // Unsafe lifecycles should not be invoked for components using the new APIs.
     if (
-      !hasOwnProperty.call(objB, keysA[i]) ||
-      !is(objA[keysA[i]], objB[keysA[i]])
+      !hasNewLifecycles &&
+      (typeof instance.UNSAFE_componentWillUpdate === "function" ||
+        typeof instance.componentWillUpdate === "function")
     ) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
-    var props = Object.assign({}, baseProps);
-    var defaultProps = Component.defaultProps;
-    for (var propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
+      startPhaseTimer(workInProgress, "componentWillUpdate");
+      if (typeof instance.componentWillUpdate === "function") {
+        instance.componentWillUpdate(newProps, newState, nextContext);
+      }
+      if (typeof instance.UNSAFE_componentWillUpdate === "function") {
+        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
       }
+      stopPhaseTimer();
     }
-    return props;
-  }
-  return baseProps;
-}
-
-function readLazyComponentType(lazyComponent) {
-  var status = lazyComponent._status;
-  var result = lazyComponent._result;
-  switch (status) {
-    case Resolved: {
-      var Component = result;
-      return Component;
+    if (typeof instance.componentDidUpdate === "function") {
+      workInProgress.effectTag |= Update;
     }
-    case Rejected: {
-      var error = result;
-      throw error;
+    if (typeof instance.getSnapshotBeforeUpdate === "function") {
+      workInProgress.effectTag |= Snapshot;
     }
-    case Pending: {
-      var thenable = result;
-      throw thenable;
+  } else {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Update;
+      }
     }
-    default: {
-      lazyComponent._status = Pending;
-      var ctor = lazyComponent._ctor;
-      var _thenable = ctor();
-      _thenable.then(
-        function(moduleObject) {
-          if (lazyComponent._status === Pending) {
-            var defaultExport = moduleObject.default;
-            {
-              if (defaultExport === undefined) {
-                warning$1(
-                  false,
-                  "lazy: Expected the result of a dynamic import() call. " +
-                    "Instead received: %s\n\nYour code should look like: \n  " +
-                    "const MyComponent = lazy(() => import('./MyComponent'))",
-                  moduleObject
-                );
-              }
-            }
-            lazyComponent._status = Resolved;
-            lazyComponent._result = defaultExport;
-          }
-        },
-        function(error) {
-          if (lazyComponent._status === Pending) {
-            lazyComponent._status = Rejected;
-            lazyComponent._result = error;
-          }
-        }
-      );
-      lazyComponent._result = _thenable;
-      throw _thenable;
+    if (typeof instance.getSnapshotBeforeUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Snapshot;
+      }
     }
+
+    // If shouldComponentUpdate returned false, we should still update the
+    // memoized props/state to indicate that this work can be reused.
+    workInProgress.memoizedProps = newProps;
+    workInProgress.memoizedState = newState;
   }
-}
 
-var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner;
+  // Update the existing instance's state, props, and context pointers even
+  // if shouldComponentUpdate returns false.
+  instance.props = newProps;
+  instance.state = newState;
+  instance.context = nextContext;
 
-function readContext$1(contextType) {
-  var dispatcher = ReactCurrentOwner$4.currentDispatcher;
-  return dispatcher.readContext(contextType);
+  return shouldUpdate;
 }
 
-var fakeInternalInstance = {};
-var isArray$1 = Array.isArray;
-
-// React.Component uses a shared frozen object by default.
-// We'll use it to determine whether we need to initialize legacy refs.
-var emptyRefsObject = new React.Component().refs;
-
-var didWarnAboutStateAssignmentForComponent = void 0;
-var didWarnAboutUninitializedState = void 0;
-var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
-var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
-var didWarnAboutUndefinedDerivedState = void 0;
-var warnOnUndefinedDerivedState = void 0;
-var warnOnInvalidCallback = void 0;
-var didWarnAboutDirectlyAssigningPropsToState = void 0;
-var didWarnAboutContextTypeAndContextTypes = void 0;
-var didWarnAboutInvalidateContextType = void 0;
+var didWarnAboutMaps = void 0;
+var didWarnAboutGenerators = void 0;
+var didWarnAboutStringRefInStrictMode = void 0;
+var ownerHasKeyUseWarning = void 0;
+var ownerHasFunctionTypeWarning = void 0;
+var warnForMissingKey = function(child) {};
 
 {
-  didWarnAboutStateAssignmentForComponent = new Set();
-  didWarnAboutUninitializedState = new Set();
-  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
-  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
-  didWarnAboutDirectlyAssigningPropsToState = new Set();
-  didWarnAboutUndefinedDerivedState = new Set();
-  didWarnAboutContextTypeAndContextTypes = new Set();
-  didWarnAboutInvalidateContextType = new Set();
+  didWarnAboutMaps = false;
+  didWarnAboutGenerators = false;
+  didWarnAboutStringRefInStrictMode = {};
 
-  var didWarnOnInvalidCallback = new Set();
+  /**
+   * Warn if there's no key explicitly set on dynamic arrays of children or
+   * object keys are not valid. This allows us to keep track of children between
+   * updates.
+   */
+  ownerHasKeyUseWarning = {};
+  ownerHasFunctionTypeWarning = {};
 
-  warnOnInvalidCallback = function(callback, callerName) {
-    if (callback === null || typeof callback === "function") {
+  warnForMissingKey = function(child) {
+    if (child === null || typeof child !== "object") {
       return;
     }
-    var key = callerName + "_" + callback;
-    if (!didWarnOnInvalidCallback.has(key)) {
-      didWarnOnInvalidCallback.add(key);
-      warningWithoutStack$1(
-        false,
-        "%s(...): Expected the last optional `callback` argument to be a " +
-          "function. Instead received: %s.",
-        callerName,
-        callback
-      );
+    if (!child._store || child._store.validated || child.key != null) {
+      return;
+    }
+    invariant(
+      typeof child._store === "object",
+      "React Component in warnForMissingKey should have a _store. " +
+        "This error is likely caused by a bug in React. Please file an issue."
+    );
+    child._store.validated = true;
+
+    var currentComponentErrorInfo =
+      "Each child in a list should have a unique " +
+      '"key" prop. See https://fb.me/react-warning-keys for ' +
+      "more information." +
+      getCurrentFiberStackInDev();
+    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
+      return;
     }
+    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
+
+    warning$1(
+      false,
+      "Each child in a list should have a unique " +
+        '"key" prop. See https://fb.me/react-warning-keys for ' +
+        "more information."
+    );
   };
+}
 
-  warnOnUndefinedDerivedState = function(type, partialState) {
-    if (partialState === undefined) {
-      var componentName = getComponentName(type) || "Component";
-      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
-        didWarnAboutUndefinedDerivedState.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " +
-            "You have returned undefined.",
-          componentName
-        );
+var isArray = Array.isArray;
+
+function coerceRef(returnFiber, current$$1, element) {
+  var mixedRef = element.ref;
+  if (
+    mixedRef !== null &&
+    typeof mixedRef !== "function" &&
+    typeof mixedRef !== "object"
+  ) {
+    {
+      if (returnFiber.mode & StrictMode) {
+        var componentName = getComponentName(returnFiber.type) || "Component";
+        if (!didWarnAboutStringRefInStrictMode[componentName]) {
+          warningWithoutStack$1(
+            false,
+            'A string ref, "%s", has been found within a strict mode tree. ' +
+              "String refs are a source of potential bugs and should be avoided. " +
+              "We recommend using createRef() instead." +
+              "\n%s" +
+              "\n\nLearn more about using refs safely here:" +
+              "\nhttps://fb.me/react-strict-mode-string-ref",
+            mixedRef,
+            getStackByFiberInDevAndProd(returnFiber)
+          );
+          didWarnAboutStringRefInStrictMode[componentName] = true;
+        }
       }
     }
-  };
 
-  // This is so gross but it's at least non-critical and can be removed if
-  // it causes problems. This is meant to give a nicer error message for
-  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
-  // ...)) which otherwise throws a "_processChildContext is not a function"
-  // exception.
-  Object.defineProperty(fakeInternalInstance, "_processChildContext", {
-    enumerable: false,
-    value: function() {
+    if (element._owner) {
+      var owner = element._owner;
+      var inst = void 0;
+      if (owner) {
+        var ownerFiber = owner;
+        invariant(
+          ownerFiber.tag === ClassComponent,
+          "Function components cannot have refs. " +
+            "Did you mean to use React.forwardRef()?"
+        );
+        inst = ownerFiber.stateNode;
+      }
       invariant(
-        false,
-        "_processChildContext is not available in React 16+. This likely " +
-          "means you have multiple copies of React and are attempting to nest " +
-          "a React 15 tree inside a React 16 tree using " +
-          "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
-          "to make sure you have only one copy of React (and ideally, switch " +
-          "to ReactDOM.createPortal)."
+        inst,
+        "Missing owner for string ref %s. This error is likely caused by a " +
+          "bug in React. Please file an issue.",
+        mixedRef
+      );
+      var stringRef = "" + mixedRef;
+      // Check if previous string ref matches new string ref
+      if (
+        current$$1 !== null &&
+        current$$1.ref !== null &&
+        typeof current$$1.ref === "function" &&
+        current$$1.ref._stringRef === stringRef
+      ) {
+        return current$$1.ref;
+      }
+      var ref = function(value) {
+        var refs = inst.refs;
+        if (refs === emptyRefsObject) {
+          // This is a lazy pooled frozen object, so we need to initialize.
+          refs = inst.refs = {};
+        }
+        if (value === null) {
+          delete refs[stringRef];
+        } else {
+          refs[stringRef] = value;
+        }
+      };
+      ref._stringRef = stringRef;
+      return ref;
+    } else {
+      invariant(
+        typeof mixedRef === "string",
+        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
+      );
+      invariant(
+        element._owner,
+        "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" +
+          " the following reasons:\n" +
+          "1. You may be adding a ref to a function component\n" +
+          "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
+          "3. You have multiple copies of React loaded\n" +
+          "See https://fb.me/react-refs-must-have-owner for more information.",
+        mixedRef
       );
     }
-  });
-  Object.freeze(fakeInternalInstance);
+  }
+  return mixedRef;
 }
 
-function applyDerivedStateFromProps(
-  workInProgress,
-  ctor,
-  getDerivedStateFromProps,
-  nextProps
-) {
-  var prevState = workInProgress.memoizedState;
-
-  {
-    if (
-      debugRenderPhaseSideEffects ||
-      (debugRenderPhaseSideEffectsForStrictMode &&
-        workInProgress.mode & StrictMode)
-    ) {
-      // Invoke the function an extra time to help detect side-effects.
-      getDerivedStateFromProps(nextProps, prevState);
+function throwOnInvalidObjectType(returnFiber, newChild) {
+  if (returnFiber.type !== "textarea") {
+    var addendum = "";
+    {
+      addendum =
+        " If you meant to render a collection of children, use an array " +
+        "instead." +
+        getCurrentFiberStackInDev();
     }
+    invariant(
+      false,
+      "Objects are not valid as a React child (found: %s).%s",
+      Object.prototype.toString.call(newChild) === "[object Object]"
+        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
+        : newChild,
+      addendum
+    );
   }
+}
 
-  var partialState = getDerivedStateFromProps(nextProps, prevState);
+function warnOnFunctionType() {
+  var currentComponentErrorInfo =
+    "Functions are not valid as a React child. This may happen if " +
+    "you return a Component instead of <Component /> from render. " +
+    "Or maybe you meant to call this function rather than return it." +
+    getCurrentFiberStackInDev();
 
-  {
-    warnOnUndefinedDerivedState(ctor, partialState);
+  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
+    return;
   }
-  // Merge the partial state and the previous state.
-  var memoizedState =
-    partialState === null || partialState === undefined
-      ? prevState
-      : Object.assign({}, prevState, partialState);
-  workInProgress.memoizedState = memoizedState;
+  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
 
-  // Once the update queue is empty, persist the derived state onto the
-  // base state.
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
-    updateQueue.baseState = memoizedState;
-  }
+  warning$1(
+    false,
+    "Functions are not valid as a React child. This may happen if " +
+      "you return a Component instead of <Component /> from render. " +
+      "Or maybe you meant to call this function rather than return it."
+  );
 }
 
-var classComponentUpdater = {
-  isMounted: isMounted,
-  enqueueSetState: function(inst, payload, callback) {
-    var fiber = get$1(inst);
-    var currentTime = requestCurrentTime();
-    var expirationTime = computeExpirationForFiber(currentTime, fiber);
-
-    var update = createUpdate(expirationTime);
-    update.payload = payload;
-    if (callback !== undefined && callback !== null) {
-      {
-        warnOnInvalidCallback(callback, "setState");
-      }
-      update.callback = callback;
+// This wrapper function exists because I expect to clone the code in each path
+// to be able to optimize each path individually by branching early. This needs
+// a compiler or we can do it manually. Helpers that don't need this branching
+// live outside of this function.
+function ChildReconciler(shouldTrackSideEffects) {
+  function deleteChild(returnFiber, childToDelete) {
+    if (!shouldTrackSideEffects) {
+      // Noop.
+      return;
+    }
+    // Deletions are added in reversed order so we add it to the front.
+    // At this point, the return fiber's effect list is empty except for
+    // deletions, so we can just append the deletion to the list. The remaining
+    // effects aren't added until the complete phase. Once we implement
+    // resuming, this may not be true.
+    var last = returnFiber.lastEffect;
+    if (last !== null) {
+      last.nextEffect = childToDelete;
+      returnFiber.lastEffect = childToDelete;
+    } else {
+      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
+    }
+    childToDelete.nextEffect = null;
+    childToDelete.effectTag = Deletion;
+  }
+
+  function deleteRemainingChildren(returnFiber, currentFirstChild) {
+    if (!shouldTrackSideEffects) {
+      // Noop.
+      return null;
     }
 
-    flushPassiveEffects();
-    enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
-  },
-  enqueueReplaceState: function(inst, payload, callback) {
-    var fiber = get$1(inst);
-    var currentTime = requestCurrentTime();
-    var expirationTime = computeExpirationForFiber(currentTime, fiber);
+    // TODO: For the shouldClone case, this could be micro-optimized a bit by
+    // assuming that after the first child we've already added everything.
+    var childToDelete = currentFirstChild;
+    while (childToDelete !== null) {
+      deleteChild(returnFiber, childToDelete);
+      childToDelete = childToDelete.sibling;
+    }
+    return null;
+  }
 
-    var update = createUpdate(expirationTime);
-    update.tag = ReplaceState;
-    update.payload = payload;
+  function mapRemainingChildren(returnFiber, currentFirstChild) {
+    // Add the remaining children to a temporary map so that we can find them by
+    // keys quickly. Implicit (null) keys get added to this set with their index
+    var existingChildren = new Map();
 
-    if (callback !== undefined && callback !== null) {
-      {
-        warnOnInvalidCallback(callback, "replaceState");
+    var existingChild = currentFirstChild;
+    while (existingChild !== null) {
+      if (existingChild.key !== null) {
+        existingChildren.set(existingChild.key, existingChild);
+      } else {
+        existingChildren.set(existingChild.index, existingChild);
       }
-      update.callback = callback;
+      existingChild = existingChild.sibling;
     }
+    return existingChildren;
+  }
 
-    flushPassiveEffects();
-    enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
-  },
-  enqueueForceUpdate: function(inst, callback) {
-    var fiber = get$1(inst);
-    var currentTime = requestCurrentTime();
-    var expirationTime = computeExpirationForFiber(currentTime, fiber);
-
-    var update = createUpdate(expirationTime);
-    update.tag = ForceUpdate;
+  function useFiber(fiber, pendingProps, expirationTime) {
+    // We currently set sibling to null and index to 0 here because it is easy
+    // to forget to do before returning it. E.g. for the single child case.
+    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
+    clone.index = 0;
+    clone.sibling = null;
+    return clone;
+  }
 
-    if (callback !== undefined && callback !== null) {
-      {
-        warnOnInvalidCallback(callback, "forceUpdate");
+  function placeChild(newFiber, lastPlacedIndex, newIndex) {
+    newFiber.index = newIndex;
+    if (!shouldTrackSideEffects) {
+      // Noop.
+      return lastPlacedIndex;
+    }
+    var current$$1 = newFiber.alternate;
+    if (current$$1 !== null) {
+      var oldIndex = current$$1.index;
+      if (oldIndex < lastPlacedIndex) {
+        // This is a move.
+        newFiber.effectTag = Placement;
+        return lastPlacedIndex;
+      } else {
+        // This item can stay in place.
+        return oldIndex;
       }
-      update.callback = callback;
+    } else {
+      // This is an insertion.
+      newFiber.effectTag = Placement;
+      return lastPlacedIndex;
     }
-
-    flushPassiveEffects();
-    enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
   }
-};
-
-function checkShouldComponentUpdate(
-  workInProgress,
-  ctor,
-  oldProps,
-  newProps,
-  oldState,
-  newState,
-  nextContext
-) {
-  var instance = workInProgress.stateNode;
-  if (typeof instance.shouldComponentUpdate === "function") {
-    startPhaseTimer(workInProgress, "shouldComponentUpdate");
-    var shouldUpdate = instance.shouldComponentUpdate(
-      newProps,
-      newState,
-      nextContext
-    );
-    stopPhaseTimer();
 
-    {
-      !(shouldUpdate !== undefined)
-        ? warningWithoutStack$1(
-            false,
-            "%s.shouldComponentUpdate(): Returned undefined instead of a " +
-              "boolean value. Make sure to return true or false.",
-            getComponentName(ctor) || "Component"
-          )
-        : void 0;
+  function placeSingleChild(newFiber) {
+    // This is simpler for the single child case. We only need to do a
+    // placement for inserting new children.
+    if (shouldTrackSideEffects && newFiber.alternate === null) {
+      newFiber.effectTag = Placement;
     }
-
-    return shouldUpdate;
+    return newFiber;
   }
 
-  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
-    return (
-      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
-    );
+  function updateTextNode(
+    returnFiber,
+    current$$1,
+    textContent,
+    expirationTime
+  ) {
+    if (current$$1 === null || current$$1.tag !== HostText) {
+      // Insert
+      var created = createFiberFromText(
+        textContent,
+        returnFiber.mode,
+        expirationTime
+      );
+      created.return = returnFiber;
+      return created;
+    } else {
+      // Update
+      var existing = useFiber(current$$1, textContent, expirationTime);
+      existing.return = returnFiber;
+      return existing;
+    }
   }
 
-  return true;
-}
-
-function checkClassInstance(workInProgress, ctor, newProps) {
-  var instance = workInProgress.stateNode;
-  {
-    var name = getComponentName(ctor) || "Component";
-    var renderPresent = instance.render;
-
-    if (!renderPresent) {
-      if (ctor.prototype && typeof ctor.prototype.render === "function") {
-        warningWithoutStack$1(
-          false,
-          "%s(...): No `render` method found on the returned component " +
-            "instance: did you accidentally return an object from the constructor?",
-          name
-        );
-      } else {
-        warningWithoutStack$1(
-          false,
-          "%s(...): No `render` method found on the returned component " +
-            "instance: you may have forgotten to define `render`.",
-          name
-        );
+  function updateElement(returnFiber, current$$1, element, expirationTime) {
+    if (current$$1 !== null && current$$1.elementType === element.type) {
+      // Move based on index
+      var existing = useFiber(current$$1, element.props, expirationTime);
+      existing.ref = coerceRef(returnFiber, current$$1, element);
+      existing.return = returnFiber;
+      {
+        existing._debugSource = element._source;
+        existing._debugOwner = element._owner;
       }
-    }
-
-    var noGetInitialStateOnES6 =
-      !instance.getInitialState ||
-      instance.getInitialState.isReactClassApproved ||
-      instance.state;
-    !noGetInitialStateOnES6
-      ? warningWithoutStack$1(
-          false,
-          "getInitialState was defined on %s, a plain JavaScript class. " +
-            "This is only supported for classes created using React.createClass. " +
-            "Did you mean to define a state property instead?",
-          name
-        )
-      : void 0;
-    var noGetDefaultPropsOnES6 =
-      !instance.getDefaultProps ||
-      instance.getDefaultProps.isReactClassApproved;
-    !noGetDefaultPropsOnES6
-      ? warningWithoutStack$1(
-          false,
-          "getDefaultProps was defined on %s, a plain JavaScript class. " +
-            "This is only supported for classes created using React.createClass. " +
-            "Use a static property to define defaultProps instead.",
-          name
-        )
-      : void 0;
-    var noInstancePropTypes = !instance.propTypes;
-    !noInstancePropTypes
-      ? warningWithoutStack$1(
-          false,
-          "propTypes was defined as an instance property on %s. Use a static " +
-            "property to define propTypes instead.",
-          name
-        )
-      : void 0;
-    var noInstanceContextType = !instance.contextType;
-    !noInstanceContextType
-      ? warningWithoutStack$1(
-          false,
-          "contextType was defined as an instance property on %s. Use a static " +
-            "property to define contextType instead.",
-          name
-        )
-      : void 0;
-    var noInstanceContextTypes = !instance.contextTypes;
-    !noInstanceContextTypes
-      ? warningWithoutStack$1(
-          false,
-          "contextTypes was defined as an instance property on %s. Use a static " +
-            "property to define contextTypes instead.",
-          name
-        )
-      : void 0;
-
-    if (
-      ctor.contextType &&
-      ctor.contextTypes &&
-      !didWarnAboutContextTypeAndContextTypes.has(ctor)
-    ) {
-      didWarnAboutContextTypeAndContextTypes.add(ctor);
-      warningWithoutStack$1(
-        false,
-        "%s declares both contextTypes and contextType static properties. " +
-          "The legacy contextTypes property will be ignored.",
-        name
+      return existing;
+    } else {
+      // Insert
+      var created = createFiberFromElement(
+        element,
+        returnFiber.mode,
+        expirationTime
       );
+      created.ref = coerceRef(returnFiber, current$$1, element);
+      created.return = returnFiber;
+      return created;
     }
+  }
 
-    var noComponentShouldUpdate =
-      typeof instance.componentShouldUpdate !== "function";
-    !noComponentShouldUpdate
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
-            "The name is phrased as a question because the function is " +
-            "expected to return a value.",
-          name
-        )
-      : void 0;
+  function updatePortal(returnFiber, current$$1, portal, expirationTime) {
     if (
-      ctor.prototype &&
-      ctor.prototype.isPureReactComponent &&
-      typeof instance.shouldComponentUpdate !== "undefined"
+      current$$1 === null ||
+      current$$1.tag !== HostPortal ||
+      current$$1.stateNode.containerInfo !== portal.containerInfo ||
+      current$$1.stateNode.implementation !== portal.implementation
     ) {
-      warningWithoutStack$1(
-        false,
-        "%s has a method called shouldComponentUpdate(). " +
-          "shouldComponentUpdate should not be used when extending React.PureComponent. " +
-          "Please extend React.Component if shouldComponentUpdate is used.",
-        getComponentName(ctor) || "A pure component"
+      // Insert
+      var created = createFiberFromPortal(
+        portal,
+        returnFiber.mode,
+        expirationTime
       );
-    }
-    var noComponentDidUnmount =
-      typeof instance.componentDidUnmount !== "function";
-    !noComponentDidUnmount
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentDidUnmount(). But there is no such lifecycle method. " +
-            "Did you mean componentWillUnmount()?",
-          name
-        )
-      : void 0;
-    var noComponentDidReceiveProps =
-      typeof instance.componentDidReceiveProps !== "function";
-    !noComponentDidReceiveProps
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentDidReceiveProps(). But there is no such lifecycle method. " +
-            "If you meant to update the state in response to changing props, " +
-            "use componentWillReceiveProps(). If you meant to fetch data or " +
-            "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
-          name
-        )
-      : void 0;
-    var noComponentWillRecieveProps =
-      typeof instance.componentWillRecieveProps !== "function";
-    !noComponentWillRecieveProps
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
-          name
-        )
-      : void 0;
-    var noUnsafeComponentWillRecieveProps =
-      typeof instance.UNSAFE_componentWillRecieveProps !== "function";
-    !noUnsafeComponentWillRecieveProps
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
-          name
-        )
-      : void 0;
-    var hasMutatedProps = instance.props !== newProps;
-    !(instance.props === undefined || !hasMutatedProps)
-      ? warningWithoutStack$1(
-          false,
-          "%s(...): When calling super() in `%s`, make sure to pass " +
-            "up the same props that your component's constructor was passed.",
-          name,
-          name
-        )
-      : void 0;
-    var noInstanceDefaultProps = !instance.defaultProps;
-    !noInstanceDefaultProps
-      ? warningWithoutStack$1(
-          false,
-          "Setting defaultProps as an instance property on %s is not supported and will be ignored." +
-            " Instead, define defaultProps as a static property on %s.",
-          name,
-          name
-        )
-      : void 0;
-
-    if (
-      typeof instance.getSnapshotBeforeUpdate === "function" &&
-      typeof instance.componentDidUpdate !== "function" &&
-      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
-    ) {
-      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
-      warningWithoutStack$1(
-        false,
-        "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " +
-          "This component defines getSnapshotBeforeUpdate() only.",
-        getComponentName(ctor)
+      created.return = returnFiber;
+      return created;
+    } else {
+      // Update
+      var existing = useFiber(
+        current$$1,
+        portal.children || [],
+        expirationTime
       );
+      existing.return = returnFiber;
+      return existing;
     }
+  }
 
-    var noInstanceGetDerivedStateFromProps =
-      typeof instance.getDerivedStateFromProps !== "function";
-    !noInstanceGetDerivedStateFromProps
-      ? warningWithoutStack$1(
-          false,
-          "%s: getDerivedStateFromProps() is defined as an instance method " +
-            "and will be ignored. Instead, declare it as a static method.",
-          name
-        )
-      : void 0;
-    var noInstanceGetDerivedStateFromCatch =
-      typeof instance.getDerivedStateFromError !== "function";
-    !noInstanceGetDerivedStateFromCatch
-      ? warningWithoutStack$1(
-          false,
-          "%s: getDerivedStateFromError() is defined as an instance method " +
-            "and will be ignored. Instead, declare it as a static method.",
-          name
-        )
-      : void 0;
-    var noStaticGetSnapshotBeforeUpdate =
-      typeof ctor.getSnapshotBeforeUpdate !== "function";
-    !noStaticGetSnapshotBeforeUpdate
-      ? warningWithoutStack$1(
-          false,
-          "%s: getSnapshotBeforeUpdate() is defined as a static method " +
-            "and will be ignored. Instead, declare it as an instance method.",
-          name
-        )
-      : void 0;
-    var _state = instance.state;
-    if (_state && (typeof _state !== "object" || isArray$1(_state))) {
-      warningWithoutStack$1(
-        false,
-        "%s.state: must be set to an object or null",
-        name
+  function updateFragment(
+    returnFiber,
+    current$$1,
+    fragment,
+    expirationTime,
+    key
+  ) {
+    if (current$$1 === null || current$$1.tag !== Fragment) {
+      // Insert
+      var created = createFiberFromFragment(
+        fragment,
+        returnFiber.mode,
+        expirationTime,
+        key
       );
-    }
-    if (typeof instance.getChildContext === "function") {
-      !(typeof ctor.childContextTypes === "object")
-        ? warningWithoutStack$1(
-            false,
-            "%s.getChildContext(): childContextTypes must be defined in order to " +
-              "use getChildContext().",
-            name
-          )
-        : void 0;
+      created.return = returnFiber;
+      return created;
+    } else {
+      // Update
+      var existing = useFiber(current$$1, fragment, expirationTime);
+      existing.return = returnFiber;
+      return existing;
     }
   }
-}
 
-function adoptClassInstance(workInProgress, instance) {
-  instance.updater = classComponentUpdater;
-  workInProgress.stateNode = instance;
-  // The instance needs access to the fiber so that it can schedule updates
-  set(instance, workInProgress);
-  {
-    instance._reactInternalInstance = fakeInternalInstance;
-  }
-}
+  function createChild(returnFiber, newChild, expirationTime) {
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      // Text nodes don't have keys. If the previous node is implicitly keyed
+      // we can continue to replace it without aborting even if it is not a text
+      // node.
+      var created = createFiberFromText(
+        "" + newChild,
+        returnFiber.mode,
+        expirationTime
+      );
+      created.return = returnFiber;
+      return created;
+    }
 
-function constructClassInstance(
-  workInProgress,
-  ctor,
-  props,
-  renderExpirationTime
-) {
-  var isLegacyContextConsumer = false;
-  var unmaskedContext = emptyContextObject;
-  var context = null;
-  var contextType = ctor.contextType;
-  if (typeof contextType === "object" && contextType !== null) {
-    {
-      if (
-        contextType.$$typeof !== REACT_CONTEXT_TYPE &&
-        !didWarnAboutInvalidateContextType.has(ctor)
-      ) {
-        didWarnAboutInvalidateContextType.add(ctor);
-        warningWithoutStack$1(
-          false,
-          "%s defines an invalid contextType. " +
-            "contextType should point to the Context object returned by React.createContext(). " +
-            "Did you accidentally pass the Context.Provider instead?",
-          getComponentName(ctor) || "Component"
+    if (typeof newChild === "object" && newChild !== null) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE: {
+          var _created = createFiberFromElement(
+            newChild,
+            returnFiber.mode,
+            expirationTime
+          );
+          _created.ref = coerceRef(returnFiber, null, newChild);
+          _created.return = returnFiber;
+          return _created;
+        }
+        case REACT_PORTAL_TYPE: {
+          var _created2 = createFiberFromPortal(
+            newChild,
+            returnFiber.mode,
+            expirationTime
+          );
+          _created2.return = returnFiber;
+          return _created2;
+        }
+      }
+
+      if (isArray(newChild) || getIteratorFn(newChild)) {
+        var _created3 = createFiberFromFragment(
+          newChild,
+          returnFiber.mode,
+          expirationTime,
+          null
         );
+        _created3.return = returnFiber;
+        return _created3;
       }
-    }
 
-    context = readContext$1(contextType);
-  } else {
-    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-    var contextTypes = ctor.contextTypes;
-    isLegacyContextConsumer =
-      contextTypes !== null && contextTypes !== undefined;
-    context = isLegacyContextConsumer
-      ? getMaskedContext(workInProgress, unmaskedContext)
-      : emptyContextObject;
-  }
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
 
-  // Instantiate twice to help detect side-effects.
-  {
-    if (
-      debugRenderPhaseSideEffects ||
-      (debugRenderPhaseSideEffectsForStrictMode &&
-        workInProgress.mode & StrictMode)
-    ) {
-      new ctor(props, context); // eslint-disable-line no-new
+    {
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
+      }
     }
+
+    return null;
   }
 
-  var instance = new ctor(props, context);
-  var state = (workInProgress.memoizedState =
-    instance.state !== null && instance.state !== undefined
-      ? instance.state
-      : null);
-  adoptClassInstance(workInProgress, instance);
+  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
+    // Update the fiber if the keys match, otherwise return null.
 
-  {
-    if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
-      var componentName = getComponentName(ctor) || "Component";
-      if (!didWarnAboutUninitializedState.has(componentName)) {
-        didWarnAboutUninitializedState.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "`%s` uses `getDerivedStateFromProps` but its initial state is " +
-            "%s. This is not recommended. Instead, define the initial state by " +
-            "assigning an object to `this.state` in the constructor of `%s`. " +
-            "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
-          componentName,
-          instance.state === null ? "null" : "undefined",
-          componentName
-        );
+    var key = oldFiber !== null ? oldFiber.key : null;
+
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      // Text nodes don't have keys. If the previous node is implicitly keyed
+      // we can continue to replace it without aborting even if it is not a text
+      // node.
+      if (key !== null) {
+        return null;
       }
+      return updateTextNode(
+        returnFiber,
+        oldFiber,
+        "" + newChild,
+        expirationTime
+      );
     }
 
-    // If new component APIs are defined, "unsafe" lifecycles won't be called.
-    // Warn about these lifecycles if they are present.
-    // Don't warn about react-lifecycles-compat polyfilled methods though.
-    if (
-      typeof ctor.getDerivedStateFromProps === "function" ||
-      typeof instance.getSnapshotBeforeUpdate === "function"
-    ) {
-      var foundWillMountName = null;
-      var foundWillReceivePropsName = null;
-      var foundWillUpdateName = null;
-      if (
-        typeof instance.componentWillMount === "function" &&
-        instance.componentWillMount.__suppressDeprecationWarning !== true
-      ) {
-        foundWillMountName = "componentWillMount";
-      } else if (typeof instance.UNSAFE_componentWillMount === "function") {
-        foundWillMountName = "UNSAFE_componentWillMount";
+    if (typeof newChild === "object" && newChild !== null) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE: {
+          if (newChild.key === key) {
+            if (newChild.type === REACT_FRAGMENT_TYPE) {
+              return updateFragment(
+                returnFiber,
+                oldFiber,
+                newChild.props.children,
+                expirationTime,
+                key
+              );
+            }
+            return updateElement(
+              returnFiber,
+              oldFiber,
+              newChild,
+              expirationTime
+            );
+          } else {
+            return null;
+          }
+        }
+        case REACT_PORTAL_TYPE: {
+          if (newChild.key === key) {
+            return updatePortal(
+              returnFiber,
+              oldFiber,
+              newChild,
+              expirationTime
+            );
+          } else {
+            return null;
+          }
+        }
       }
-      if (
-        typeof instance.componentWillReceiveProps === "function" &&
-        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
-      ) {
-        foundWillReceivePropsName = "componentWillReceiveProps";
-      } else if (
-        typeof instance.UNSAFE_componentWillReceiveProps === "function"
-      ) {
-        foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
+
+      if (isArray(newChild) || getIteratorFn(newChild)) {
+        if (key !== null) {
+          return null;
+        }
+
+        return updateFragment(
+          returnFiber,
+          oldFiber,
+          newChild,
+          expirationTime,
+          null
+        );
       }
-      if (
-        typeof instance.componentWillUpdate === "function" &&
-        instance.componentWillUpdate.__suppressDeprecationWarning !== true
-      ) {
-        foundWillUpdateName = "componentWillUpdate";
-      } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
-        foundWillUpdateName = "UNSAFE_componentWillUpdate";
+
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
+
+    {
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
       }
-      if (
-        foundWillMountName !== null ||
-        foundWillReceivePropsName !== null ||
-        foundWillUpdateName !== null
-      ) {
-        var _componentName = getComponentName(ctor) || "Component";
-        var newApiName =
-          typeof ctor.getDerivedStateFromProps === "function"
-            ? "getDerivedStateFromProps()"
-            : "getSnapshotBeforeUpdate()";
-        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
-          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
-          warningWithoutStack$1(
-            false,
-            "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
-              "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
-              "The above lifecycles should be removed. Learn more about this warning here:\n" +
-              "https://fb.me/react-async-component-lifecycle-hooks",
-            _componentName,
-            newApiName,
-            foundWillMountName !== null ? "\n  " + foundWillMountName : "",
-            foundWillReceivePropsName !== null
-              ? "\n  " + foundWillReceivePropsName
-              : "",
-            foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : ""
+    }
+
+    return null;
+  }
+
+  function updateFromMap(
+    existingChildren,
+    returnFiber,
+    newIdx,
+    newChild,
+    expirationTime
+  ) {
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      // Text nodes don't have keys, so we neither have to check the old nor
+      // new node for the key. If both are text nodes, they match.
+      var matchedFiber = existingChildren.get(newIdx) || null;
+      return updateTextNode(
+        returnFiber,
+        matchedFiber,
+        "" + newChild,
+        expirationTime
+      );
+    }
+
+    if (typeof newChild === "object" && newChild !== null) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE: {
+          var _matchedFiber =
+            existingChildren.get(
+              newChild.key === null ? newIdx : newChild.key
+            ) || null;
+          if (newChild.type === REACT_FRAGMENT_TYPE) {
+            return updateFragment(
+              returnFiber,
+              _matchedFiber,
+              newChild.props.children,
+              expirationTime,
+              newChild.key
+            );
+          }
+          return updateElement(
+            returnFiber,
+            _matchedFiber,
+            newChild,
+            expirationTime
+          );
+        }
+        case REACT_PORTAL_TYPE: {
+          var _matchedFiber2 =
+            existingChildren.get(
+              newChild.key === null ? newIdx : newChild.key
+            ) || null;
+          return updatePortal(
+            returnFiber,
+            _matchedFiber2,
+            newChild,
+            expirationTime
           );
         }
       }
-    }
-  }
-
-  // Cache unmasked context so we can avoid recreating masked context unless necessary.
-  // ReactFiberContext usually updates this cache but can't for newly-created instances.
-  if (isLegacyContextConsumer) {
-    cacheContext(workInProgress, unmaskedContext, context);
-  }
 
-  return instance;
-}
+      if (isArray(newChild) || getIteratorFn(newChild)) {
+        var _matchedFiber3 = existingChildren.get(newIdx) || null;
+        return updateFragment(
+          returnFiber,
+          _matchedFiber3,
+          newChild,
+          expirationTime,
+          null
+        );
+      }
+
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
 
-function callComponentWillMount(workInProgress, instance) {
-  startPhaseTimer(workInProgress, "componentWillMount");
-  var oldState = instance.state;
+    {
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
+      }
+    }
 
-  if (typeof instance.componentWillMount === "function") {
-    instance.componentWillMount();
-  }
-  if (typeof instance.UNSAFE_componentWillMount === "function") {
-    instance.UNSAFE_componentWillMount();
+    return null;
   }
 
-  stopPhaseTimer();
-
-  if (oldState !== instance.state) {
+  /**
+   * Warns if there is a duplicate or missing key
+   */
+  function warnOnInvalidKey(child, knownKeys) {
     {
-      warningWithoutStack$1(
-        false,
-        "%s.componentWillMount(): Assigning directly to this.state is " +
-          "deprecated (except inside a component's " +
-          "constructor). Use setState instead.",
-        getComponentName(workInProgress.type) || "Component"
-      );
+      if (typeof child !== "object" || child === null) {
+        return knownKeys;
+      }
+      switch (child.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+        case REACT_PORTAL_TYPE:
+          warnForMissingKey(child);
+          var key = child.key;
+          if (typeof key !== "string") {
+            break;
+          }
+          if (knownKeys === null) {
+            knownKeys = new Set();
+            knownKeys.add(key);
+            break;
+          }
+          if (!knownKeys.has(key)) {
+            knownKeys.add(key);
+            break;
+          }
+          warning$1(
+            false,
+            "Encountered two children with the same key, `%s`. " +
+              "Keys should be unique so that components maintain their identity " +
+              "across updates. Non-unique keys may cause children to be " +
+              "duplicated and/or omitted — the behavior is unsupported and " +
+              "could change in a future version.",
+            key
+          );
+          break;
+        default:
+          break;
+      }
     }
-    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+    return knownKeys;
   }
-}
 
-function callComponentWillReceiveProps(
-  workInProgress,
-  instance,
-  newProps,
-  nextContext
-) {
-  var oldState = instance.state;
-  startPhaseTimer(workInProgress, "componentWillReceiveProps");
-  if (typeof instance.componentWillReceiveProps === "function") {
-    instance.componentWillReceiveProps(newProps, nextContext);
-  }
-  if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
-    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
-  }
-  stopPhaseTimer();
+  function reconcileChildrenArray(
+    returnFiber,
+    currentFirstChild,
+    newChildren,
+    expirationTime
+  ) {
+    // This algorithm can't optimize by searching from boths ends since we
+    // don't have backpointers on fibers. I'm trying to see how far we can get
+    // with that model. If it ends up not being worth the tradeoffs, we can
+    // add it later.
+
+    // Even with a two ended optimization, we'd want to optimize for the case
+    // where there are few changes and brute force the comparison instead of
+    // going for the Map. It'd like to explore hitting that path first in
+    // forward-only mode and only go for the Map once we notice that we need
+    // lots of look ahead. This doesn't handle reversal as well as two ended
+    // search but that's unusual. Besides, for the two ended optimization to
+    // work on Iterables, we'd need to copy the whole set.
+
+    // In this first iteration, we'll just live with hitting the bad case
+    // (adding everything to a Map) in for every insert/move.
+
+    // If you change this code, also update reconcileChildrenIterator() which
+    // uses the same algorithm.
 
-  if (instance.state !== oldState) {
     {
-      var componentName = getComponentName(workInProgress.type) || "Component";
-      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
-        didWarnAboutStateAssignmentForComponent.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "%s.componentWillReceiveProps(): Assigning directly to " +
-            "this.state is deprecated (except inside a component's " +
-            "constructor). Use setState instead.",
-          componentName
-        );
+      // First, validate keys.
+      var knownKeys = null;
+      for (var i = 0; i < newChildren.length; i++) {
+        var child = newChildren[i];
+        knownKeys = warnOnInvalidKey(child, knownKeys);
       }
     }
-    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
-  }
-}
 
-// Invokes the mount life-cycles on a previously never rendered instance.
-function mountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
-  {
-    checkClassInstance(workInProgress, ctor, newProps);
-  }
+    var resultingFirstChild = null;
+    var previousNewFiber = null;
 
-  var instance = workInProgress.stateNode;
-  instance.props = newProps;
-  instance.state = workInProgress.memoizedState;
-  instance.refs = emptyRefsObject;
+    var oldFiber = currentFirstChild;
+    var lastPlacedIndex = 0;
+    var newIdx = 0;
+    var nextOldFiber = null;
+    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
+      if (oldFiber.index > newIdx) {
+        nextOldFiber = oldFiber;
+        oldFiber = null;
+      } else {
+        nextOldFiber = oldFiber.sibling;
+      }
+      var newFiber = updateSlot(
+        returnFiber,
+        oldFiber,
+        newChildren[newIdx],
+        expirationTime
+      );
+      if (newFiber === null) {
+        // TODO: This breaks on empty slots like null children. That's
+        // unfortunate because it triggers the slow path all the time. We need
+        // a better way to communicate whether this was a miss or null,
+        // boolean, undefined, etc.
+        if (oldFiber === null) {
+          oldFiber = nextOldFiber;
+        }
+        break;
+      }
+      if (shouldTrackSideEffects) {
+        if (oldFiber && newFiber.alternate === null) {
+          // We matched the slot, but we didn't reuse the existing fiber, so we
+          // need to delete the existing child.
+          deleteChild(returnFiber, oldFiber);
+        }
+      }
+      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
+      if (previousNewFiber === null) {
+        // TODO: Move out of the loop. This only happens for the first run.
+        resultingFirstChild = newFiber;
+      } else {
+        // TODO: Defer siblings if we're not at the right index for this slot.
+        // I.e. if we had null values before, then we want to defer this
+        // for each null value. However, we also don't want to call updateSlot
+        // with the previous one.
+        previousNewFiber.sibling = newFiber;
+      }
+      previousNewFiber = newFiber;
+      oldFiber = nextOldFiber;
+    }
 
-  var contextType = ctor.contextType;
-  if (typeof contextType === "object" && contextType !== null) {
-    instance.context = readContext$1(contextType);
-  } else {
-    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-    instance.context = getMaskedContext(workInProgress, unmaskedContext);
-  }
+    if (newIdx === newChildren.length) {
+      // We've reached the end of the new children. We can delete the rest.
+      deleteRemainingChildren(returnFiber, oldFiber);
+      return resultingFirstChild;
+    }
 
-  {
-    if (instance.state === newProps) {
-      var componentName = getComponentName(ctor) || "Component";
-      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
-        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "%s: It is not recommended to assign props directly to state " +
-            "because updates to props won't be reflected in state. " +
-            "In most cases, it is better to use props directly.",
-          componentName
+    if (oldFiber === null) {
+      // If we don't have any more existing children we can choose a fast path
+      // since the rest will all be insertions.
+      for (; newIdx < newChildren.length; newIdx++) {
+        var _newFiber = createChild(
+          returnFiber,
+          newChildren[newIdx],
+          expirationTime
         );
+        if (!_newFiber) {
+          continue;
+        }
+        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          // TODO: Move out of the loop. This only happens for the first run.
+          resultingFirstChild = _newFiber;
+        } else {
+          previousNewFiber.sibling = _newFiber;
+        }
+        previousNewFiber = _newFiber;
       }
+      return resultingFirstChild;
     }
 
-    if (workInProgress.mode & StrictMode) {
-      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
-        workInProgress,
-        instance
-      );
+    // Add all children to a key map for quick lookups.
+    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
 
-      ReactStrictModeWarnings.recordLegacyContextWarning(
-        workInProgress,
-        instance
+    // Keep scanning and use the map to restore deleted items as moves.
+    for (; newIdx < newChildren.length; newIdx++) {
+      var _newFiber2 = updateFromMap(
+        existingChildren,
+        returnFiber,
+        newIdx,
+        newChildren[newIdx],
+        expirationTime
       );
+      if (_newFiber2) {
+        if (shouldTrackSideEffects) {
+          if (_newFiber2.alternate !== null) {
+            // The new fiber is a work in progress, but if there exists a
+            // current, that means that we reused the fiber. We need to delete
+            // it from the child list so that we don't add it to the deletion
+            // list.
+            existingChildren.delete(
+              _newFiber2.key === null ? newIdx : _newFiber2.key
+            );
+          }
+        }
+        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          resultingFirstChild = _newFiber2;
+        } else {
+          previousNewFiber.sibling = _newFiber2;
+        }
+        previousNewFiber = _newFiber2;
+      }
     }
 
-    if (warnAboutDeprecatedLifecycles) {
-      ReactStrictModeWarnings.recordDeprecationWarnings(
-        workInProgress,
-        instance
-      );
+    if (shouldTrackSideEffects) {
+      // Any existing children that weren't consumed above were deleted. We need
+      // to add them to the deletion list.
+      existingChildren.forEach(function(child) {
+        return deleteChild(returnFiber, child);
+      });
     }
-  }
-
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null) {
-    processUpdateQueue(
-      workInProgress,
-      updateQueue,
-      newProps,
-      instance,
-      renderExpirationTime
-    );
-    instance.state = workInProgress.memoizedState;
-  }
 
-  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
-  if (typeof getDerivedStateFromProps === "function") {
-    applyDerivedStateFromProps(
-      workInProgress,
-      ctor,
-      getDerivedStateFromProps,
-      newProps
-    );
-    instance.state = workInProgress.memoizedState;
+    return resultingFirstChild;
   }
 
-  // In order to support react-lifecycles-compat polyfilled components,
-  // Unsafe lifecycles should not be invoked for components using the new APIs.
-  if (
-    typeof ctor.getDerivedStateFromProps !== "function" &&
-    typeof instance.getSnapshotBeforeUpdate !== "function" &&
-    (typeof instance.UNSAFE_componentWillMount === "function" ||
-      typeof instance.componentWillMount === "function")
+  function reconcileChildrenIterator(
+    returnFiber,
+    currentFirstChild,
+    newChildrenIterable,
+    expirationTime
   ) {
-    callComponentWillMount(workInProgress, instance);
-    // If we had additional state updates during this life-cycle, let's
-    // process them now.
-    updateQueue = workInProgress.updateQueue;
-    if (updateQueue !== null) {
-      processUpdateQueue(
-        workInProgress,
-        updateQueue,
-        newProps,
-        instance,
-        renderExpirationTime
-      );
-      instance.state = workInProgress.memoizedState;
-    }
-  }
-
-  if (typeof instance.componentDidMount === "function") {
-    workInProgress.effectTag |= Update;
-  }
-}
-
-function resumeMountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
-  var instance = workInProgress.stateNode;
-
-  var oldProps = workInProgress.memoizedProps;
-  instance.props = oldProps;
+    // This is the same implementation as reconcileChildrenArray(),
+    // but using the iterator instead.
 
-  var oldContext = instance.context;
-  var contextType = ctor.contextType;
-  var nextContext = void 0;
-  if (typeof contextType === "object" && contextType !== null) {
-    nextContext = readContext$1(contextType);
-  } else {
-    var nextLegacyUnmaskedContext = getUnmaskedContext(
-      workInProgress,
-      ctor,
-      true
+    var iteratorFn = getIteratorFn(newChildrenIterable);
+    invariant(
+      typeof iteratorFn === "function",
+      "An object is not an iterable. This error is likely caused by a bug in " +
+        "React. Please file an issue."
     );
-    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
-  }
 
-  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
-  var hasNewLifecycles =
-    typeof getDerivedStateFromProps === "function" ||
-    typeof instance.getSnapshotBeforeUpdate === "function";
+    {
+      // We don't support rendering Generators because it's a mutation.
+      // See https://github.com/facebook/react/issues/12995
+      if (
+        typeof Symbol === "function" &&
+        // $FlowFixMe Flow doesn't know about toStringTag
+        newChildrenIterable[Symbol.toStringTag] === "Generator"
+      ) {
+        !didWarnAboutGenerators
+          ? warning$1(
+              false,
+              "Using Generators as children is unsupported and will likely yield " +
+                "unexpected results because enumerating a generator mutates it. " +
+                "You may convert it to an array with `Array.from()` or the " +
+                "`[...spread]` operator before rendering. Keep in mind " +
+                "you might need to polyfill these features for older browsers."
+            )
+          : void 0;
+        didWarnAboutGenerators = true;
+      }
 
-  // Note: During these life-cycles, instance.props/instance.state are what
-  // ever the previously attempted to render - not the "current". However,
-  // during componentDidUpdate we pass the "current" props.
+      // Warn about using Maps as children
+      if (newChildrenIterable.entries === iteratorFn) {
+        !didWarnAboutMaps
+          ? warning$1(
+              false,
+              "Using Maps as children is unsupported and will likely yield " +
+                "unexpected results. Convert it to a sequence/iterable of keyed " +
+                "ReactElements instead."
+            )
+          : void 0;
+        didWarnAboutMaps = true;
+      }
 
-  // In order to support react-lifecycles-compat polyfilled components,
-  // Unsafe lifecycles should not be invoked for components using the new APIs.
-  if (
-    !hasNewLifecycles &&
-    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
-      typeof instance.componentWillReceiveProps === "function")
-  ) {
-    if (oldProps !== newProps || oldContext !== nextContext) {
-      callComponentWillReceiveProps(
-        workInProgress,
-        instance,
-        newProps,
-        nextContext
-      );
+      // First, validate keys.
+      // We'll get a different iterator later for the main pass.
+      var _newChildren = iteratorFn.call(newChildrenIterable);
+      if (_newChildren) {
+        var knownKeys = null;
+        var _step = _newChildren.next();
+        for (; !_step.done; _step = _newChildren.next()) {
+          var child = _step.value;
+          knownKeys = warnOnInvalidKey(child, knownKeys);
+        }
+      }
     }
-  }
-
-  resetHasForceUpdateBeforeProcessing();
 
-  var oldState = workInProgress.memoizedState;
-  var newState = (instance.state = oldState);
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null) {
-    processUpdateQueue(
-      workInProgress,
-      updateQueue,
-      newProps,
-      instance,
-      renderExpirationTime
-    );
-    newState = workInProgress.memoizedState;
-  }
-  if (
-    oldProps === newProps &&
-    oldState === newState &&
-    !hasContextChanged() &&
-    !checkHasForceUpdateAfterProcessing()
-  ) {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
-    }
-    return false;
-  }
+    var newChildren = iteratorFn.call(newChildrenIterable);
+    invariant(newChildren != null, "An iterable object provided no iterator.");
 
-  if (typeof getDerivedStateFromProps === "function") {
-    applyDerivedStateFromProps(
-      workInProgress,
-      ctor,
-      getDerivedStateFromProps,
-      newProps
-    );
-    newState = workInProgress.memoizedState;
-  }
+    var resultingFirstChild = null;
+    var previousNewFiber = null;
 
-  var shouldUpdate =
-    checkHasForceUpdateAfterProcessing() ||
-    checkShouldComponentUpdate(
-      workInProgress,
-      ctor,
-      oldProps,
-      newProps,
-      oldState,
-      newState,
-      nextContext
-    );
+    var oldFiber = currentFirstChild;
+    var lastPlacedIndex = 0;
+    var newIdx = 0;
+    var nextOldFiber = null;
 
-  if (shouldUpdate) {
-    // In order to support react-lifecycles-compat polyfilled components,
-    // Unsafe lifecycles should not be invoked for components using the new APIs.
-    if (
-      !hasNewLifecycles &&
-      (typeof instance.UNSAFE_componentWillMount === "function" ||
-        typeof instance.componentWillMount === "function")
+    var step = newChildren.next();
+    for (
+      ;
+      oldFiber !== null && !step.done;
+      newIdx++, step = newChildren.next()
     ) {
-      startPhaseTimer(workInProgress, "componentWillMount");
-      if (typeof instance.componentWillMount === "function") {
-        instance.componentWillMount();
+      if (oldFiber.index > newIdx) {
+        nextOldFiber = oldFiber;
+        oldFiber = null;
+      } else {
+        nextOldFiber = oldFiber.sibling;
       }
-      if (typeof instance.UNSAFE_componentWillMount === "function") {
-        instance.UNSAFE_componentWillMount();
+      var newFiber = updateSlot(
+        returnFiber,
+        oldFiber,
+        step.value,
+        expirationTime
+      );
+      if (newFiber === null) {
+        // TODO: This breaks on empty slots like null children. That's
+        // unfortunate because it triggers the slow path all the time. We need
+        // a better way to communicate whether this was a miss or null,
+        // boolean, undefined, etc.
+        if (!oldFiber) {
+          oldFiber = nextOldFiber;
+        }
+        break;
       }
-      stopPhaseTimer();
-    }
-    if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
-    }
-  } else {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
+      if (shouldTrackSideEffects) {
+        if (oldFiber && newFiber.alternate === null) {
+          // We matched the slot, but we didn't reuse the existing fiber, so we
+          // need to delete the existing child.
+          deleteChild(returnFiber, oldFiber);
+        }
+      }
+      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
+      if (previousNewFiber === null) {
+        // TODO: Move out of the loop. This only happens for the first run.
+        resultingFirstChild = newFiber;
+      } else {
+        // TODO: Defer siblings if we're not at the right index for this slot.
+        // I.e. if we had null values before, then we want to defer this
+        // for each null value. However, we also don't want to call updateSlot
+        // with the previous one.
+        previousNewFiber.sibling = newFiber;
+      }
+      previousNewFiber = newFiber;
+      oldFiber = nextOldFiber;
     }
 
-    // If shouldComponentUpdate returned false, we should still update the
-    // memoized state to indicate that this work can be reused.
-    workInProgress.memoizedProps = newProps;
-    workInProgress.memoizedState = newState;
-  }
+    if (step.done) {
+      // We've reached the end of the new children. We can delete the rest.
+      deleteRemainingChildren(returnFiber, oldFiber);
+      return resultingFirstChild;
+    }
 
-  // Update the existing instance's state, props, and context pointers even
-  // if shouldComponentUpdate returns false.
-  instance.props = newProps;
-  instance.state = newState;
-  instance.context = nextContext;
+    if (oldFiber === null) {
+      // If we don't have any more existing children we can choose a fast path
+      // since the rest will all be insertions.
+      for (; !step.done; newIdx++, step = newChildren.next()) {
+        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
+        if (_newFiber3 === null) {
+          continue;
+        }
+        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          // TODO: Move out of the loop. This only happens for the first run.
+          resultingFirstChild = _newFiber3;
+        } else {
+          previousNewFiber.sibling = _newFiber3;
+        }
+        previousNewFiber = _newFiber3;
+      }
+      return resultingFirstChild;
+    }
 
-  return shouldUpdate;
-}
+    // Add all children to a key map for quick lookups.
+    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
 
-// Invokes the update life-cycles and returns false if it shouldn't rerender.
-function updateClassInstance(
-  current,
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
-  var instance = workInProgress.stateNode;
+    // Keep scanning and use the map to restore deleted items as moves.
+    for (; !step.done; newIdx++, step = newChildren.next()) {
+      var _newFiber4 = updateFromMap(
+        existingChildren,
+        returnFiber,
+        newIdx,
+        step.value,
+        expirationTime
+      );
+      if (_newFiber4 !== null) {
+        if (shouldTrackSideEffects) {
+          if (_newFiber4.alternate !== null) {
+            // The new fiber is a work in progress, but if there exists a
+            // current, that means that we reused the fiber. We need to delete
+            // it from the child list so that we don't add it to the deletion
+            // list.
+            existingChildren.delete(
+              _newFiber4.key === null ? newIdx : _newFiber4.key
+            );
+          }
+        }
+        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          resultingFirstChild = _newFiber4;
+        } else {
+          previousNewFiber.sibling = _newFiber4;
+        }
+        previousNewFiber = _newFiber4;
+      }
+    }
 
-  var oldProps = workInProgress.memoizedProps;
-  instance.props =
-    workInProgress.type === workInProgress.elementType
-      ? oldProps
-      : resolveDefaultProps(workInProgress.type, oldProps);
+    if (shouldTrackSideEffects) {
+      // Any existing children that weren't consumed above were deleted. We need
+      // to add them to the deletion list.
+      existingChildren.forEach(function(child) {
+        return deleteChild(returnFiber, child);
+      });
+    }
 
-  var oldContext = instance.context;
-  var contextType = ctor.contextType;
-  var nextContext = void 0;
-  if (typeof contextType === "object" && contextType !== null) {
-    nextContext = readContext$1(contextType);
-  } else {
-    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
+    return resultingFirstChild;
   }
 
-  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
-  var hasNewLifecycles =
-    typeof getDerivedStateFromProps === "function" ||
-    typeof instance.getSnapshotBeforeUpdate === "function";
-
-  // Note: During these life-cycles, instance.props/instance.state are what
-  // ever the previously attempted to render - not the "current". However,
-  // during componentDidUpdate we pass the "current" props.
-
-  // In order to support react-lifecycles-compat polyfilled components,
-  // Unsafe lifecycles should not be invoked for components using the new APIs.
-  if (
-    !hasNewLifecycles &&
-    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
-      typeof instance.componentWillReceiveProps === "function")
+  function reconcileSingleTextNode(
+    returnFiber,
+    currentFirstChild,
+    textContent,
+    expirationTime
   ) {
-    if (oldProps !== newProps || oldContext !== nextContext) {
-      callComponentWillReceiveProps(
-        workInProgress,
-        instance,
-        newProps,
-        nextContext
-      );
+    // There's no need to check for keys on text nodes since we don't have a
+    // way to define them.
+    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
+      // We already have an existing node so let's just update it and delete
+      // the rest.
+      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
+      var existing = useFiber(currentFirstChild, textContent, expirationTime);
+      existing.return = returnFiber;
+      return existing;
     }
-  }
-
-  resetHasForceUpdateBeforeProcessing();
-
-  var oldState = workInProgress.memoizedState;
-  var newState = (instance.state = oldState);
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null) {
-    processUpdateQueue(
-      workInProgress,
-      updateQueue,
-      newProps,
-      instance,
-      renderExpirationTime
+    // The existing first child is not a text node so we need to create one
+    // and delete the existing ones.
+    deleteRemainingChildren(returnFiber, currentFirstChild);
+    var created = createFiberFromText(
+      textContent,
+      returnFiber.mode,
+      expirationTime
     );
-    newState = workInProgress.memoizedState;
+    created.return = returnFiber;
+    return created;
   }
 
-  if (
-    oldProps === newProps &&
-    oldState === newState &&
-    !hasContextChanged() &&
-    !checkHasForceUpdateAfterProcessing()
+  function reconcileSingleElement(
+    returnFiber,
+    currentFirstChild,
+    element,
+    expirationTime
   ) {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Update;
-      }
-    }
-    if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Snapshot;
+    var key = element.key;
+    var child = currentFirstChild;
+    while (child !== null) {
+      // TODO: If key === null and child.key === null, then this only applies to
+      // the first item in the list.
+      if (child.key === key) {
+        if (
+          child.tag === Fragment
+            ? element.type === REACT_FRAGMENT_TYPE
+            : child.elementType === element.type
+        ) {
+          deleteRemainingChildren(returnFiber, child.sibling);
+          var existing = useFiber(
+            child,
+            element.type === REACT_FRAGMENT_TYPE
+              ? element.props.children
+              : element.props,
+            expirationTime
+          );
+          existing.ref = coerceRef(returnFiber, child, element);
+          existing.return = returnFiber;
+          {
+            existing._debugSource = element._source;
+            existing._debugOwner = element._owner;
+          }
+          return existing;
+        } else {
+          deleteRemainingChildren(returnFiber, child);
+          break;
+        }
+      } else {
+        deleteChild(returnFiber, child);
       }
+      child = child.sibling;
     }
-    return false;
-  }
 
-  if (typeof getDerivedStateFromProps === "function") {
-    applyDerivedStateFromProps(
-      workInProgress,
-      ctor,
-      getDerivedStateFromProps,
-      newProps
-    );
-    newState = workInProgress.memoizedState;
+    if (element.type === REACT_FRAGMENT_TYPE) {
+      var created = createFiberFromFragment(
+        element.props.children,
+        returnFiber.mode,
+        expirationTime,
+        element.key
+      );
+      created.return = returnFiber;
+      return created;
+    } else {
+      var _created4 = createFiberFromElement(
+        element,
+        returnFiber.mode,
+        expirationTime
+      );
+      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
+      _created4.return = returnFiber;
+      return _created4;
+    }
   }
 
-  var shouldUpdate =
-    checkHasForceUpdateAfterProcessing() ||
-    checkShouldComponentUpdate(
-      workInProgress,
-      ctor,
-      oldProps,
-      newProps,
-      oldState,
-      newState,
-      nextContext
-    );
-
-  if (shouldUpdate) {
-    // In order to support react-lifecycles-compat polyfilled components,
-    // Unsafe lifecycles should not be invoked for components using the new APIs.
-    if (
-      !hasNewLifecycles &&
-      (typeof instance.UNSAFE_componentWillUpdate === "function" ||
-        typeof instance.componentWillUpdate === "function")
-    ) {
-      startPhaseTimer(workInProgress, "componentWillUpdate");
-      if (typeof instance.componentWillUpdate === "function") {
-        instance.componentWillUpdate(newProps, newState, nextContext);
-      }
-      if (typeof instance.UNSAFE_componentWillUpdate === "function") {
-        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
-      }
-      stopPhaseTimer();
-    }
-    if (typeof instance.componentDidUpdate === "function") {
-      workInProgress.effectTag |= Update;
-    }
-    if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      workInProgress.effectTag |= Snapshot;
-    }
-  } else {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Update;
-      }
-    }
-    if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Snapshot;
+  function reconcileSinglePortal(
+    returnFiber,
+    currentFirstChild,
+    portal,
+    expirationTime
+  ) {
+    var key = portal.key;
+    var child = currentFirstChild;
+    while (child !== null) {
+      // TODO: If key === null and child.key === null, then this only applies to
+      // the first item in the list.
+      if (child.key === key) {
+        if (
+          child.tag === HostPortal &&
+          child.stateNode.containerInfo === portal.containerInfo &&
+          child.stateNode.implementation === portal.implementation
+        ) {
+          deleteRemainingChildren(returnFiber, child.sibling);
+          var existing = useFiber(child, portal.children || [], expirationTime);
+          existing.return = returnFiber;
+          return existing;
+        } else {
+          deleteRemainingChildren(returnFiber, child);
+          break;
+        }
+      } else {
+        deleteChild(returnFiber, child);
       }
+      child = child.sibling;
     }
 
-    // If shouldComponentUpdate returned false, we should still update the
-    // memoized props/state to indicate that this work can be reused.
-    workInProgress.memoizedProps = newProps;
-    workInProgress.memoizedState = newState;
+    var created = createFiberFromPortal(
+      portal,
+      returnFiber.mode,
+      expirationTime
+    );
+    created.return = returnFiber;
+    return created;
   }
 
-  // Update the existing instance's state, props, and context pointers even
-  // if shouldComponentUpdate returns false.
-  instance.props = newProps;
-  instance.state = newState;
-  instance.context = nextContext;
-
-  return shouldUpdate;
-}
-
-var didWarnAboutMaps = void 0;
-var didWarnAboutGenerators = void 0;
-var didWarnAboutStringRefInStrictMode = void 0;
-var ownerHasKeyUseWarning = void 0;
-var ownerHasFunctionTypeWarning = void 0;
-var warnForMissingKey = function(child) {};
+  // This API will tag the children with the side-effect of the reconciliation
+  // itself. They will be added to the side-effect list as we pass through the
+  // children and the parent.
+  function reconcileChildFibers(
+    returnFiber,
+    currentFirstChild,
+    newChild,
+    expirationTime
+  ) {
+    // This function is not recursive.
+    // If the top level item is an array, we treat it as a set of children,
+    // not as a fragment. Nested arrays on the other hand will be treated as
+    // fragment nodes. Recursion happens at the normal flow.
 
-{
-  didWarnAboutMaps = false;
-  didWarnAboutGenerators = false;
-  didWarnAboutStringRefInStrictMode = {};
+    // Handle top level unkeyed fragments as if they were arrays.
+    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
+    // We treat the ambiguous cases above the same.
+    var isUnkeyedTopLevelFragment =
+      typeof newChild === "object" &&
+      newChild !== null &&
+      newChild.type === REACT_FRAGMENT_TYPE &&
+      newChild.key === null;
+    if (isUnkeyedTopLevelFragment) {
+      newChild = newChild.props.children;
+    }
 
-  /**
-   * Warn if there's no key explicitly set on dynamic arrays of children or
-   * object keys are not valid. This allows us to keep track of children between
-   * updates.
-   */
-  ownerHasKeyUseWarning = {};
-  ownerHasFunctionTypeWarning = {};
+    // Handle object types
+    var isObject = typeof newChild === "object" && newChild !== null;
 
-  warnForMissingKey = function(child) {
-    if (child === null || typeof child !== "object") {
-      return;
+    if (isObject) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          return placeSingleChild(
+            reconcileSingleElement(
+              returnFiber,
+              currentFirstChild,
+              newChild,
+              expirationTime
+            )
+          );
+        case REACT_PORTAL_TYPE:
+          return placeSingleChild(
+            reconcileSinglePortal(
+              returnFiber,
+              currentFirstChild,
+              newChild,
+              expirationTime
+            )
+          );
+      }
     }
-    if (!child._store || child._store.validated || child.key != null) {
-      return;
+
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      return placeSingleChild(
+        reconcileSingleTextNode(
+          returnFiber,
+          currentFirstChild,
+          "" + newChild,
+          expirationTime
+        )
+      );
     }
-    invariant(
-      typeof child._store === "object",
-      "React Component in warnForMissingKey should have a _store. " +
-        "This error is likely caused by a bug in React. Please file an issue."
-    );
-    child._store.validated = true;
 
-    var currentComponentErrorInfo =
-      "Each child in an array or iterator should have a unique " +
-      '"key" prop. See https://fb.me/react-warning-keys for ' +
-      "more information." +
-      getCurrentFiberStackInDev();
-    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
-      return;
+    if (isArray(newChild)) {
+      return reconcileChildrenArray(
+        returnFiber,
+        currentFirstChild,
+        newChild,
+        expirationTime
+      );
     }
-    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
 
-    warning$1(
-      false,
-      "Each child in an array or iterator should have a unique " +
-        '"key" prop. See https://fb.me/react-warning-keys for ' +
-        "more information."
-    );
-  };
-}
+    if (getIteratorFn(newChild)) {
+      return reconcileChildrenIterator(
+        returnFiber,
+        currentFirstChild,
+        newChild,
+        expirationTime
+      );
+    }
 
-var isArray = Array.isArray;
+    if (isObject) {
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
 
-function coerceRef(returnFiber, current$$1, element) {
-  var mixedRef = element.ref;
-  if (
-    mixedRef !== null &&
-    typeof mixedRef !== "function" &&
-    typeof mixedRef !== "object"
-  ) {
     {
-      if (returnFiber.mode & StrictMode) {
-        var componentName = getComponentName(returnFiber.type) || "Component";
-        if (!didWarnAboutStringRefInStrictMode[componentName]) {
-          warningWithoutStack$1(
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
+      }
+    }
+    if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
+      // If the new child is undefined, and the return fiber is a composite
+      // component, throw an error. If Fiber return types are disabled,
+      // we already threw above.
+      switch (returnFiber.tag) {
+        case ClassComponent: {
+          {
+            var instance = returnFiber.stateNode;
+            if (instance.render._isMockFunction) {
+              // We allow auto-mocks to proceed as if they're returning null.
+              break;
+            }
+          }
+        }
+        // Intentionally fall through to the next case, which handles both
+        // functions and classes
+        // eslint-disable-next-lined no-fallthrough
+        case FunctionComponent: {
+          var Component = returnFiber.type;
+          invariant(
             false,
-            'A string ref, "%s", has been found within a strict mode tree. ' +
-              "String refs are a source of potential bugs and should be avoided. " +
-              "We recommend using createRef() instead." +
-              "\n%s" +
-              "\n\nLearn more about using refs safely here:" +
-              "\nhttps://fb.me/react-strict-mode-string-ref",
-            mixedRef,
-            getStackByFiberInDevAndProd(returnFiber)
+            "%s(...): Nothing was returned from render. This usually means a " +
+              "return statement is missing. Or, to render nothing, " +
+              "return null.",
+            Component.displayName || Component.name || "Component"
           );
-          didWarnAboutStringRefInStrictMode[componentName] = true;
         }
       }
     }
 
-    if (element._owner) {
-      var owner = element._owner;
-      var inst = void 0;
-      if (owner) {
-        var ownerFiber = owner;
-        invariant(
-          ownerFiber.tag === ClassComponent,
-          "Function components cannot have refs."
-        );
-        inst = ownerFiber.stateNode;
-      }
-      invariant(
-        inst,
-        "Missing owner for string ref %s. This error is likely caused by a " +
-          "bug in React. Please file an issue.",
-        mixedRef
-      );
-      var stringRef = "" + mixedRef;
-      // Check if previous string ref matches new string ref
-      if (
-        current$$1 !== null &&
-        current$$1.ref !== null &&
-        typeof current$$1.ref === "function" &&
-        current$$1.ref._stringRef === stringRef
-      ) {
-        return current$$1.ref;
-      }
-      var ref = function(value) {
-        var refs = inst.refs;
-        if (refs === emptyRefsObject) {
-          // This is a lazy pooled frozen object, so we need to initialize.
-          refs = inst.refs = {};
-        }
-        if (value === null) {
-          delete refs[stringRef];
-        } else {
-          refs[stringRef] = value;
-        }
-      };
-      ref._stringRef = stringRef;
-      return ref;
-    } else {
-      invariant(
-        typeof mixedRef === "string",
-        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-      );
-      invariant(
-        element._owner,
-        "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" +
-          " the following reasons:\n" +
-          "1. You may be adding a ref to a function component\n" +
-          "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
-          "3. You have multiple copies of React loaded\n" +
-          "See https://fb.me/react-refs-must-have-owner for more information.",
-        mixedRef
-      );
-    }
+    // Remaining cases are all treated as empty.
+    return deleteRemainingChildren(returnFiber, currentFirstChild);
   }
-  return mixedRef;
+
+  return reconcileChildFibers;
 }
 
-function throwOnInvalidObjectType(returnFiber, newChild) {
-  if (returnFiber.type !== "textarea") {
-    var addendum = "";
-    {
-      addendum =
-        " If you meant to render a collection of children, use an array " +
-        "instead." +
-        getCurrentFiberStackInDev();
-    }
-    invariant(
-      false,
-      "Objects are not valid as a React child (found: %s).%s",
-      Object.prototype.toString.call(newChild) === "[object Object]"
-        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
-        : newChild,
-      addendum
+var reconcileChildFibers = ChildReconciler(true);
+var mountChildFibers = ChildReconciler(false);
+
+function cloneChildFibers(current$$1, workInProgress) {
+  invariant(
+    current$$1 === null || workInProgress.child === current$$1.child,
+    "Resuming work not yet implemented."
+  );
+
+  if (workInProgress.child === null) {
+    return;
+  }
+
+  var currentChild = workInProgress.child;
+  var newChild = createWorkInProgress(
+    currentChild,
+    currentChild.pendingProps,
+    currentChild.expirationTime
+  );
+  workInProgress.child = newChild;
+
+  newChild.return = workInProgress;
+  while (currentChild.sibling !== null) {
+    currentChild = currentChild.sibling;
+    newChild = newChild.sibling = createWorkInProgress(
+      currentChild,
+      currentChild.pendingProps,
+      currentChild.expirationTime
     );
+    newChild.return = workInProgress;
   }
+  newChild.sibling = null;
 }
 
-function warnOnFunctionType() {
-  var currentComponentErrorInfo =
-    "Functions are not valid as a React child. This may happen if " +
-    "you return a Component instead of <Component /> from render. " +
-    "Or maybe you meant to call this function rather than return it." +
-    getCurrentFiberStackInDev();
+var NO_CONTEXT = {};
 
-  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
+var contextStackCursor$1 = createCursor(NO_CONTEXT);
+var contextFiberStackCursor = createCursor(NO_CONTEXT);
+var rootInstanceStackCursor = createCursor(NO_CONTEXT);
+
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug " +
+      "in React. Please file an issue."
+  );
+  return c;
+}
+
+function getRootHostContainer() {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  return rootInstance;
+}
+
+function pushHostContainer(fiber, nextRootInstance) {
+  // Push current root instance onto the stack;
+  // This allows us to reset root when portals are popped.
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+
+  // Finally, we need to push the host context to the stack.
+  // However, we can't just call getRootHostContext() and push it because
+  // we'd have a different number of entries on the stack depending on
+  // whether getRootHostContext() throws somewhere in renderer code or not.
+  // So we push an empty value first. This lets us safely unwind on errors.
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  var nextRootContext = getRootHostContext(nextRootInstance);
+  // Now that we know this function doesn't throw, replace it.
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, nextRootContext, fiber);
+}
+
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+
+function getHostContext() {
+  var context = requiredContext(contextStackCursor$1.current);
+  return context;
+}
+
+function pushHostContext(fiber) {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+
+  // Don't push this Fiber's context unless it's unique.
+  if (context === nextContext) {
     return;
   }
-  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
 
-  warning$1(
-    false,
-    "Functions are not valid as a React child. This may happen if " +
-      "you return a Component instead of <Component /> from render. " +
-      "Or maybe you meant to call this function rather than return it."
-  );
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, nextContext, fiber);
 }
 
-// This wrapper function exists because I expect to clone the code in each path
-// to be able to optimize each path individually by branching early. This needs
-// a compiler or we can do it manually. Helpers that don't need this branching
-// live outside of this function.
-function ChildReconciler(shouldTrackSideEffects) {
-  function deleteChild(returnFiber, childToDelete) {
-    if (!shouldTrackSideEffects) {
-      // Noop.
-      return;
-    }
-    // Deletions are added in reversed order so we add it to the front.
-    // At this point, the return fiber's effect list is empty except for
-    // deletions, so we can just append the deletion to the list. The remaining
-    // effects aren't added until the complete phase. Once we implement
-    // resuming, this may not be true.
-    var last = returnFiber.lastEffect;
-    if (last !== null) {
-      last.nextEffect = childToDelete;
-      returnFiber.lastEffect = childToDelete;
-    } else {
-      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
-    }
-    childToDelete.nextEffect = null;
-    childToDelete.effectTag = Deletion;
+function popHostContext(fiber) {
+  // Do not pop unless this Fiber provided the current context.
+  // pushHostContext() only pushes Fibers that provide unique contexts.
+  if (contextFiberStackCursor.current !== fiber) {
+    return;
   }
 
-  function deleteRemainingChildren(returnFiber, currentFirstChild) {
-    if (!shouldTrackSideEffects) {
-      // Noop.
-      return null;
-    }
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+}
 
-    // TODO: For the shouldClone case, this could be micro-optimized a bit by
-    // assuming that after the first child we've already added everything.
-    var childToDelete = currentFirstChild;
-    while (childToDelete !== null) {
-      deleteChild(returnFiber, childToDelete);
-      childToDelete = childToDelete.sibling;
-    }
-    return null;
-  }
+var NoEffect$1 = /*             */ 0;
+var UnmountSnapshot = /*      */ 2;
+var UnmountMutation = /*      */ 4;
+var MountMutation = /*        */ 8;
+var UnmountLayout = /*        */ 16;
+var MountLayout = /*          */ 32;
+var MountPassive = /*         */ 64;
+var UnmountPassive = /*       */ 128;
 
-  function mapRemainingChildren(returnFiber, currentFirstChild) {
-    // Add the remaining children to a temporary map so that we can find them by
-    // keys quickly. Implicit (null) keys get added to this set with their index
-    var existingChildren = new Map();
+// the first instance of a hook mismatch in a component,
+// represented by a portion of it's stacktrace
+var currentHookMismatchInDev = null;
 
-    var existingChild = currentFirstChild;
-    while (existingChild !== null) {
-      if (existingChild.key !== null) {
-        existingChildren.set(existingChild.key, existingChild);
-      } else {
-        existingChildren.set(existingChild.index, existingChild);
-      }
-      existingChild = existingChild.sibling;
-    }
-    return existingChildren;
-  }
+var didWarnAboutMismatchedHooksForComponent = void 0;
+{
+  didWarnAboutMismatchedHooksForComponent = new Set();
+}
 
-  function useFiber(fiber, pendingProps, expirationTime) {
-    // We currently set sibling to null and index to 0 here because it is easy
-    // to forget to do before returning it. E.g. for the single child case.
-    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
-    clone.index = 0;
-    clone.sibling = null;
-    return clone;
-  }
+// These are set right before calling the component.
+var renderExpirationTime = NoWork;
+// The work-in-progress fiber. I've named it differently to distinguish it from
+// the work-in-progress hook.
+var currentlyRenderingFiber$1 = null;
 
-  function placeChild(newFiber, lastPlacedIndex, newIndex) {
-    newFiber.index = newIndex;
-    if (!shouldTrackSideEffects) {
-      // Noop.
-      return lastPlacedIndex;
-    }
-    var current$$1 = newFiber.alternate;
-    if (current$$1 !== null) {
-      var oldIndex = current$$1.index;
-      if (oldIndex < lastPlacedIndex) {
-        // This is a move.
-        newFiber.effectTag = Placement;
-        return lastPlacedIndex;
-      } else {
-        // This item can stay in place.
-        return oldIndex;
-      }
-    } else {
-      // This is an insertion.
-      newFiber.effectTag = Placement;
-      return lastPlacedIndex;
-    }
-  }
+// Hooks are stored as a linked list on the fiber's memoizedState field. The
+// current hook list is the list that belongs to the current fiber. The
+// work-in-progress hook list is a new list that will be added to the
+// work-in-progress fiber.
+var firstCurrentHook = null;
+var currentHook = null;
+var firstWorkInProgressHook = null;
+var workInProgressHook = null;
 
-  function placeSingleChild(newFiber) {
-    // This is simpler for the single child case. We only need to do a
-    // placement for inserting new children.
-    if (shouldTrackSideEffects && newFiber.alternate === null) {
-      newFiber.effectTag = Placement;
-    }
-    return newFiber;
-  }
+var remainingExpirationTime = NoWork;
+var componentUpdateQueue = null;
 
-  function updateTextNode(
-    returnFiber,
-    current$$1,
-    textContent,
-    expirationTime
-  ) {
-    if (current$$1 === null || current$$1.tag !== HostText) {
-      // Insert
-      var created = createFiberFromText(
-        textContent,
-        returnFiber.mode,
-        expirationTime
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      // Update
-      var existing = useFiber(current$$1, textContent, expirationTime);
-      existing.return = returnFiber;
-      return existing;
-    }
-  }
+// Updates scheduled during render will trigger an immediate re-render at the
+// end of the current pass. We can't store these updates on the normal queue,
+// because if the work is aborted, they should be discarded. Because this is
+// a relatively rare case, we also don't want to add an additional field to
+// either the hook or queue object types. So we store them in a lazily create
+// map of queue -> render-phase updates, which are discarded once the component
+// completes without re-rendering.
 
-  function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (current$$1 !== null && current$$1.elementType === element.type) {
-      // Move based on index
-      var existing = useFiber(current$$1, element.props, expirationTime);
-      existing.ref = coerceRef(returnFiber, current$$1, element);
-      existing.return = returnFiber;
-      {
-        existing._debugSource = element._source;
-        existing._debugOwner = element._owner;
-      }
-      return existing;
-    } else {
-      // Insert
-      var created = createFiberFromElement(
-        element,
-        returnFiber.mode,
-        expirationTime
+// Whether an update was scheduled during the currently executing render pass.
+var didScheduleRenderPhaseUpdate = false;
+// Lazily created map of render-phase updates
+var renderPhaseUpdates = null;
+// Counter to prevent infinite loops.
+var numberOfReRenders = -1;
+var RE_RENDER_LIMIT = 25;
+
+// In DEV, this is the name of the currently executing primitive hook
+var currentHookNameInDev = null;
+
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    currentlyRenderingFiber$1 !== null,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (prevDeps === null) {
+    {
+      warning$1(
+        false,
+        "%s received a final argument during this render, but not during " +
+          "the previous render. Even though the final argument is optional, " +
+          "its type cannot change between renders.",
+        currentHookNameInDev
       );
-      created.ref = coerceRef(returnFiber, current$$1, element);
-      created.return = returnFiber;
-      return created;
     }
+    return false;
   }
 
-  function updatePortal(returnFiber, current$$1, portal, expirationTime) {
-    if (
-      current$$1 === null ||
-      current$$1.tag !== HostPortal ||
-      current$$1.stateNode.containerInfo !== portal.containerInfo ||
-      current$$1.stateNode.implementation !== portal.implementation
-    ) {
-      // Insert
-      var created = createFiberFromPortal(
-        portal,
-        returnFiber.mode,
-        expirationTime
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      // Update
-      var existing = useFiber(
-        current$$1,
-        portal.children || [],
-        expirationTime
+  {
+    // Don't bother comparing lengths in prod because these arrays should be
+    // passed inline.
+    if (nextDeps.length !== prevDeps.length) {
+      warning$1(
+        false,
+        "The final argument passed to %s changed size between renders. The " +
+          "order and size of this array must remain constant.\n\n" +
+          "Previous: %s\n" +
+          "Incoming: %s",
+        currentHookNameInDev,
+        "[" + nextDeps.join(", ") + "]",
+        "[" + prevDeps.join(", ") + "]"
       );
-      existing.return = returnFiber;
-      return existing;
     }
   }
-
-  function updateFragment(
-    returnFiber,
-    current$$1,
-    fragment,
-    expirationTime,
-    key
-  ) {
-    if (current$$1 === null || current$$1.tag !== Fragment) {
-      // Insert
-      var created = createFiberFromFragment(
-        fragment,
-        returnFiber.mode,
-        expirationTime,
-        key
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      // Update
-      var existing = useFiber(current$$1, fragment, expirationTime);
-      existing.return = returnFiber;
-      return existing;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
+    if (is(nextDeps[i], prevDeps[i])) {
+      continue;
     }
+    return false;
   }
+  return true;
+}
 
-  function createChild(returnFiber, newChild, expirationTime) {
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      // Text nodes don't have keys. If the previous node is implicitly keyed
-      // we can continue to replace it without aborting even if it is not a text
-      // node.
-      var created = createFiberFromText(
-        "" + newChild,
-        returnFiber.mode,
-        expirationTime
-      );
-      created.return = returnFiber;
-      return created;
+// till we have String::padEnd, a small function to
+// right-pad strings with spaces till a minimum length
+function padEndSpaces(string, length) {
+  {
+    if (string.length >= length) {
+      return string;
+    } else {
+      return string + " " + new Array(length - string.length).join(" ");
     }
-
-    if (typeof newChild === "object" && newChild !== null) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE: {
-          var _created = createFiberFromElement(
-            newChild,
-            returnFiber.mode,
-            expirationTime
-          );
-          _created.ref = coerceRef(returnFiber, null, newChild);
-          _created.return = returnFiber;
-          return _created;
-        }
-        case REACT_PORTAL_TYPE: {
-          var _created2 = createFiberFromPortal(
-            newChild,
-            returnFiber.mode,
-            expirationTime
-          );
-          _created2.return = returnFiber;
-          return _created2;
+  }
+}
+
+function flushHookMismatchWarnings() {
+  // we'll show the diff of the low level hooks,
+  // and a stack trace so the dev can locate where
+  // the first mismatch is coming from
+  {
+    if (currentHookMismatchInDev !== null) {
+      var componentName = getComponentName(currentlyRenderingFiber$1.type);
+      if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
+        didWarnAboutMismatchedHooksForComponent.add(componentName);
+        var hookStackDiff = [];
+        var _current = firstCurrentHook;
+        var previousOrder = [];
+        while (_current !== null) {
+          previousOrder.push(_current._debugType);
+          _current = _current.next;
         }
-      }
+        var workInProgress = firstWorkInProgressHook;
+        var nextOrder = [];
+        while (workInProgress !== null) {
+          nextOrder.push(workInProgress._debugType);
+          workInProgress = workInProgress.next;
+        }
+        // some bookkeeping for formatting the output table
+        var columnLength = Math.max.apply(
+          null,
+          previousOrder
+            .map(function(hook) {
+              return hook.length;
+            })
+            .concat("   Previous render".length)
+        );
 
-      if (isArray(newChild) || getIteratorFn(newChild)) {
-        var _created3 = createFiberFromFragment(
-          newChild,
-          returnFiber.mode,
-          expirationTime,
-          null
+        var hookStackHeader =
+          padEndSpaces("   Previous render", columnLength) +
+          "    Next render\n";
+        var hookStackWidth = hookStackHeader.length;
+        hookStackHeader += "   " + new Array(hookStackWidth - 2).join("-");
+        var hookStackFooter = "   " + new Array(hookStackWidth - 2).join("^");
+
+        var hookStackLength = Math.max(previousOrder.length, nextOrder.length);
+        for (var i = 0; i < hookStackLength; i++) {
+          hookStackDiff.push(
+            padEndSpaces(i + 1 + ". ", 3) +
+              padEndSpaces(previousOrder[i], columnLength) +
+              " " +
+              nextOrder[i]
+          );
+          if (previousOrder[i] !== nextOrder[i]) {
+            break;
+          }
+        }
+        warning$1(
+          false,
+          "React has detected a change in the order of Hooks called by %s. " +
+            "This will lead to bugs and errors if not fixed. " +
+            "For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n" +
+            "%s\n" +
+            "%s\n" +
+            "%s\n" +
+            "The first Hook type mismatch occured at:\n" +
+            "%s\n\n" +
+            "This error occurred in the following component:",
+          componentName,
+          hookStackHeader,
+          hookStackDiff.join("\n"),
+          hookStackFooter,
+          currentHookMismatchInDev
         );
-        _created3.return = returnFiber;
-        return _created3;
       }
-
-      throwOnInvalidObjectType(returnFiber, newChild);
+      currentHookMismatchInDev = null;
     }
+  }
+}
+
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  refOrContext,
+  nextRenderExpirationTime
+) {
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = current !== null ? current.memoizedState : null;
+
+  // The following should have already been reset
+  // currentHook = null;
+  // workInProgressHook = null;
+
+  // remainingExpirationTime = NoWork;
+  // componentUpdateQueue = null;
+
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = -1;
+
+  var children = void 0;
+  do {
+    didScheduleRenderPhaseUpdate = false;
+    numberOfReRenders += 1;
+
+    // Start over from the beginning of the list
+    currentHook = null;
+    workInProgressHook = null;
+    componentUpdateQueue = null;
+
+    children = Component(props, refOrContext);
 
     {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
+      if (
+        current !== null &&
+        workInProgressHook !== null &&
+        currentHook === null
+      ) {
+        warning$1(
+          false,
+          "%s: Rendered more hooks than during the previous render. This is " +
+            "not currently supported and may lead to unexpected behavior.",
+          getComponentName(Component)
+        );
       }
+      flushHookMismatchWarnings();
     }
+  } while (didScheduleRenderPhaseUpdate);
 
-    return null;
-  }
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
 
-  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
-    // Update the fiber if the keys match, otherwise return null.
+  var renderedWork = currentlyRenderingFiber$1;
 
-    var key = oldFiber !== null ? oldFiber.key : null;
+  renderedWork.memoizedState = firstWorkInProgressHook;
+  renderedWork.expirationTime = remainingExpirationTime;
+  renderedWork.updateQueue = componentUpdateQueue;
 
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      // Text nodes don't have keys. If the previous node is implicitly keyed
-      // we can continue to replace it without aborting even if it is not a text
-      // node.
-      if (key !== null) {
-        return null;
-      }
-      return updateTextNode(
-        returnFiber,
-        oldFiber,
-        "" + newChild,
-        expirationTime
-      );
-    }
+  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
 
-    if (typeof newChild === "object" && newChild !== null) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE: {
-          if (newChild.key === key) {
-            if (newChild.type === REACT_FRAGMENT_TYPE) {
-              return updateFragment(
-                returnFiber,
-                oldFiber,
-                newChild.props.children,
-                expirationTime,
-                key
-              );
-            }
-            return updateElement(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
-          } else {
-            return null;
-          }
-        }
-        case REACT_PORTAL_TYPE: {
-          if (newChild.key === key) {
-            return updatePortal(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
-          } else {
-            return null;
-          }
-        }
-      }
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-      if (isArray(newChild) || getIteratorFn(newChild)) {
-        if (key !== null) {
-          return null;
-        }
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-        return updateFragment(
-          returnFiber,
-          oldFiber,
-          newChild,
-          expirationTime,
-          null
-        );
-      }
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-      throwOnInvalidObjectType(returnFiber, newChild);
-    }
+  {
+    currentHookNameInDev = null;
+  }
 
-    {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
-      }
-    }
+  // These were reset above
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = -1;
 
-    return null;
+  invariant(
+    !didRenderTooFewHooks,
+    "Rendered fewer hooks than expected. This may be caused by an accidental " +
+      "early return statement."
+  );
+
+  return children;
+}
+
+function bailoutHooks(current, workInProgress, expirationTime) {
+  workInProgress.updateQueue = current.updateQueue;
+  workInProgress.effectTag &= ~(Passive | Update);
+  if (current.expirationTime <= expirationTime) {
+    current.expirationTime = NoWork;
   }
+}
 
-  function updateFromMap(
-    existingChildren,
-    returnFiber,
-    newIdx,
-    newChild,
-    expirationTime
-  ) {
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      // Text nodes don't have keys, so we neither have to check the old nor
-      // new node for the key. If both are text nodes, they match.
-      var matchedFiber = existingChildren.get(newIdx) || null;
-      return updateTextNode(
-        returnFiber,
-        matchedFiber,
-        "" + newChild,
-        expirationTime
-      );
-    }
+function resetHooks() {
+  {
+    flushHookMismatchWarnings();
+  }
 
-    if (typeof newChild === "object" && newChild !== null) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE: {
-          var _matchedFiber =
-            existingChildren.get(
-              newChild.key === null ? newIdx : newChild.key
-            ) || null;
-          if (newChild.type === REACT_FRAGMENT_TYPE) {
-            return updateFragment(
-              returnFiber,
-              _matchedFiber,
-              newChild.props.children,
-              expirationTime,
-              newChild.key
-            );
-          }
-          return updateElement(
-            returnFiber,
-            _matchedFiber,
-            newChild,
-            expirationTime
-          );
-        }
-        case REACT_PORTAL_TYPE: {
-          var _matchedFiber2 =
-            existingChildren.get(
-              newChild.key === null ? newIdx : newChild.key
-            ) || null;
-          return updatePortal(
-            returnFiber,
-            _matchedFiber2,
-            newChild,
-            expirationTime
-          );
-        }
-      }
+  // This is used to reset the state of this module when a component throws.
+  // It's also called inside mountIndeterminateComponent if we determine the
+  // component is a module-style component.
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-      if (isArray(newChild) || getIteratorFn(newChild)) {
-        var _matchedFiber3 = existingChildren.get(newIdx) || null;
-        return updateFragment(
-          returnFiber,
-          _matchedFiber3,
-          newChild,
-          expirationTime,
-          null
-        );
-      }
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-      throwOnInvalidObjectType(returnFiber, newChild);
-    }
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-    {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
-      }
-    }
+  {
+    currentHookNameInDev = null;
+  }
+
+  didScheduleRenderPhaseUpdate = false;
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+}
+
+function createHook() {
+  var hook = {
+    _debugType: currentHookNameInDev,
+    memoizedState: null,
 
-    return null;
-  }
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
 
-  /**
-   * Warns if there is a duplicate or missing key
-   */
-  function warnOnInvalidKey(child, knownKeys) {
-    {
-      if (typeof child !== "object" || child === null) {
-        return knownKeys;
-      }
-      switch (child.$$typeof) {
-        case REACT_ELEMENT_TYPE:
-        case REACT_PORTAL_TYPE:
-          warnForMissingKey(child);
-          var key = child.key;
-          if (typeof key !== "string") {
-            break;
-          }
-          if (knownKeys === null) {
-            knownKeys = new Set();
-            knownKeys.add(key);
-            break;
-          }
-          if (!knownKeys.has(key)) {
-            knownKeys.add(key);
-            break;
-          }
-          warning$1(
-            false,
-            "Encountered two children with the same key, `%s`. " +
-              "Keys should be unique so that components maintain their identity " +
-              "across updates. Non-unique keys may cause children to be " +
-              "duplicated and/or omitted — the behavior is unsupported and " +
-              "could change in a future version.",
-            key
-          );
-          break;
-        default:
-          break;
-      }
-    }
-    return knownKeys;
-  }
+    next: null
+  };
 
-  function reconcileChildrenArray(
-    returnFiber,
-    currentFirstChild,
-    newChildren,
-    expirationTime
-  ) {
-    // This algorithm can't optimize by searching from boths ends since we
-    // don't have backpointers on fibers. I'm trying to see how far we can get
-    // with that model. If it ends up not being worth the tradeoffs, we can
-    // add it later.
+  return hook;
+}
 
-    // Even with a two ended optimization, we'd want to optimize for the case
-    // where there are few changes and brute force the comparison instead of
-    // going for the Map. It'd like to explore hitting that path first in
-    // forward-only mode and only go for the Map once we notice that we need
-    // lots of look ahead. This doesn't handle reversal as well as two ended
-    // search but that's unusual. Besides, for the two ended optimization to
-    // work on Iterables, we'd need to copy the whole set.
+function cloneHook(hook) {
+  var nextHook = {
+    _debugType: currentHookNameInDev,
+    memoizedState: hook.memoizedState,
 
-    // In this first iteration, we'll just live with hitting the bad case
-    // (adding everything to a Map) in for every insert/move.
+    baseState: hook.baseState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
 
-    // If you change this code, also update reconcileChildrenIterator() which
-    // uses the same algorithm.
+    next: null
+  };
 
-    {
-      // First, validate keys.
-      var knownKeys = null;
-      for (var i = 0; i < newChildren.length; i++) {
-        var child = newChildren[i];
-        knownKeys = warnOnInvalidKey(child, knownKeys);
+  {
+    if (currentHookMismatchInDev === null) {
+      if (currentHookNameInDev !== hook._debugType) {
+        currentHookMismatchInDev = new Error("tracer").stack
+          .split("\n")
+          .slice(4)
+          .join("\n");
       }
     }
+  }
+  return nextHook;
+}
 
-    var resultingFirstChild = null;
-    var previousNewFiber = null;
-
-    var oldFiber = currentFirstChild;
-    var lastPlacedIndex = 0;
-    var newIdx = 0;
-    var nextOldFiber = null;
-    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
-      if (oldFiber.index > newIdx) {
-        nextOldFiber = oldFiber;
-        oldFiber = null;
+function createWorkInProgressHook() {
+  if (workInProgressHook === null) {
+    // This is the first hook in the list
+    if (firstWorkInProgressHook === null) {
+      currentHook = firstCurrentHook;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        workInProgressHook = createHook();
       } else {
-        nextOldFiber = oldFiber.sibling;
-      }
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        newChildren[newIdx],
-        expirationTime
-      );
-      if (newFiber === null) {
-        // TODO: This breaks on empty slots like null children. That's
-        // unfortunate because it triggers the slow path all the time. We need
-        // a better way to communicate whether this was a miss or null,
-        // boolean, undefined, etc.
-        if (oldFiber === null) {
-          oldFiber = nextOldFiber;
-        }
-        break;
-      }
-      if (shouldTrackSideEffects) {
-        if (oldFiber && newFiber.alternate === null) {
-          // We matched the slot, but we didn't reuse the existing fiber, so we
-          // need to delete the existing child.
-          deleteChild(returnFiber, oldFiber);
-        }
+        // Clone the current hook.
+        workInProgressHook = cloneHook(currentHook);
       }
-      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
-      if (previousNewFiber === null) {
-        // TODO: Move out of the loop. This only happens for the first run.
-        resultingFirstChild = newFiber;
+      firstWorkInProgressHook = workInProgressHook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      currentHook = firstCurrentHook;
+      workInProgressHook = firstWorkInProgressHook;
+    }
+  } else {
+    if (workInProgressHook.next === null) {
+      var hook = void 0;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        hook = createHook();
       } else {
-        // TODO: Defer siblings if we're not at the right index for this slot.
-        // I.e. if we had null values before, then we want to defer this
-        // for each null value. However, we also don't want to call updateSlot
-        // with the previous one.
-        previousNewFiber.sibling = newFiber;
+        currentHook = currentHook.next;
+        if (currentHook === null) {
+          // This is a newly mounted hook
+          hook = createHook();
+        } else {
+          // Clone the current hook.
+          hook = cloneHook(currentHook);
+        }
       }
-      previousNewFiber = newFiber;
-      oldFiber = nextOldFiber;
+      // Append to the end of the list
+      workInProgressHook = workInProgressHook.next = hook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      workInProgressHook = workInProgressHook.next;
+      currentHook = currentHook !== null ? currentHook.next : null;
     }
+  }
+  return workInProgressHook;
+}
 
-    if (newIdx === newChildren.length) {
-      // We've reached the end of the new children. We can delete the rest.
-      deleteRemainingChildren(returnFiber, oldFiber);
-      return resultingFirstChild;
+function createFunctionComponentUpdateQueue() {
+  return {
+    lastEffect: null
+  };
+}
+
+function basicStateReducer(state, action) {
+  return typeof action === "function" ? action(state) : action;
+}
+
+function useContext(context, observedBits) {
+  {
+    currentHookNameInDev = "useContext";
+    createWorkInProgressHook();
+    currentHookNameInDev = null;
+  }
+  // Ensure we're in a function component (class components support only the
+  // .unstable_read() form)
+  resolveCurrentlyRenderingFiber();
+  return readContext(context, observedBits);
+}
+
+function useState(initialState) {
+  {
+    currentHookNameInDev = "useState";
+  }
+  return useReducer(
+    basicStateReducer,
+    // useReducer has a special case to support lazy useState initializers
+    initialState
+  );
+}
+
+function useReducer(reducer, initialState, initialAction) {
+  {
+    if (reducer !== basicStateReducer) {
+      currentHookNameInDev = "useReducer";
     }
+  }
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
+  {
+    currentHookNameInDev = null;
+  }
+  var queue = workInProgressHook.queue;
+  if (queue !== null) {
+    // Already have a queue, so this is an update.
+    if (numberOfReRenders > 0) {
+      // This is a re-render. Apply the new render phase updates to the previous
+      var _dispatch2 = queue.dispatch;
+      if (renderPhaseUpdates !== null) {
+        // Render phase updates are stored in a map of queue -> linked list
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (firstRenderPhaseUpdate !== undefined) {
+          renderPhaseUpdates.delete(queue);
+          var newState = workInProgressHook.memoizedState;
+          var update = firstRenderPhaseUpdate;
+          do {
+            // Process this render phase update. We don't have to check the
+            // priority because it will always be the same as the current
+            // render's.
+            var _action = update.action;
+            // Temporarily clear to forbid calling Hooks in a reducer.
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            newState = reducer(newState, _action);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+            update = update.next;
+          } while (update !== null);
 
-    if (oldFiber === null) {
-      // If we don't have any more existing children we can choose a fast path
-      // since the rest will all be insertions.
-      for (; newIdx < newChildren.length; newIdx++) {
-        var _newFiber = createChild(
-          returnFiber,
-          newChildren[newIdx],
-          expirationTime
-        );
-        if (!_newFiber) {
-          continue;
-        }
-        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          // TODO: Move out of the loop. This only happens for the first run.
-          resultingFirstChild = _newFiber;
-        } else {
-          previousNewFiber.sibling = _newFiber;
+          workInProgressHook.memoizedState = newState;
+
+          // Don't persist the state accumlated from the render phase updates to
+          // the base state unless the queue is empty.
+          // TODO: Not sure if this is the desired semantics, but it's what we
+          // do for gDSFP. I can't remember why.
+          if (workInProgressHook.baseUpdate === queue.last) {
+            workInProgressHook.baseState = newState;
+          }
+
+          return [newState, _dispatch2];
         }
-        previousNewFiber = _newFiber;
       }
-      return resultingFirstChild;
+      return [workInProgressHook.memoizedState, _dispatch2];
     }
 
-    // Add all children to a key map for quick lookups.
-    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
+    // The last update in the entire queue
+    var _last = queue.last;
+    // The last update that is part of the base state.
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    var _baseState = workInProgressHook.baseState;
 
-    // Keep scanning and use the map to restore deleted items as moves.
-    for (; newIdx < newChildren.length; newIdx++) {
-      var _newFiber2 = updateFromMap(
-        existingChildren,
-        returnFiber,
-        newIdx,
-        newChildren[newIdx],
-        expirationTime
-      );
-      if (_newFiber2) {
-        if (shouldTrackSideEffects) {
-          if (_newFiber2.alternate !== null) {
-            // The new fiber is a work in progress, but if there exists a
-            // current, that means that we reused the fiber. We need to delete
-            // it from the child list so that we don't add it to the deletion
-            // list.
-            existingChildren.delete(
-              _newFiber2.key === null ? newIdx : _newFiber2.key
-            );
+    // Find the first unprocessed update.
+    var first = void 0;
+    if (_baseUpdate !== null) {
+      if (_last !== null) {
+        // For the first update, the queue is a circular linked list where
+        // `queue.last.next = queue.first`. Once the first update commits, and
+        // the `baseUpdate` is no longer empty, we can unravel the list.
+        _last.next = null;
+      }
+      first = _baseUpdate.next;
+    } else {
+      first = _last !== null ? _last.next : null;
+    }
+    if (first !== null) {
+      var _newState = _baseState;
+      var newBaseState = null;
+      var newBaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      var _update = first;
+      var didSkip = false;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        if (updateExpirationTime < renderExpirationTime) {
+          // Priority is insufficient. Skip this update. If this is the first
+          // skipped update, the previous update/state is the new base
+          // update/state.
+          if (!didSkip) {
+            didSkip = true;
+            newBaseUpdate = prevUpdate;
+            newBaseState = _newState;
+          }
+          // Update the remaining priority in the queue.
+          if (updateExpirationTime > remainingExpirationTime) {
+            remainingExpirationTime = updateExpirationTime;
           }
-        }
-        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          resultingFirstChild = _newFiber2;
         } else {
-          previousNewFiber.sibling = _newFiber2;
+          // Process this update.
+          if (_update.eagerReducer === reducer) {
+            // If this update was processed eagerly, and its reducer matches the
+            // current reducer, we can use the eagerly computed state.
+            _newState = _update.eagerState;
+          } else {
+            var _action2 = _update.action;
+            // Temporarily clear to forbid calling Hooks in a reducer.
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            _newState = reducer(_newState, _action2);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+          }
         }
-        previousNewFiber = _newFiber2;
-      }
-    }
-
-    if (shouldTrackSideEffects) {
-      // Any existing children that weren't consumed above were deleted. We need
-      // to add them to the deletion list.
-      existingChildren.forEach(function(child) {
-        return deleteChild(returnFiber, child);
-      });
-    }
-
-    return resultingFirstChild;
-  }
-
-  function reconcileChildrenIterator(
-    returnFiber,
-    currentFirstChild,
-    newChildrenIterable,
-    expirationTime
-  ) {
-    // This is the same implementation as reconcileChildrenArray(),
-    // but using the iterator instead.
-
-    var iteratorFn = getIteratorFn(newChildrenIterable);
-    invariant(
-      typeof iteratorFn === "function",
-      "An object is not an iterable. This error is likely caused by a bug in " +
-        "React. Please file an issue."
-    );
+        prevUpdate = _update;
+        _update = _update.next;
+      } while (_update !== null && _update !== first);
 
-    {
-      // We don't support rendering Generators because it's a mutation.
-      // See https://github.com/facebook/react/issues/12995
-      if (
-        typeof Symbol === "function" &&
-        // $FlowFixMe Flow doesn't know about toStringTag
-        newChildrenIterable[Symbol.toStringTag] === "Generator"
-      ) {
-        !didWarnAboutGenerators
-          ? warning$1(
-              false,
-              "Using Generators as children is unsupported and will likely yield " +
-                "unexpected results because enumerating a generator mutates it. " +
-                "You may convert it to an array with `Array.from()` or the " +
-                "`[...spread]` operator before rendering. Keep in mind " +
-                "you might need to polyfill these features for older browsers."
-            )
-          : void 0;
-        didWarnAboutGenerators = true;
+      if (!didSkip) {
+        newBaseUpdate = prevUpdate;
+        newBaseState = _newState;
       }
 
-      // Warn about using Maps as children
-      if (newChildrenIterable.entries === iteratorFn) {
-        !didWarnAboutMaps
-          ? warning$1(
-              false,
-              "Using Maps as children is unsupported and will likely yield " +
-                "unexpected results. Convert it to a sequence/iterable of keyed " +
-                "ReactElements instead."
-            )
-          : void 0;
-        didWarnAboutMaps = true;
-      }
+      workInProgressHook.memoizedState = _newState;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = newBaseState;
 
-      // First, validate keys.
-      // We'll get a different iterator later for the main pass.
-      var _newChildren = iteratorFn.call(newChildrenIterable);
-      if (_newChildren) {
-        var knownKeys = null;
-        var _step = _newChildren.next();
-        for (; !_step.done; _step = _newChildren.next()) {
-          var child = _step.value;
-          knownKeys = warnOnInvalidKey(child, knownKeys);
-        }
+      // Mark that the fiber performed work, but only if the new state is
+      // different from the current state.
+      if (_newState !== currentHook.memoizedState) {
+        markWorkInProgressReceivedUpdate();
       }
-    }
-
-    var newChildren = iteratorFn.call(newChildrenIterable);
-    invariant(newChildren != null, "An iterable object provided no iterator.");
 
-    var resultingFirstChild = null;
-    var previousNewFiber = null;
+      queue.eagerReducer = reducer;
+      queue.eagerState = _newState;
+    }
 
-    var oldFiber = currentFirstChild;
-    var lastPlacedIndex = 0;
-    var newIdx = 0;
-    var nextOldFiber = null;
+    var _dispatch = queue.dispatch;
+    return [workInProgressHook.memoizedState, _dispatch];
+  }
+  // Temporarily clear to forbid calling Hooks in a reducer.
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  // There's no existing queue, so this is the initial render.
+  if (reducer === basicStateReducer) {
+    // Special case for `useState`.
+    if (typeof initialState === "function") {
+      initialState = initialState();
+    }
+  } else if (initialAction !== undefined && initialAction !== null) {
+    initialState = reducer(initialState, initialAction);
+  }
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null,
+    eagerReducer: reducer,
+    eagerState: initialState
+  };
+  var dispatch = (queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  ));
+  return [workInProgressHook.memoizedState, dispatch];
+}
 
-    var step = newChildren.next();
-    for (
-      ;
-      oldFiber !== null && !step.done;
-      newIdx++, step = newChildren.next()
-    ) {
-      if (oldFiber.index > newIdx) {
-        nextOldFiber = oldFiber;
-        oldFiber = null;
-      } else {
-        nextOldFiber = oldFiber.sibling;
-      }
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        step.value,
-        expirationTime
-      );
-      if (newFiber === null) {
-        // TODO: This breaks on empty slots like null children. That's
-        // unfortunate because it triggers the slow path all the time. We need
-        // a better way to communicate whether this was a miss or null,
-        // boolean, undefined, etc.
-        if (!oldFiber) {
-          oldFiber = nextOldFiber;
-        }
-        break;
-      }
-      if (shouldTrackSideEffects) {
-        if (oldFiber && newFiber.alternate === null) {
-          // We matched the slot, but we didn't reuse the existing fiber, so we
-          // need to delete the existing child.
-          deleteChild(returnFiber, oldFiber);
-        }
-      }
-      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
-      if (previousNewFiber === null) {
-        // TODO: Move out of the loop. This only happens for the first run.
-        resultingFirstChild = newFiber;
-      } else {
-        // TODO: Defer siblings if we're not at the right index for this slot.
-        // I.e. if we had null values before, then we want to defer this
-        // for each null value. However, we also don't want to call updateSlot
-        // with the previous one.
-        previousNewFiber.sibling = newFiber;
-      }
-      previousNewFiber = newFiber;
-      oldFiber = nextOldFiber;
+function pushEffect(tag, create, destroy, deps) {
+  var effect = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    deps: deps,
+    // Circular
+    next: null
+  };
+  if (componentUpdateQueue === null) {
+    componentUpdateQueue = createFunctionComponentUpdateQueue();
+    componentUpdateQueue.lastEffect = effect.next = effect;
+  } else {
+    var _lastEffect = componentUpdateQueue.lastEffect;
+    if (_lastEffect === null) {
+      componentUpdateQueue.lastEffect = effect.next = effect;
+    } else {
+      var firstEffect = _lastEffect.next;
+      _lastEffect.next = effect;
+      effect.next = firstEffect;
+      componentUpdateQueue.lastEffect = effect;
     }
+  }
+  return effect;
+}
 
-    if (step.done) {
-      // We've reached the end of the new children. We can delete the rest.
-      deleteRemainingChildren(returnFiber, oldFiber);
-      return resultingFirstChild;
+function useRef(initialValue) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  {
+    currentHookNameInDev = "useRef";
+  }
+  workInProgressHook = createWorkInProgressHook();
+  {
+    currentHookNameInDev = null;
+  }
+  var ref = void 0;
+
+  if (workInProgressHook.memoizedState === null) {
+    ref = { current: initialValue };
+    {
+      Object.seal(ref);
     }
+    workInProgressHook.memoizedState = ref;
+  } else {
+    ref = workInProgressHook.memoizedState;
+  }
+  return ref;
+}
 
-    if (oldFiber === null) {
-      // If we don't have any more existing children we can choose a fast path
-      // since the rest will all be insertions.
-      for (; !step.done; newIdx++, step = newChildren.next()) {
-        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
-        if (_newFiber3 === null) {
-          continue;
-        }
-        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          // TODO: Move out of the loop. This only happens for the first run.
-          resultingFirstChild = _newFiber3;
-        } else {
-          previousNewFiber.sibling = _newFiber3;
-        }
-        previousNewFiber = _newFiber3;
-      }
-      return resultingFirstChild;
+function useLayoutEffect(create, deps) {
+  {
+    if (currentHookNameInDev !== "useImperativeHandle") {
+      currentHookNameInDev = "useLayoutEffect";
     }
+  }
+  useEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
+}
 
-    // Add all children to a key map for quick lookups.
-    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
+function useEffect(create, deps) {
+  {
+    currentHookNameInDev = "useEffect";
+  }
+  useEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
+}
 
-    // Keep scanning and use the map to restore deleted items as moves.
-    for (; !step.done; newIdx++, step = newChildren.next()) {
-      var _newFiber4 = updateFromMap(
-        existingChildren,
-        returnFiber,
-        newIdx,
-        step.value,
-        expirationTime
-      );
-      if (_newFiber4 !== null) {
-        if (shouldTrackSideEffects) {
-          if (_newFiber4.alternate !== null) {
-            // The new fiber is a work in progress, but if there exists a
-            // current, that means that we reused the fiber. We need to delete
-            // it from the child list so that we don't add it to the deletion
-            // list.
-            existingChildren.delete(
-              _newFiber4.key === null ? newIdx : _newFiber4.key
-            );
-          }
-        }
-        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          resultingFirstChild = _newFiber4;
-        } else {
-          previousNewFiber.sibling = _newFiber4;
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextDeps = deps === undefined ? null : deps;
+  var destroy = null;
+  if (currentHook !== null) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (nextDeps !== null) {
+      var prevDeps = prevEffect.deps;
+      if (areHookInputsEqual(nextDeps, prevDeps)) {
+        pushEffect(NoEffect$1, create, destroy, nextDeps);
+        {
+          currentHookNameInDev = null;
         }
-        previousNewFiber = _newFiber4;
+        return;
       }
     }
+  }
 
-    if (shouldTrackSideEffects) {
-      // Any existing children that weren't consumed above were deleted. We need
-      // to add them to the deletion list.
-      existingChildren.forEach(function(child) {
-        return deleteChild(returnFiber, child);
-      });
-    }
-
-    return resultingFirstChild;
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    nextDeps
+  );
+  {
+    currentHookNameInDev = null;
   }
+}
 
-  function reconcileSingleTextNode(
-    returnFiber,
-    currentFirstChild,
-    textContent,
-    expirationTime
-  ) {
-    // There's no need to check for keys on text nodes since we don't have a
-    // way to define them.
-    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
-      // We already have an existing node so let's just update it and delete
-      // the rest.
-      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
-      var existing = useFiber(currentFirstChild, textContent, expirationTime);
-      existing.return = returnFiber;
-      return existing;
-    }
-    // The existing first child is not a text node so we need to create one
-    // and delete the existing ones.
-    deleteRemainingChildren(returnFiber, currentFirstChild);
-    var created = createFiberFromText(
-      textContent,
-      returnFiber.mode,
-      expirationTime
-    );
-    created.return = returnFiber;
-    return created;
+function useImperativeHandle(ref, create, deps) {
+  {
+    currentHookNameInDev = "useImperativeHandle";
+    !(typeof create === "function")
+      ? warning$1(
+          false,
+          "Expected useImperativeHandle() second argument to be a function " +
+            "that creates a handle. Instead received: %s.",
+          create !== null ? typeof create : "null"
+        )
+      : void 0;
   }
+  // TODO: If deps are provided, should we skip comparing the ref itself?
+  var nextDeps =
+    deps !== null && deps !== undefined ? deps.concat([ref]) : [ref];
 
-  function reconcileSingleElement(
-    returnFiber,
-    currentFirstChild,
-    element,
-    expirationTime
-  ) {
-    var key = element.key;
-    var child = currentFirstChild;
-    while (child !== null) {
-      // TODO: If key === null and child.key === null, then this only applies to
-      // the first item in the list.
-      if (child.key === key) {
-        if (
-          child.tag === Fragment
-            ? element.type === REACT_FRAGMENT_TYPE
-            : child.elementType === element.type
-        ) {
-          deleteRemainingChildren(returnFiber, child.sibling);
-          var existing = useFiber(
-            child,
-            element.type === REACT_FRAGMENT_TYPE
-              ? element.props.children
-              : element.props,
-            expirationTime
-          );
-          existing.ref = coerceRef(returnFiber, child, element);
-          existing.return = returnFiber;
-          {
-            existing._debugSource = element._source;
-            existing._debugOwner = element._owner;
-          }
-          return existing;
-        } else {
-          deleteRemainingChildren(returnFiber, child);
-          break;
-        }
-      } else {
-        deleteChild(returnFiber, child);
+  // TODO: I've implemented this on top of useEffect because it's almost the
+  // same thing, and it would require an equal amount of code. It doesn't seem
+  // like a common enough use case to justify the additional size.
+  useLayoutEffect(function() {
+    if (typeof ref === "function") {
+      var refCallback = ref;
+      var _inst = create();
+      refCallback(_inst);
+      return function() {
+        return refCallback(null);
+      };
+    } else if (ref !== null && ref !== undefined) {
+      var refObject = ref;
+      {
+        !refObject.hasOwnProperty("current")
+          ? warning$1(
+              false,
+              "Expected useImperativeHandle() first argument to either be a " +
+                "ref callback or React.createRef() object. Instead received: %s.",
+              "an object with keys {" + Object.keys(refObject).join(", ") + "}"
+            )
+          : void 0;
       }
-      child = child.sibling;
+      var _inst2 = create();
+      refObject.current = _inst2;
+      return function() {
+        refObject.current = null;
+      };
     }
+  }, nextDeps);
+}
 
-    if (element.type === REACT_FRAGMENT_TYPE) {
-      var created = createFiberFromFragment(
-        element.props.children,
-        returnFiber.mode,
-        expirationTime,
-        element.key
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      var _created4 = createFiberFromElement(
-        element,
-        returnFiber.mode,
-        expirationTime
-      );
-      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
-      _created4.return = returnFiber;
-      return _created4;
-    }
+function useDebugValue(value, formatterFn) {
+  {
+    currentHookNameInDev = "useDebugValue";
   }
 
-  function reconcileSinglePortal(
-    returnFiber,
-    currentFirstChild,
-    portal,
-    expirationTime
-  ) {
-    var key = portal.key;
-    var child = currentFirstChild;
-    while (child !== null) {
-      // TODO: If key === null and child.key === null, then this only applies to
-      // the first item in the list.
-      if (child.key === key) {
-        if (
-          child.tag === HostPortal &&
-          child.stateNode.containerInfo === portal.containerInfo &&
-          child.stateNode.implementation === portal.implementation
-        ) {
-          deleteRemainingChildren(returnFiber, child.sibling);
-          var existing = useFiber(child, portal.children || [], expirationTime);
-          existing.return = returnFiber;
-          return existing;
-        } else {
-          deleteRemainingChildren(returnFiber, child);
-          break;
-        }
-      } else {
-        deleteChild(returnFiber, child);
+  // This will trigger a warning if the hook is used in a non-Function component.
+  resolveCurrentlyRenderingFiber();
+
+  // This hook is normally a no-op.
+  // The react-debug-hooks package injects its own implementation
+  // so that e.g. DevTools can display custom hook values.
+}
+
+function useCallback(callback, deps) {
+  {
+    currentHookNameInDev = "useCallback";
+  }
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextDeps = deps === undefined ? null : deps;
+
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    if (nextDeps !== null) {
+      var prevDeps = prevState[1];
+      if (areHookInputsEqual(nextDeps, prevDeps)) {
+        currentHookNameInDev = null;
+        return prevState[0];
       }
-      child = child.sibling;
     }
+  }
+  workInProgressHook.memoizedState = [callback, nextDeps];
+  {
+    currentHookNameInDev = null;
+  }
+  return callback;
+}
 
-    var created = createFiberFromPortal(
-      portal,
-      returnFiber.mode,
-      expirationTime
-    );
-    created.return = returnFiber;
-    return created;
+function useMemo(nextCreate, deps) {
+  {
+    currentHookNameInDev = "useMemo";
   }
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
 
-  // This API will tag the children with the side-effect of the reconciliation
-  // itself. They will be added to the side-effect list as we pass through the
-  // children and the parent.
-  function reconcileChildFibers(
-    returnFiber,
-    currentFirstChild,
-    newChild,
-    expirationTime
-  ) {
-    // This function is not recursive.
-    // If the top level item is an array, we treat it as a set of children,
-    // not as a fragment. Nested arrays on the other hand will be treated as
-    // fragment nodes. Recursion happens at the normal flow.
+  var nextDeps = deps === undefined ? null : deps;
 
-    // Handle top level unkeyed fragments as if they were arrays.
-    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
-    // We treat the ambiguous cases above the same.
-    var isUnkeyedTopLevelFragment =
-      typeof newChild === "object" &&
-      newChild !== null &&
-      newChild.type === REACT_FRAGMENT_TYPE &&
-      newChild.key === null;
-    if (isUnkeyedTopLevelFragment) {
-      newChild = newChild.props.children;
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    // Assume these are defined. If they're not, areHookInputsEqual will warn.
+    if (nextDeps !== null) {
+      var prevDeps = prevState[1];
+      if (areHookInputsEqual(nextDeps, prevDeps)) {
+        {
+          currentHookNameInDev = null;
+        }
+        return prevState[0];
+      }
     }
+  }
 
-    // Handle object types
-    var isObject = typeof newChild === "object" && newChild !== null;
+  // Temporarily clear to forbid calling Hooks.
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  var nextValue = nextCreate();
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = [nextValue, nextDeps];
+  {
+    currentHookNameInDev = null;
+  }
+  return nextValue;
+}
 
-    if (isObject) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE:
-          return placeSingleChild(
-            reconcileSingleElement(
-              returnFiber,
-              currentFirstChild,
-              newChild,
-              expirationTime
-            )
-          );
-        case REACT_PORTAL_TYPE:
-          return placeSingleChild(
-            reconcileSinglePortal(
-              returnFiber,
-              currentFirstChild,
-              newChild,
-              expirationTime
-            )
-          );
-      }
-    }
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    numberOfReRenders < RE_RENDER_LIMIT,
+    "Too many re-renders. React limits the number of renders to prevent " +
+      "an infinite loop."
+  );
 
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      return placeSingleChild(
-        reconcileSingleTextNode(
-          returnFiber,
-          currentFirstChild,
-          "" + newChild,
-          expirationTime
+  {
+    !(arguments.length <= 3)
+      ? warning$1(
+          false,
+          "State updates from the useState() and useReducer() Hooks don't support the " +
+            "second callback argument. To execute a side effect after " +
+            "rendering, declare it in the component body with useEffect()."
         )
-      );
-    }
+      : void 0;
+  }
 
-    if (isArray(newChild)) {
-      return reconcileChildrenArray(
-        returnFiber,
-        currentFirstChild,
-        newChild,
-        expirationTime
-      );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (alternate !== null && alternate === currentlyRenderingFiber$1)
+  ) {
+    // This is a render phase update. Stash it in a lazily-created map of
+    // queue -> linked list of updates. After this render pass, we'll restart
+    // and apply the stashed updates on top of the work-in-progress hook.
+    didScheduleRenderPhaseUpdate = true;
+    var update = {
+      expirationTime: renderExpirationTime,
+      action: action,
+      eagerReducer: null,
+      eagerState: null,
+      next: null
+    };
+    if (renderPhaseUpdates === null) {
+      renderPhaseUpdates = new Map();
     }
-
-    if (getIteratorFn(newChild)) {
-      return reconcileChildrenIterator(
-        returnFiber,
-        currentFirstChild,
-        newChild,
-        expirationTime
-      );
+    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+    if (firstRenderPhaseUpdate === undefined) {
+      renderPhaseUpdates.set(queue, update);
+    } else {
+      // Append the update to the end of the list.
+      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
+      while (lastRenderPhaseUpdate.next !== null) {
+        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
+      }
+      lastRenderPhaseUpdate.next = update;
     }
+  } else {
+    flushPassiveEffects();
 
-    if (isObject) {
-      throwOnInvalidObjectType(returnFiber, newChild);
-    }
+    var currentTime = requestCurrentTime();
+    var _expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-    {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
+    var _update2 = {
+      expirationTime: _expirationTime,
+      action: action,
+      eagerReducer: null,
+      eagerState: null,
+      next: null
+    };
+
+    // Append the update to the end of the list.
+    var _last2 = queue.last;
+    if (_last2 === null) {
+      // This is the first update. Create a circular list.
+      _update2.next = _update2;
+    } else {
+      var first = _last2.next;
+      if (first !== null) {
+        // Still circular.
+        _update2.next = first;
       }
+      _last2.next = _update2;
     }
-    if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
-      // If the new child is undefined, and the return fiber is a composite
-      // component, throw an error. If Fiber return types are disabled,
-      // we already threw above.
-      switch (returnFiber.tag) {
-        case ClassComponent: {
-          {
-            var instance = returnFiber.stateNode;
-            if (instance.render._isMockFunction) {
-              // We allow auto-mocks to proceed as if they're returning null.
-              break;
-            }
+    queue.last = _update2;
+
+    if (
+      fiber.expirationTime === NoWork &&
+      (alternate === null || alternate.expirationTime === NoWork)
+    ) {
+      // The queue is currently empty, which means we can eagerly compute the
+      // next state before entering the render phase. If the new state is the
+      // same as the current state, we may be able to bail out entirely.
+      var _eagerReducer = queue.eagerReducer;
+      if (_eagerReducer !== null) {
+        try {
+          var currentState = queue.eagerState;
+          // Temporarily clear to forbid calling Hooks in a reducer.
+          var maybeFiber = currentlyRenderingFiber$1; // Note: likely null now unlike `fiber`
+          currentlyRenderingFiber$1 = null;
+          stashContextDependencies();
+          var _eagerState = _eagerReducer(currentState, action);
+          currentlyRenderingFiber$1 = maybeFiber;
+          unstashContextDependencies();
+          // Stash the eagerly computed state, and the reducer used to compute
+          // it, on the update object. If the reducer hasn't changed by the
+          // time we enter the render phase, then the eager state can be used
+          // without calling the reducer again.
+          _update2.eagerReducer = _eagerReducer;
+          _update2.eagerState = _eagerState;
+          if (_eagerState === currentState) {
+            // Fast path. We can bail out without scheduling React to re-render.
+            // It's still possible that we'll need to rebase this update later,
+            // if the component re-renders for a different reason and by that
+            // time the reducer has changed.
+            return;
           }
-        }
-        // Intentionally fall through to the next case, which handles both
-        // functions and classes
-        // eslint-disable-next-lined no-fallthrough
-        case FunctionComponent: {
-          var Component = returnFiber.type;
-          invariant(
-            false,
-            "%s(...): Nothing was returned from render. This usually means a " +
-              "return statement is missing. Or, to render nothing, " +
-              "return null.",
-            Component.displayName || Component.name || "Component"
-          );
+        } catch (error) {
+          // Suppress the error. It will throw again in the render phase.
         }
       }
     }
-
-    // Remaining cases are all treated as empty.
-    return deleteRemainingChildren(returnFiber, currentFirstChild);
+    scheduleWork(fiber, _expirationTime);
   }
+}
 
-  return reconcileChildFibers;
+var commitTime = 0;
+var profilerStartTime = -1;
+
+function getCommitTime() {
+  return commitTime;
 }
 
-var reconcileChildFibers = ChildReconciler(true);
-var mountChildFibers = ChildReconciler(false);
+function recordCommitTime() {
+  if (!enableProfilerTimer) {
+    return;
+  }
+  commitTime = now$$1();
+}
 
-function cloneChildFibers(current$$1, workInProgress) {
-  invariant(
-    current$$1 === null || workInProgress.child === current$$1.child,
-    "Resuming work not yet implemented."
-  );
+function startProfilerTimer(fiber) {
+  if (!enableProfilerTimer) {
+    return;
+  }
 
-  if (workInProgress.child === null) {
+  profilerStartTime = now$$1();
+
+  if (fiber.actualStartTime < 0) {
+    fiber.actualStartTime = now$$1();
+  }
+}
+
+function stopProfilerTimerIfRunning(fiber) {
+  if (!enableProfilerTimer) {
     return;
   }
+  profilerStartTime = -1;
+}
 
-  var currentChild = workInProgress.child;
-  var newChild = createWorkInProgress(
-    currentChild,
-    currentChild.pendingProps,
-    currentChild.expirationTime
-  );
-  workInProgress.child = newChild;
+function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
+  if (!enableProfilerTimer) {
+    return;
+  }
 
-  newChild.return = workInProgress;
-  while (currentChild.sibling !== null) {
-    currentChild = currentChild.sibling;
-    newChild = newChild.sibling = createWorkInProgress(
-      currentChild,
-      currentChild.pendingProps,
-      currentChild.expirationTime
-    );
-    newChild.return = workInProgress;
+  if (profilerStartTime >= 0) {
+    var elapsedTime = now$$1() - profilerStartTime;
+    fiber.actualDuration += elapsedTime;
+    if (overrideBaseTime) {
+      fiber.selfBaseDuration = elapsedTime;
+    }
+    profilerStartTime = -1;
   }
-  newChild.sibling = null;
 }
 
 // The deepest Fiber on the stack involved in a hydration context.
@@ -10776,6 +10821,8 @@ function resetHydrationState() {
 
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 
+var didReceiveUpdate = false;
+
 var didWarnAboutBadClass = void 0;
 var didWarnAboutContextTypeOnFunctionComponent = void 0;
 var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
@@ -10885,14 +10932,45 @@ function updateForwardRef(
   // The rest is a fork of updateFunctionComponent
   var nextChildren = void 0;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
-    nextChildren = render(nextProps, ref);
+    nextChildren = renderWithHooks(
+      current$$1,
+      workInProgress,
+      render,
+      nextProps,
+      ref,
+      renderExpirationTime
+    );
+    if (
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
+    ) {
+      // Only double-render components with Hooks
+      if (workInProgress.memoizedState !== null) {
+        renderWithHooks(
+          current$$1,
+          workInProgress,
+          render,
+          nextProps,
+          ref,
+          renderExpirationTime
+        );
+      }
+    }
     setCurrentPhase(null);
   }
-  nextChildren = finishHooks(render, nextProps, nextChildren, ref);
+
+  if (current$$1 !== null && !didReceiveUpdate) {
+    bailoutHooks(current$$1, workInProgress, renderExpirationTime);
+    return bailoutOnAlreadyFinishedWork(
+      current$$1,
+      workInProgress,
+      renderExpirationTime
+    );
+  }
 
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -11044,17 +11122,20 @@ function updateSimpleMemoComponent(
       // Inner propTypes will be validated in the function component path.
     }
   }
-  if (current$$1 !== null && updateExpirationTime < renderExpirationTime) {
+  if (current$$1 !== null) {
     var prevProps = current$$1.memoizedProps;
     if (
       shallowEqual(prevProps, nextProps) &&
       current$$1.ref === workInProgress.ref
     ) {
-      return bailoutOnAlreadyFinishedWork(
-        current$$1,
-        workInProgress,
-        renderExpirationTime
-      );
+      didReceiveUpdate = false;
+      if (updateExpirationTime < renderExpirationTime) {
+        return bailoutOnAlreadyFinishedWork(
+          current$$1,
+          workInProgress,
+          renderExpirationTime
+        );
+      }
     }
   }
   return updateFunctionComponent(
@@ -11143,14 +11224,45 @@ function updateFunctionComponent(
 
   var nextChildren = void 0;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
-    nextChildren = Component(nextProps, context);
+    nextChildren = renderWithHooks(
+      current$$1,
+      workInProgress,
+      Component,
+      nextProps,
+      context,
+      renderExpirationTime
+    );
+    if (
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
+    ) {
+      // Only double-render components with Hooks
+      if (workInProgress.memoizedState !== null) {
+        renderWithHooks(
+          current$$1,
+          workInProgress,
+          Component,
+          nextProps,
+          context,
+          renderExpirationTime
+        );
+      }
+    }
     setCurrentPhase(null);
   }
-  nextChildren = finishHooks(Component, nextProps, nextChildren, context);
+
+  if (current$$1 !== null && !didReceiveUpdate) {
+    bailoutHooks(current$$1, workInProgress, renderExpirationTime);
+    return bailoutOnAlreadyFinishedWork(
+      current$$1,
+      workInProgress,
+      renderExpirationTime
+    );
+  }
 
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -11485,7 +11597,7 @@ function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
     shouldDeprioritizeSubtree(type, nextProps)
   ) {
     // Schedule this fiber to re-render at offscreen priority. Then bailout.
-    workInProgress.expirationTime = Never;
+    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
     return null;
   }
 
@@ -11538,6 +11650,9 @@ function mountLazyComponent(
   var child = void 0;
   switch (resolvedTag) {
     case FunctionComponent: {
+      {
+        validateFunctionComponentInDev(workInProgress, Component);
+      }
       child = updateFunctionComponent(
         null,
         workInProgress,
@@ -11698,7 +11813,6 @@ function mountIndeterminateComponent(
   var context = getMaskedContext(workInProgress, unmaskedContext);
 
   prepareToReadContext(workInProgress, renderExpirationTime);
-  prepareToUseHooks(null, workInProgress, renderExpirationTime);
 
   var value = void 0;
 
@@ -11726,7 +11840,14 @@ function mountIndeterminateComponent(
     }
 
     ReactCurrentOwner$3.current = workInProgress;
-    value = Component(props, context);
+    value = renderWithHooks(
+      null,
+      workInProgress,
+      Component,
+      props,
+      context,
+      renderExpirationTime
+    );
   }
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -11780,7 +11901,25 @@ function mountIndeterminateComponent(
   } else {
     // Proceed under the assumption that this is a function component
     workInProgress.tag = FunctionComponent;
-    value = finishHooks(Component, props, value, context);
+    {
+      if (
+        debugRenderPhaseSideEffects ||
+        (debugRenderPhaseSideEffectsForStrictMode &&
+          workInProgress.mode & StrictMode)
+      ) {
+        // Only double-render components with Hooks
+        if (workInProgress.memoizedState !== null) {
+          renderWithHooks(
+            null,
+            workInProgress,
+            Component,
+            props,
+            context,
+            renderExpirationTime
+          );
+        }
+      }
+    }
     reconcileChildren(null, workInProgress, value, renderExpirationTime);
     {
       validateFunctionComponentInDev(workInProgress, Component);
@@ -11816,7 +11955,8 @@ function validateFunctionComponentInDev(workInProgress, Component) {
       warning$1(
         false,
         "Function components cannot be given refs. " +
-          "Attempts to access this ref will fail.%s",
+          "Attempts to access this ref will fail. " +
+          "Did you mean to use React.forwardRef()?%s",
         info
       );
     }
@@ -12105,6 +12245,7 @@ function updateSuspenseComponent(
         );
       }
     }
+    workInProgress.stateNode = current$$1.stateNode;
   }
 
   workInProgress.memoizedState = nextState;
@@ -12275,6 +12416,10 @@ function updateContextConsumer(
   return workInProgress.child;
 }
 
+function markWorkInProgressReceivedUpdate() {
+  didReceiveUpdate = true;
+}
+
 function bailoutOnAlreadyFinishedWork(
   current$$1,
   workInProgress,
@@ -12284,7 +12429,7 @@ function bailoutOnAlreadyFinishedWork(
 
   if (current$$1 !== null) {
     // Reuse previous context list
-    workInProgress.firstContextDependency = current$$1.firstContextDependency;
+    workInProgress.contextDependencies = current$$1.contextDependencies;
   }
 
   if (enableProfilerTimer) {
@@ -12313,11 +12458,13 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
   if (current$$1 !== null) {
     var oldProps = current$$1.memoizedProps;
     var newProps = workInProgress.pendingProps;
-    if (
-      oldProps === newProps &&
-      !hasContextChanged() &&
-      updateExpirationTime < renderExpirationTime
-    ) {
+
+    if (oldProps !== newProps || hasContextChanged()) {
+      // If props or context changed, mark the fiber as having performed work.
+      // This may be unset if the props are determined to be equal later (memo).
+      didReceiveUpdate = true;
+    } else if (updateExpirationTime < renderExpirationTime) {
+      didReceiveUpdate = false;
       // This fiber does not have any pending work. Bailout without entering
       // the begin phase. There's still some bookkeeping we that needs to be done
       // in this optimized path, mostly pushing stuff onto the stack.
@@ -12399,6 +12546,8 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         renderExpirationTime
       );
     }
+  } else {
+    didReceiveUpdate = false;
   }
 
   // Before entering the begin phase, clear the expiration time.
@@ -12528,48 +12677,358 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
           }
         }
       }
-      _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
-      return updateMemoComponent(
-        current$$1,
-        workInProgress,
-        _type2,
-        _resolvedProps3,
-        updateExpirationTime,
-        renderExpirationTime
-      );
+      _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
+      return updateMemoComponent(
+        current$$1,
+        workInProgress,
+        _type2,
+        _resolvedProps3,
+        updateExpirationTime,
+        renderExpirationTime
+      );
+    }
+    case SimpleMemoComponent: {
+      return updateSimpleMemoComponent(
+        current$$1,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        updateExpirationTime,
+        renderExpirationTime
+      );
+    }
+    case IncompleteClassComponent: {
+      var _Component3 = workInProgress.type;
+      var _unresolvedProps4 = workInProgress.pendingProps;
+      var _resolvedProps4 =
+        workInProgress.elementType === _Component3
+          ? _unresolvedProps4
+          : resolveDefaultProps(_Component3, _unresolvedProps4);
+      return mountIncompleteClassComponent(
+        current$$1,
+        workInProgress,
+        _Component3,
+        _resolvedProps4,
+        renderExpirationTime
+      );
+    }
+    default:
+      invariant(
+        false,
+        "Unknown unit of work tag. This error is likely caused by a bug in " +
+          "React. Please file an issue."
+      );
+  }
+}
+
+var valueCursor = createCursor(null);
+
+var rendererSigil = void 0;
+{
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+}
+
+var currentlyRenderingFiber = null;
+var lastContextDependency = null;
+var lastContextWithAllBitsObserved = null;
+
+// We stash the variables above before entering user code in Hooks.
+var stashedCurrentlyRenderingFiber = null;
+var stashedLastContextDependency = null;
+var stashedLastContextWithAllBitsObserved = null;
+
+function resetContextDependences() {
+  // This is called right before React yields execution, to ensure `readContext`
+  // cannot be called outside the render phase.
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+
+  stashedCurrentlyRenderingFiber = null;
+  stashedLastContextDependency = null;
+  stashedLastContextWithAllBitsObserved = null;
+}
+
+function stashContextDependencies() {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+}
+
+function unstashContextDependencies() {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+}
+
+function pushProvider(providerFiber, nextValue) {
+  var context = providerFiber.type._context;
+
+  if (isPrimaryRenderer) {
+    push(valueCursor, context._currentValue, providerFiber);
+
+    context._currentValue = nextValue;
+    {
+      !(
+        context._currentRenderer === undefined ||
+        context._currentRenderer === null ||
+        context._currentRenderer === rendererSigil
+      )
+        ? warningWithoutStack$1(
+            false,
+            "Detected multiple renderers concurrently rendering the " +
+              "same context provider. This is currently unsupported."
+          )
+        : void 0;
+      context._currentRenderer = rendererSigil;
+    }
+  } else {
+    push(valueCursor, context._currentValue2, providerFiber);
+
+    context._currentValue2 = nextValue;
+    {
+      !(
+        context._currentRenderer2 === undefined ||
+        context._currentRenderer2 === null ||
+        context._currentRenderer2 === rendererSigil
+      )
+        ? warningWithoutStack$1(
+            false,
+            "Detected multiple renderers concurrently rendering the " +
+              "same context provider. This is currently unsupported."
+          )
+        : void 0;
+      context._currentRenderer2 = rendererSigil;
+    }
+  }
+}
+
+function popProvider(providerFiber) {
+  var currentValue = valueCursor.current;
+
+  pop(valueCursor, providerFiber);
+
+  var context = providerFiber.type._context;
+  if (isPrimaryRenderer) {
+    context._currentValue = currentValue;
+  } else {
+    context._currentValue2 = currentValue;
+  }
+}
+
+function calculateChangedBits(context, newValue, oldValue) {
+  if (is(oldValue, newValue)) {
+    // No change
+    return 0;
+  } else {
+    var changedBits =
+      typeof context._calculateChangedBits === "function"
+        ? context._calculateChangedBits(oldValue, newValue)
+        : maxSigned31BitInt;
+
+    {
+      !((changedBits & maxSigned31BitInt) === changedBits)
+        ? warning$1(
+            false,
+            "calculateChangedBits: Expected the return value to be a " +
+              "31-bit integer. Instead received: %s",
+            changedBits
+          )
+        : void 0;
+    }
+    return changedBits | 0;
+  }
+}
+
+function propagateContextChange(
+  workInProgress,
+  context,
+  changedBits,
+  renderExpirationTime
+) {
+  var fiber = workInProgress.child;
+  if (fiber !== null) {
+    // Set the return pointer of the child to the work-in-progress fiber.
+    fiber.return = workInProgress;
+  }
+  while (fiber !== null) {
+    var nextFiber = void 0;
+
+    // Visit this fiber.
+    var list = fiber.contextDependencies;
+    if (list !== null) {
+      nextFiber = fiber.child;
+
+      var dependency = list.first;
+      while (dependency !== null) {
+        // Check if the context matches.
+        if (
+          dependency.context === context &&
+          (dependency.observedBits & changedBits) !== 0
+        ) {
+          // Match! Schedule an update on this fiber.
+
+          if (fiber.tag === ClassComponent) {
+            // Schedule a force update on the work-in-progress.
+            var update = createUpdate(renderExpirationTime);
+            update.tag = ForceUpdate;
+            // TODO: Because we don't have a work-in-progress, this will add the
+            // update to the current fiber, too, which means it will persist even if
+            // this render is thrown away. Since it's a race condition, not sure it's
+            // worth fixing.
+            enqueueUpdate(fiber, update);
+          }
+
+          if (fiber.expirationTime < renderExpirationTime) {
+            fiber.expirationTime = renderExpirationTime;
+          }
+          var alternate = fiber.alternate;
+          if (
+            alternate !== null &&
+            alternate.expirationTime < renderExpirationTime
+          ) {
+            alternate.expirationTime = renderExpirationTime;
+          }
+          // Update the child expiration time of all the ancestors, including
+          // the alternates.
+          var node = fiber.return;
+          while (node !== null) {
+            alternate = node.alternate;
+            if (node.childExpirationTime < renderExpirationTime) {
+              node.childExpirationTime = renderExpirationTime;
+              if (
+                alternate !== null &&
+                alternate.childExpirationTime < renderExpirationTime
+              ) {
+                alternate.childExpirationTime = renderExpirationTime;
+              }
+            } else if (
+              alternate !== null &&
+              alternate.childExpirationTime < renderExpirationTime
+            ) {
+              alternate.childExpirationTime = renderExpirationTime;
+            } else {
+              // Neither alternate was updated, which means the rest of the
+              // ancestor path already has sufficient priority.
+              break;
+            }
+            node = node.return;
+          }
+
+          // Mark the expiration time on the list, too.
+          if (list.expirationTime < renderExpirationTime) {
+            list.expirationTime = renderExpirationTime;
+          }
+
+          // Since we already found a match, we can stop traversing the
+          // dependency list.
+          break;
+        }
+        dependency = dependency.next;
+      }
+    } else if (fiber.tag === ContextProvider) {
+      // Don't scan deeper if this is a matching provider
+      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
+    } else {
+      // Traverse down.
+      nextFiber = fiber.child;
     }
-    case SimpleMemoComponent: {
-      return updateSimpleMemoComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        updateExpirationTime,
-        renderExpirationTime
-      );
+
+    if (nextFiber !== null) {
+      // Set the return pointer of the child to the work-in-progress fiber.
+      nextFiber.return = fiber;
+    } else {
+      // No child. Traverse to next sibling.
+      nextFiber = fiber;
+      while (nextFiber !== null) {
+        if (nextFiber === workInProgress) {
+          // We're back to the root of this subtree. Exit.
+          nextFiber = null;
+          break;
+        }
+        var sibling = nextFiber.sibling;
+        if (sibling !== null) {
+          // Set the return pointer of the sibling to the work-in-progress fiber.
+          sibling.return = nextFiber.return;
+          nextFiber = sibling;
+          break;
+        }
+        // No more siblings. Traverse up.
+        nextFiber = nextFiber.return;
+      }
     }
-    case IncompleteClassComponent: {
-      var _Component3 = workInProgress.type;
-      var _unresolvedProps4 = workInProgress.pendingProps;
-      var _resolvedProps4 =
-        workInProgress.elementType === _Component3
-          ? _unresolvedProps4
-          : resolveDefaultProps(_Component3, _unresolvedProps4);
-      return mountIncompleteClassComponent(
-        current$$1,
-        workInProgress,
-        _Component3,
-        _resolvedProps4,
-        renderExpirationTime
-      );
+    fiber = nextFiber;
+  }
+}
+
+function prepareToReadContext(workInProgress, renderExpirationTime) {
+  currentlyRenderingFiber = workInProgress;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+
+  var currentDependencies = workInProgress.contextDependencies;
+  if (
+    currentDependencies !== null &&
+    currentDependencies.expirationTime >= renderExpirationTime
+  ) {
+    // Context list has a pending update. Mark that this fiber performed work.
+    markWorkInProgressReceivedUpdate();
+  }
+
+  // Reset the work-in-progress list
+  workInProgress.contextDependencies = null;
+}
+
+function readContext(context, observedBits) {
+  if (lastContextWithAllBitsObserved === context) {
+    // Nothing to do. We already observe everything in this context.
+  } else if (observedBits === false || observedBits === 0) {
+    // Do not observe any updates.
+  } else {
+    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
+    if (
+      typeof observedBits !== "number" ||
+      observedBits === maxSigned31BitInt
+    ) {
+      // Observe all updates.
+      lastContextWithAllBitsObserved = context;
+      resolvedObservedBits = maxSigned31BitInt;
+    } else {
+      resolvedObservedBits = observedBits;
     }
-    default:
+
+    var contextItem = {
+      context: context,
+      observedBits: resolvedObservedBits,
+      next: null
+    };
+
+    if (lastContextDependency === null) {
       invariant(
-        false,
-        "Unknown unit of work tag. This error is likely caused by a bug in " +
-          "React. Please file an issue."
+        currentlyRenderingFiber !== null,
+        "Context can only be read while React is rendering. " +
+          "In classes, you can read it in the render method or getDerivedStateFromProps. " +
+          "In function components, you can read it directly in the function body, but not " +
+          "inside Hooks like useReducer() or useMemo()."
       );
+
+      // This is the first dependency for this component. Create a new list.
+      lastContextDependency = contextItem;
+      currentlyRenderingFiber.contextDependencies = {
+        first: contextItem,
+        expirationTime: NoWork
+      };
+    } else {
+      // Append a new context item.
+      lastContextDependency = lastContextDependency.next = contextItem;
+    }
   }
+  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
 }
 
 function markUpdate(workInProgress) {
@@ -13192,18 +13651,10 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         }
       }
 
-      // The children either timed out after previously being visible, or
-      // were restored after previously being hidden. Schedule an effect
-      // to update their visiblity.
-      if (
-        //
-        nextDidTimeout !== prevDidTimeout ||
-        // Outside concurrent mode, the primary children commit in an
-        // inconsistent state, even if they are hidden. So if they are hidden,
-        // we need to schedule an effect to re-hide them, just in case.
-        ((workInProgress.effectTag & ConcurrentMode) === NoContext &&
-          nextDidTimeout)
-      ) {
+      if (nextDidTimeout || prevDidTimeout) {
+        // If the children are hidden, or if they were previous hidden, schedule
+        // an effect to toggle their visibility. This is also used to attach a
+        // retry listener to the promise.
         workInProgress.effectTag |= Update;
       }
       break;
@@ -13246,7 +13697,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   return null;
 }
 
-function shouldCaptureSuspense(current, workInProgress) {
+function shouldCaptureSuspense(workInProgress) {
   // In order to capture, the Suspense component must have a fallback prop.
   if (workInProgress.memoizedProps.fallback === undefined) {
     return false;
@@ -13378,6 +13829,8 @@ var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
   didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
 }
 
+var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
+
 function logError(boundary, errorInfo) {
   var source = errorInfo.source;
   var stack = errorInfo.stack;
@@ -13556,9 +14009,6 @@ function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
 }
 
 function commitHookEffectList(unmountTag, mountTag, finishedWork) {
-  if (!enableHooks) {
-    return;
-  }
   var updateQueue = finishedWork.updateQueue;
   var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
   if (lastEffect !== null) {
@@ -14435,6 +14885,30 @@ function commitWork(current$$1, finishedWork) {
       if (primaryChildParent !== null) {
         hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
       }
+
+      // If this boundary just timed out, then it will have a set of thenables.
+      // For each thenable, attach a listener so that when it resolves, React
+      // attempts to re-render the boundary in the primary (pre-timeout) state.
+      var thenables = finishedWork.updateQueue;
+      if (thenables !== null) {
+        finishedWork.updateQueue = null;
+        var retryCache = finishedWork.stateNode;
+        if (retryCache === null) {
+          retryCache = finishedWork.stateNode = new PossiblyWeakSet();
+        }
+        thenables.forEach(function(thenable) {
+          // Memoize using the boundary fiber to prevent redundant listeners.
+          var retry = retryTimedOutBoundary.bind(null, finishedWork, thenable);
+          if (enableSchedulerTracing) {
+            retry = tracing.unstable_wrap(retry);
+          }
+          if (!retryCache.has(thenable)) {
+            retryCache.add(thenable);
+            thenable.then(retry, retry);
+          }
+        });
+      }
+
       return;
     }
     case IncompleteClassComponent: {
@@ -14457,6 +14931,8 @@ function commitResetTextContent(current$$1) {
   resetTextContent(current$$1.stateNode);
 }
 
+var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
+
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
   var update = createUpdate(expirationTime);
   // Unmount the root by rendering null.
@@ -14582,29 +15058,19 @@ function throwException(
     do {
       if (
         _workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(_workInProgress.alternate, _workInProgress)
+        shouldCaptureSuspense(_workInProgress)
       ) {
         // Found the nearest boundary.
 
-        // If the boundary is not in concurrent mode, we should not suspend, and
-        // likewise, when the promise resolves, we should ping synchronously.
-        var pingTime =
-          (_workInProgress.mode & ConcurrentMode) === NoEffect
-            ? Sync
-            : renderExpirationTime;
-
-        // Attach a listener to the promise to "ping" the root and retry.
-        var onResolveOrReject = retrySuspendedRoot.bind(
-          null,
-          root,
-          _workInProgress,
-          sourceFiber,
-          pingTime
-        );
-        if (enableSchedulerTracing) {
-          onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
+        // Stash the promise on the boundary fiber. If the boundary times out, we'll
+        var thenables = _workInProgress.updateQueue;
+        if (thenables === null) {
+          var updateQueue = new Set();
+          updateQueue.add(thenable);
+          _workInProgress.updateQueue = updateQueue;
+        } else {
+          thenables.add(thenable);
         }
-        thenable.then(onResolveOrReject, onResolveOrReject);
 
         // If the boundary is outside of concurrent mode, we should *not*
         // suspend the commit. Pretend as if the suspended component rendered
@@ -14623,18 +15089,25 @@ function throwException(
           sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
 
           if (sourceFiber.tag === ClassComponent) {
-            var _current = sourceFiber.alternate;
-            if (_current === null) {
+            var currentSourceFiber = sourceFiber.alternate;
+            if (currentSourceFiber === null) {
               // This is a new mount. Change the tag so it's not mistaken for a
               // completed class component. For example, we should not call
               // componentWillUnmount if it is deleted.
               sourceFiber.tag = IncompleteClassComponent;
+            } else {
+              // When we try rendering again, we should not reuse the current fiber,
+              // since it's known to be in an inconsistent state. Use a force updte to
+              // prevent a bail out.
+              var update = createUpdate(Sync);
+              update.tag = ForceUpdate;
+              enqueueUpdate(sourceFiber, update);
             }
           }
 
-          // The source fiber did not complete. Mark it with the current
-          // render priority to indicate that it still has pending work.
-          sourceFiber.expirationTime = renderExpirationTime;
+          // The source fiber did not complete. Mark it with Sync priority to
+          // indicate that it still has pending work.
+          sourceFiber.expirationTime = Sync;
 
           // Exit without suspending.
           return;
@@ -14643,6 +15116,37 @@ function throwException(
         // Confirmed that the boundary is in a concurrent mode tree. Continue
         // with the normal suspend path.
 
+        // Attach a listener to the promise to "ping" the root and retry. But
+        // only if one does not already exist for the current render expiration
+        // time (which acts like a "thread ID" here).
+        var pingCache = root.pingCache;
+        var threadIDs = void 0;
+        if (pingCache === null) {
+          pingCache = root.pingCache = new PossiblyWeakMap();
+          threadIDs = new Set();
+          pingCache.set(thenable, threadIDs);
+        } else {
+          threadIDs = pingCache.get(thenable);
+          if (threadIDs === undefined) {
+            threadIDs = new Set();
+            pingCache.set(thenable, threadIDs);
+          }
+        }
+        if (!threadIDs.has(renderExpirationTime)) {
+          // Memoize using the thread ID to prevent redundant listeners.
+          threadIDs.add(renderExpirationTime);
+          var ping = pingSuspendedRoot.bind(
+            null,
+            root,
+            thenable,
+            renderExpirationTime
+          );
+          if (enableSchedulerTracing) {
+            ping = tracing.unstable_wrap(ping);
+          }
+          thenable.then(ping, ping);
+        }
+
         var absoluteTimeoutMs = void 0;
         if (earliestTimeoutMs === -1) {
           // If no explicit threshold is given, default to an abitrarily large
@@ -14710,12 +15214,12 @@ function throwException(
         var _errorInfo = value;
         workInProgress.effectTag |= ShouldCapture;
         workInProgress.expirationTime = renderExpirationTime;
-        var update = createRootErrorUpdate(
+        var _update = createRootErrorUpdate(
           workInProgress,
           _errorInfo,
           renderExpirationTime
         );
-        enqueueCapturedUpdate(workInProgress, update);
+        enqueueCapturedUpdate(workInProgress, _update);
         return;
       }
       case ClassComponent:
@@ -14733,12 +15237,12 @@ function throwException(
           workInProgress.effectTag |= ShouldCapture;
           workInProgress.expirationTime = renderExpirationTime;
           // Schedule the error boundary to re-render using updated state
-          var _update = createClassErrorUpdate(
+          var _update2 = createClassErrorUpdate(
             workInProgress,
             errorInfo,
             renderExpirationTime
           );
-          enqueueCapturedUpdate(workInProgress, _update);
+          enqueueCapturedUpdate(workInProgress, _update2);
           return;
         }
         break;
@@ -14833,17 +15337,16 @@ var Dispatcher = {
   useCallback: useCallback,
   useContext: useContext,
   useEffect: useEffect,
-  useImperativeMethods: useImperativeMethods,
+  useImperativeHandle: useImperativeHandle,
+  useDebugValue: useDebugValue,
   useLayoutEffect: useLayoutEffect,
   useMemo: useMemo,
   useReducer: useReducer,
   useRef: useRef,
   useState: useState
 };
-var DispatcherWithoutHooks = {
-  readContext: readContext
-};
 
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
 var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
 
 var didWarnAboutStateTransition = void 0;
@@ -15153,6 +15656,9 @@ function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
     }
   }
   while (nextEffect !== null) {
+    {
+      setCurrentFiber(nextEffect);
+    }
     var effectTag = nextEffect.effectTag;
 
     if (effectTag & (Update | Callback)) {
@@ -15171,12 +15677,15 @@ function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
       commitAttachRef(nextEffect);
     }
 
-    if (enableHooks && effectTag & Passive) {
+    if (effectTag & Passive) {
       rootWithPendingPassiveEffects = finishedRoot;
     }
 
     nextEffect = nextEffect.nextEffect;
   }
+  {
+    resetCurrentFiber();
+  }
 }
 
 function commitPassiveEffects(root, firstEffect) {
@@ -15190,6 +15699,10 @@ function commitPassiveEffects(root, firstEffect) {
 
   var effect = firstEffect;
   do {
+    {
+      setCurrentFiber(effect);
+    }
+
     if (effect.effectTag & Passive) {
       var didError = false;
       var error = void 0;
@@ -15206,6 +15719,9 @@ function commitPassiveEffects(root, firstEffect) {
     }
     effect = effect.nextEffect;
   } while (effect !== null);
+  {
+    resetCurrentFiber();
+  }
 
   isRendering = previousIsRendering;
 
@@ -15407,11 +15923,7 @@ function commitRoot(root, finishedWork) {
     }
   }
 
-  if (
-    enableHooks &&
-    firstEffect !== null &&
-    rootWithPendingPassiveEffects !== null
-  ) {
+  if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {
     // This commit included a passive effect. These do not need to fire until
     // after the next paint. Schedule an callback to fire them in an async
     // event. To ensure serial execution, the callback will be flushed early if
@@ -15842,11 +16354,7 @@ function renderRoot(root, isYieldy) {
   flushPassiveEffects();
 
   isWorking = true;
-  if (enableHooks) {
-    ReactCurrentOwner$2.currentDispatcher = Dispatcher;
-  } else {
-    ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
-  }
+  ReactCurrentDispatcher.current = Dispatcher;
 
   var expirationTime = root.nextExpirationTimeToWorkOn;
 
@@ -15900,7 +16408,7 @@ function renderRoot(root, isYieldy) {
             subscriber.onWorkStarted(interactions, threadID);
           } catch (error) {
             // Work thrown by an interaction tracing subscriber should be rethrown,
-            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).
+            // But only once it's safe (to avoid leaving the scheduler in an invalid state).
             // Store the error for now and we'll re-throw in finishRendering().
             if (!hasUnhandledError) {
               hasUnhandledError = true;
@@ -16007,7 +16515,7 @@ function renderRoot(root, isYieldy) {
 
   // We're done performing work. Time to clean up.
   isWorking = false;
-  ReactCurrentOwner$2.currentDispatcher = null;
+  ReactCurrentDispatcher.current = null;
   resetContextDependences();
   resetHooks();
 
@@ -16254,56 +16762,54 @@ function renderDidError() {
   nextRenderDidError = true;
 }
 
-function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
-  var retryTime = void 0;
-
-  if (isPriorityLevelSuspended(root, suspendedTime)) {
-    // Ping at the original level
-    retryTime = suspendedTime;
+function pingSuspendedRoot(root, thenable, pingTime) {
+  // A promise that previously suspended React from committing has resolved.
+  // If React is still suspended, try again at the previous level (pingTime).
 
-    markPingedPriorityLevel(root, retryTime);
-  } else {
-    // Suspense already timed out. Compute a new expiration time
-    var currentTime = requestCurrentTime();
-    retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
-    markPendingPriorityLevel(root, retryTime);
+  var pingCache = root.pingCache;
+  if (pingCache !== null) {
+    // The thenable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    pingCache.delete(thenable);
   }
 
-  // TODO: If the suspense fiber has already rendered the primary children
-  // without suspending (that is, all of the promises have already resolved),
-  // we should not trigger another update here. One case this happens is when
-  // we are in sync mode and a single promise is thrown both on initial render
-  // and on update; we attach two .then(retrySuspendedRoot) callbacks and each
-  // one performs Sync work, rerendering the Suspense.
-
-  if ((boundaryFiber.mode & ConcurrentMode) !== NoContext) {
-    if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
-      // Received a ping at the same priority level at which we're currently
-      // rendering. Restart from the root.
-      nextRoot = null;
+  if (nextRoot !== null && nextRenderExpirationTime === pingTime) {
+    // Received a ping at the same priority level at which we're currently
+    // rendering. Restart from the root.
+    nextRoot = null;
+  } else {
+    // Confirm that the root is still suspended at this level. Otherwise exit.
+    if (isPriorityLevelSuspended(root, pingTime)) {
+      // Ping at the original level
+      markPingedPriorityLevel(root, pingTime);
+      var rootExpirationTime = root.expirationTime;
+      if (rootExpirationTime !== NoWork) {
+        requestWork(root, rootExpirationTime);
+      }
     }
   }
+}
 
-  scheduleWorkToRoot(boundaryFiber, retryTime);
-  if ((boundaryFiber.mode & ConcurrentMode) === NoContext) {
-    // Outside of concurrent mode, we must schedule an update on the source
-    // fiber, too, since it already committed in an inconsistent state and
-    // therefore does not have any pending work.
-    scheduleWorkToRoot(sourceFiber, retryTime);
-    var sourceTag = sourceFiber.tag;
-    if (sourceTag === ClassComponent && sourceFiber.stateNode !== null) {
-      // When we try rendering again, we should not reuse the current fiber,
-      // since it's known to be in an inconsistent state. Use a force updte to
-      // prevent a bail out.
-      var update = createUpdate(retryTime);
-      update.tag = ForceUpdate;
-      enqueueUpdate(sourceFiber, update);
-    }
+function retryTimedOutBoundary(boundaryFiber, thenable) {
+  // The boundary fiber (a Suspense component) previously timed out and was
+  // rendered in its fallback state. One of the promises that suspended it has
+  // resolved, which means at least part of the tree was likely unblocked. Try
+  var retryCache = boundaryFiber.stateNode;
+  if (retryCache !== null) {
+    // The thenable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    retryCache.delete(thenable);
   }
 
-  var rootExpirationTime = root.expirationTime;
-  if (rootExpirationTime !== NoWork) {
-    requestWork(root, rootExpirationTime);
+  var currentTime = requestCurrentTime();
+  var retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
+  var root = scheduleWorkToRoot(boundaryFiber, retryTime);
+  if (root !== null) {
+    markPendingPriorityLevel(root, retryTime);
+    var rootExpirationTime = root.expirationTime;
+    if (rootExpirationTime !== NoWork) {
+      requestWork(root, rootExpirationTime);
+    }
   }
 }
 
@@ -17265,11 +17771,43 @@ function getPublicRootInstance(container) {
   }
 }
 
+var overrideProps = null;
+
+{
+  var copyWithSetImpl = function(obj, path, idx, value) {
+    if (idx >= path.length) {
+      return value;
+    }
+    var key = path[idx];
+    var updated = Array.isArray(obj) ? obj.slice() : Object.assign({}, obj);
+    // $FlowFixMe number or string is fine here
+    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
+    return updated;
+  };
+
+  var copyWithSet = function(obj, path, value) {
+    return copyWithSetImpl(obj, path, 0, value);
+  };
+
+  // Support DevTools props for function components, forwardRef, memo, host components, etc.
+  overrideProps = function(fiber, path, value) {
+    flushPassiveEffects();
+    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
+    if (fiber.alternate) {
+      fiber.alternate.pendingProps = fiber.pendingProps;
+    }
+    scheduleWork(fiber, Sync);
+  };
+}
+
 function injectIntoDevTools(devToolsConfig) {
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
+  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
 
   return injectInternals(
     Object.assign({}, devToolsConfig, {
+      overrideProps: overrideProps,
+      currentDispatcherRef: ReactCurrentDispatcher,
       findHostInstanceByFiber: function(fiber) {
         var hostFiber = findCurrentHostFiber(fiber);
         if (hostFiber === null) {
@@ -17312,7 +17850,7 @@ function createPortal(
 
 // TODO: this is special because it gets imported during build.
 
-var ReactVersion = "16.6.1";
+var ReactVersion = "16.7.0";
 
 // Modules provided by RN:
 var NativeMethodsMixin = function(findNodeHandle, findHostInstance) {
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-prod.js
@@ -1777,7 +1777,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
-  this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
+  this.contextDependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
   this.mode = mode;
   this.effectTag = 0;
   this.lastEffect = this.firstEffect = this.nextEffect = null;
@@ -1826,7 +1826,7 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.firstContextDependency = current.firstContextDependency;
+  workInProgress.contextDependencies = current.contextDependencies;
   workInProgress.sibling = current.sibling;
   workInProgress.index = current.index;
   workInProgress.ref = current.ref;
@@ -1952,24 +1952,21 @@ function markPendingPriorityLevel(root, expirationTime) {
 }
 function markSuspendedPriorityLevel(root, suspendedTime) {
   root.didError = !1;
-  var latestPingedTime = root.latestPingedTime;
-  0 !== latestPingedTime &&
-    latestPingedTime >= suspendedTime &&
-    (root.latestPingedTime = 0);
-  latestPingedTime = root.earliestPendingTime;
-  var latestPendingTime = root.latestPendingTime;
-  latestPingedTime === suspendedTime
+  root.latestPingedTime >= suspendedTime && (root.latestPingedTime = 0);
+  var earliestPendingTime = root.earliestPendingTime,
+    latestPendingTime = root.latestPendingTime;
+  earliestPendingTime === suspendedTime
     ? (root.earliestPendingTime =
         latestPendingTime === suspendedTime
           ? (root.latestPendingTime = 0)
           : latestPendingTime)
     : latestPendingTime === suspendedTime &&
-      (root.latestPendingTime = latestPingedTime);
-  latestPingedTime = root.earliestSuspendedTime;
+      (root.latestPendingTime = earliestPendingTime);
+  earliestPendingTime = root.earliestSuspendedTime;
   latestPendingTime = root.latestSuspendedTime;
-  0 === latestPingedTime
+  0 === earliestPendingTime
     ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
-    : latestPingedTime < suspendedTime
+    : earliestPendingTime < suspendedTime
       ? (root.earliestSuspendedTime = suspendedTime)
       : latestPendingTime > suspendedTime &&
         (root.latestSuspendedTime = suspendedTime);
@@ -2236,93 +2233,10 @@ function createCapturedValue(value, source) {
     stack: getStackByFiberInDevAndProd(source)
   };
 }
-var valueCursor = { current: null },
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastContextWithAllBitsObserved = null;
-function pushProvider(providerFiber, nextValue) {
-  var context = providerFiber.type._context;
-  push(valueCursor, context._currentValue2, providerFiber);
-  context._currentValue2 = nextValue;
-}
-function popProvider(providerFiber) {
-  var currentValue = valueCursor.current;
-  pop(valueCursor, providerFiber);
-  providerFiber.type._context._currentValue2 = currentValue;
-}
-function prepareToReadContext(workInProgress) {
-  currentlyRenderingFiber = workInProgress;
-  lastContextWithAllBitsObserved = lastContextDependency = null;
-  workInProgress.firstContextDependency = null;
-}
-function readContext(context, observedBits) {
-  if (
-    lastContextWithAllBitsObserved !== context &&
-    !1 !== observedBits &&
-    0 !== observedBits
-  ) {
-    if ("number" !== typeof observedBits || 1073741823 === observedBits)
-      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
-    observedBits = { context: context, observedBits: observedBits, next: null };
-    null === lastContextDependency
-      ? (invariant(
-          null !== currentlyRenderingFiber,
-          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
-        ),
-        (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
-      : (lastContextDependency = lastContextDependency.next = observedBits);
-  }
-  return context._currentValue2;
-}
-var NO_CONTEXT = {},
-  contextStackCursor$1 = { current: NO_CONTEXT },
-  contextFiberStackCursor = { current: NO_CONTEXT },
-  rootInstanceStackCursor = { current: NO_CONTEXT };
-function requiredContext(c) {
-  invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
-  );
-  return c;
-}
-function pushHostContainer(fiber, nextRootInstance) {
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
-}
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
-}
-function pushHostContext(fiber) {
-  requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = fiber.type;
-  nextContext =
-    "AndroidTextInput" === nextContext ||
-    "RCTMultilineTextInputView" === nextContext ||
-    "RCTSinglelineTextInputView" === nextContext ||
-    "RCTText" === nextContext ||
-    "RCTVirtualText" === nextContext;
-  nextContext =
-    context.isInAParentText !== nextContext
-      ? { isInAParentText: nextContext }
-      : context;
-  context !== nextContext &&
-    (push(contextFiberStackCursor, fiber, fiber),
-    push(contextStackCursor$1, nextContext, fiber));
-}
-function popHostContext(fiber) {
-  contextFiberStackCursor.current === fiber &&
-    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty;
 function is(x, y) {
-  return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
+  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (is(objA, objB)) return !0;
   if (
@@ -2363,9 +2277,9 @@ function readLazyComponentType(lazyComponent) {
     case 0:
       throw result;
     default:
-      throw ((lazyComponent._status = 0),
-      (result = lazyComponent._ctor),
-      (result = result()),
+      lazyComponent._status = 0;
+      result = lazyComponent._ctor;
+      result = result();
       result.then(
         function(moduleObject) {
           0 === lazyComponent._status &&
@@ -2377,13 +2291,18 @@ function readLazyComponentType(lazyComponent) {
           0 === lazyComponent._status &&
             ((lazyComponent._status = 2), (lazyComponent._result = error));
         }
-      ),
-      (lazyComponent._result = result),
-      result);
+      );
+      switch (lazyComponent._status) {
+        case 1:
+          return lazyComponent._result;
+        case 2:
+          throw lazyComponent._result;
+      }
+      lazyComponent._result = result;
+      throw result;
   }
 }
-var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
-  emptyRefsObject = new React.Component().refs;
+var emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2464,7 +2383,7 @@ function constructClassInstance(workInProgress, ctor, props) {
     unmaskedContext = emptyContextObject;
   var context = ctor.contextType;
   "object" === typeof context && null !== context
-    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    ? (context = readContext(context))
     : ((unmaskedContext = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2511,9 +2430,7 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
-        contextType
-      ))
+    ? (instance.context = readContext(contextType))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2568,7 +2485,10 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(1 === element.tag, "Function components cannot have refs."),
+        (invariant(
+          1 === element.tag,
+          "Function components cannot have refs. Did you mean to use React.forwardRef()?"
+        ),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -3268,7 +3188,367 @@ function ChildReconciler(shouldTrackSideEffects) {
 }
 var reconcileChildFibers = ChildReconciler(!0),
   mountChildFibers = ChildReconciler(!1),
-  hydrationParentFiber = null,
+  NO_CONTEXT = {},
+  contextStackCursor$1 = { current: NO_CONTEXT },
+  contextFiberStackCursor = { current: NO_CONTEXT },
+  rootInstanceStackCursor = { current: NO_CONTEXT };
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
+  );
+  return c;
+}
+function pushHostContainer(fiber, nextRootInstance) {
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
+}
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+function pushHostContext(fiber) {
+  requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = fiber.type;
+  nextContext =
+    "AndroidTextInput" === nextContext ||
+    "RCTMultilineTextInputView" === nextContext ||
+    "RCTSinglelineTextInputView" === nextContext ||
+    "RCTText" === nextContext ||
+    "RCTVirtualText" === nextContext;
+  nextContext =
+    context.isInAParentText !== nextContext
+      ? { isInAParentText: nextContext }
+      : context;
+  context !== nextContext &&
+    (push(contextFiberStackCursor, fiber, fiber),
+    push(contextStackCursor$1, nextContext, fiber));
+}
+function popHostContext(fiber) {
+  contextFiberStackCursor.current === fiber &&
+    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
+}
+var NoEffect$1 = 0,
+  UnmountSnapshot = 2,
+  UnmountMutation = 4,
+  MountMutation = 8,
+  UnmountLayout = 16,
+  MountLayout = 32,
+  MountPassive = 64,
+  UnmountPassive = 128,
+  renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = -1;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (null === prevDeps) return !1;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+    if (!is(nextDeps[i], prevDeps[i])) return !1;
+  return !0;
+}
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  refOrContext,
+  nextRenderExpirationTime
+) {
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current ? current.memoizedState : null;
+  do
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (current = Component(props, refOrContext));
+  while (didScheduleRenderPhaseUpdate);
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return current;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.baseState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (0 < numberOfReRenders) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do {
+            var _action = firstRenderPhaseUpdate.action;
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            initialAction = reducer(initialAction, _action);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+            firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
+          } while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    initialAction = workInProgressHook.baseState;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      _action = firstRenderPhaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      _baseUpdate = initialState;
+      var didSkip = !1;
+      do {
+        var updateExpirationTime = _baseUpdate.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (_action = prevUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : _baseUpdate.eagerReducer === reducer
+            ? (initialAction = _baseUpdate.eagerState)
+            : ((prevUpdate = _baseUpdate.action),
+              (currentlyRenderingFiber$1 = null),
+              stashContextDependencies(),
+              (initialAction = reducer(initialAction, prevUpdate)),
+              (currentlyRenderingFiber$1 = fiber),
+              unstashContextDependencies());
+        prevUpdate = _baseUpdate;
+        _baseUpdate = _baseUpdate.next;
+      } while (null !== _baseUpdate && _baseUpdate !== initialState);
+      didSkip ||
+        ((_action = prevUpdate), (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = _action;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+      initialAction !== currentHook.memoizedState && (didReceiveUpdate = !0);
+      queue.eagerReducer = reducer;
+      queue.eagerState = initialAction;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null,
+    eagerReducer: reducer,
+    eagerState: initialState
+  };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, deps) {
+  tag = { tag: tag, create: create, destroy: destroy, deps: deps, next: null };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useLayoutEffect(create, deps) {
+  useEffectImpl(4, UnmountMutation | MountLayout, create, deps);
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
+      pushEffect(NoEffect$1, create, destroy, deps);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    deps
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (action = renderPhaseUpdates.get(queue)),
+      void 0 === action)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = action; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    flushPassiveEffects();
+    var currentTime = requestCurrentTime();
+    currentTime = computeExpirationForFiber(currentTime, fiber);
+    var _update2 = {
+        expirationTime: currentTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      },
+      _last2 = queue.last;
+    if (null === _last2) _update2.next = _update2;
+    else {
+      var first = _last2.next;
+      null !== first && (_update2.next = first);
+      _last2.next = _update2;
+    }
+    queue.last = _update2;
+    if (
+      0 === fiber.expirationTime &&
+      (null === alternate || 0 === alternate.expirationTime) &&
+      ((alternate = queue.eagerReducer), null !== alternate)
+    )
+      try {
+        var currentState = queue.eagerState;
+        queue = currentlyRenderingFiber$1;
+        currentlyRenderingFiber$1 = null;
+        stashContextDependencies();
+        var _eagerState = alternate(currentState, action);
+        currentlyRenderingFiber$1 = queue;
+        unstashContextDependencies();
+        _update2.eagerReducer = alternate;
+        _update2.eagerState = _eagerState;
+        if (_eagerState === currentState) return;
+      } catch (error) {}
+    scheduleWork(fiber, currentTime);
+  }
+}
+var hydrationParentFiber = null,
   nextHydratableInstance = null,
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
@@ -3320,7 +3600,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
+var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner,
+  didReceiveUpdate = !1;
 function reconcileChildren(
   current$$1,
   workInProgress,
@@ -3352,7 +3633,26 @@ function updateForwardRef(
   Component = Component.render;
   var ref = workInProgress.ref;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  nextProps = Component(nextProps, ref);
+  nextProps = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    ref,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3432,9 +3732,9 @@ function updateSimpleMemoComponent(
   renderExpirationTime
 ) {
   return null !== current$$1 &&
-    updateExpirationTime < renderExpirationTime &&
     shallowEqual(current$$1.memoizedProps, nextProps) &&
-    current$$1.ref === workInProgress.ref
+    current$$1.ref === workInProgress.ref &&
+    ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
     ? bailoutOnAlreadyFinishedWork(
         current$$1,
         workInProgress,
@@ -3468,7 +3768,26 @@ function updateFunctionComponent(
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
   prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  Component = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    unmaskedContext,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3515,9 +3834,7 @@ function updateClassComponent(
     var oldContext = instance.context,
       contextType = Component.contextType;
     "object" === typeof contextType && null !== contextType
-      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-          contextType
-        ))
+      ? (contextType = readContext(contextType))
       : ((contextType = isContextProvider(Component)
           ? previousContext
           : contextStackCursor.current),
@@ -3602,9 +3919,7 @@ function updateClassComponent(
       (oldContext = instance.context),
       (contextType = Component.contextType),
       "object" === typeof contextType && null !== contextType
-        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-            contextType
-          ))
+        ? (contextType = readContext(contextType))
         : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
@@ -3785,33 +4100,35 @@ function updateSuspenseComponent(
     (nextState = { timedOutAt: null !== nextState ? nextState.timedOutAt : 0 }),
       (nextDidTimeout = !0),
       (workInProgress.effectTag &= -65);
-  null === current$$1
-    ? nextDidTimeout
-      ? ((nextDidTimeout = nextProps.fallback),
-        (nextProps = createFiberFromFragment(null, mode, 0, null)),
-        0 === (workInProgress.mode & 1) &&
-          (nextProps.child =
-            null !== workInProgress.memoizedState
-              ? workInProgress.child.child
-              : workInProgress.child),
-        (mode = createFiberFromFragment(
-          nextDidTimeout,
-          mode,
-          renderExpirationTime,
-          null
-        )),
-        (nextProps.sibling = mode),
-        (renderExpirationTime = nextProps),
-        (renderExpirationTime.return = mode.return = workInProgress))
-      : (renderExpirationTime = mode = mountChildFibers(
-          workInProgress,
-          null,
-          nextProps.children,
-          renderExpirationTime
-        ))
-    : null !== current$$1.memoizedState
+  if (null === current$$1)
+    if (nextDidTimeout) {
+      var nextFallbackChildren = nextProps.fallback;
+      current$$1 = createFiberFromFragment(null, mode, 0, null);
+      0 === (workInProgress.mode & 1) &&
+        (current$$1.child =
+          null !== workInProgress.memoizedState
+            ? workInProgress.child.child
+            : workInProgress.child);
+      mode = createFiberFromFragment(
+        nextFallbackChildren,
+        mode,
+        renderExpirationTime,
+        null
+      );
+      current$$1.sibling = mode;
+      renderExpirationTime = current$$1;
+      renderExpirationTime.return = mode.return = workInProgress;
+    } else
+      renderExpirationTime = mode = mountChildFibers(
+        workInProgress,
+        null,
+        nextProps.children,
+        renderExpirationTime
+      );
+  else
+    null !== current$$1.memoizedState
       ? ((mode = current$$1.child),
-        (current$$1 = mode.sibling),
+        (nextFallbackChildren = mode.sibling),
         nextDidTimeout
           ? ((renderExpirationTime = nextProps.fallback),
             (nextProps = createWorkInProgress(mode, mode.pendingProps, 0)),
@@ -3823,9 +4140,9 @@ function updateSuspenseComponent(
               nextDidTimeout !== mode.child &&
                 (nextProps.child = nextDidTimeout)),
             (mode = nextProps.sibling = createWorkInProgress(
-              current$$1,
+              nextFallbackChildren,
               renderExpirationTime,
-              current$$1.expirationTime
+              nextFallbackChildren.expirationTime
             )),
             (renderExpirationTime = nextProps),
             (nextProps.childExpirationTime = 0),
@@ -3836,11 +4153,11 @@ function updateSuspenseComponent(
               nextProps.children,
               renderExpirationTime
             )))
-      : ((current$$1 = current$$1.child),
+      : ((nextFallbackChildren = current$$1.child),
         nextDidTimeout
           ? ((nextDidTimeout = nextProps.fallback),
             (nextProps = createFiberFromFragment(null, mode, 0, null)),
-            (nextProps.child = current$$1),
+            (nextProps.child = nextFallbackChildren),
             0 === (workInProgress.mode & 1) &&
               (nextProps.child =
                 null !== workInProgress.memoizedState
@@ -3858,10 +4175,11 @@ function updateSuspenseComponent(
             (renderExpirationTime.return = mode.return = workInProgress))
           : (mode = renderExpirationTime = reconcileChildFibers(
               workInProgress,
-              current$$1,
+              nextFallbackChildren,
               nextProps.children,
               renderExpirationTime
-            )));
+            ))),
+      (workInProgress.stateNode = current$$1.stateNode);
   workInProgress.memoizedState = nextState;
   workInProgress.child = renderExpirationTime;
   return mode;
@@ -3872,7 +4190,7 @@ function bailoutOnAlreadyFinishedWork(
   renderExpirationTime
 ) {
   null !== current$$1 &&
-    (workInProgress.firstContextDependency = current$$1.firstContextDependency);
+    (workInProgress.contextDependencies = current$$1.contextDependencies);
   if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
     null === current$$1 || workInProgress.child === current$$1.child,
@@ -3904,58 +4222,63 @@ function bailoutOnAlreadyFinishedWork(
 }
 function beginWork(current$$1, workInProgress, renderExpirationTime) {
   var updateExpirationTime = workInProgress.expirationTime;
-  if (
-    null !== current$$1 &&
-    current$$1.memoizedProps === workInProgress.pendingProps &&
-    !didPerformWorkStackCursor.current &&
-    updateExpirationTime < renderExpirationTime
-  ) {
-    switch (workInProgress.tag) {
-      case 3:
-        pushHostRootContext(workInProgress);
-        break;
-      case 5:
-        pushHostContext(workInProgress);
-        break;
-      case 1:
-        isContextProvider(workInProgress.type) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 4:
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        );
-        break;
-      case 10:
-        pushProvider(workInProgress, workInProgress.memoizedProps.value);
-        break;
-      case 13:
-        if (null !== workInProgress.memoizedState) {
-          updateExpirationTime = workInProgress.child.childExpirationTime;
-          if (
-            0 !== updateExpirationTime &&
-            updateExpirationTime >= renderExpirationTime
-          )
-            return updateSuspenseComponent(
-              current$$1,
+  if (null !== current$$1)
+    if (
+      current$$1.memoizedProps !== workInProgress.pendingProps ||
+      didPerformWorkStackCursor.current
+    )
+      didReceiveUpdate = !0;
+    else {
+      if (updateExpirationTime < renderExpirationTime) {
+        didReceiveUpdate = !1;
+        switch (workInProgress.tag) {
+          case 3:
+            pushHostRootContext(workInProgress);
+            break;
+          case 5:
+            pushHostContext(workInProgress);
+            break;
+          case 1:
+            isContextProvider(workInProgress.type) &&
+              pushContextProvider(workInProgress);
+            break;
+          case 4:
+            pushHostContainer(
               workInProgress,
-              renderExpirationTime
+              workInProgress.stateNode.containerInfo
             );
-          workInProgress = bailoutOnAlreadyFinishedWork(
-            current$$1,
-            workInProgress,
-            renderExpirationTime
-          );
-          return null !== workInProgress ? workInProgress.sibling : null;
+            break;
+          case 10:
+            pushProvider(workInProgress, workInProgress.memoizedProps.value);
+            break;
+          case 13:
+            if (null !== workInProgress.memoizedState) {
+              updateExpirationTime = workInProgress.child.childExpirationTime;
+              if (
+                0 !== updateExpirationTime &&
+                updateExpirationTime >= renderExpirationTime
+              )
+                return updateSuspenseComponent(
+                  current$$1,
+                  workInProgress,
+                  renderExpirationTime
+                );
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+              return null !== workInProgress ? workInProgress.sibling : null;
+            }
         }
+        return bailoutOnAlreadyFinishedWork(
+          current$$1,
+          workInProgress,
+          renderExpirationTime
+        );
+      }
     }
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  }
+  else didReceiveUpdate = !1;
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
     case 2:
@@ -3970,7 +4293,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         contextStackCursor.current
       );
       prepareToReadContext(workInProgress, renderExpirationTime);
-      context = updateExpirationTime(current$$1, context);
+      context = renderWithHooks(
+        null,
+        workInProgress,
+        updateExpirationTime,
+        current$$1,
+        context,
+        renderExpirationTime
+      );
       workInProgress.effectTag |= 1;
       if (
         "object" === typeof context &&
@@ -3979,6 +4309,7 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         void 0 === context.$$typeof
       ) {
         workInProgress.tag = 1;
+        resetHooks();
         if (isContextProvider(updateExpirationTime)) {
           var hasContext = !0;
           pushContextProvider(workInProgress);
@@ -4250,18 +4581,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         pushProvider(workInProgress, hasContext);
         if (null !== getDerivedStateFromProps) {
           var oldValue = getDerivedStateFromProps.value;
-          hasContext =
-            (oldValue === hasContext &&
-              (0 !== oldValue || 1 / oldValue === 1 / hasContext)) ||
-            (oldValue !== oldValue && hasContext !== hasContext)
-              ? 0
-              : ("function" ===
-                typeof updateExpirationTime._calculateChangedBits
-                  ? updateExpirationTime._calculateChangedBits(
-                      oldValue,
-                      hasContext
-                    )
-                  : 1073741823) | 0;
+          hasContext = is(oldValue, hasContext)
+            ? 0
+            : ("function" === typeof updateExpirationTime._calculateChangedBits
+                ? updateExpirationTime._calculateChangedBits(
+                    oldValue,
+                    hasContext
+                  )
+                : 1073741823) | 0;
           if (0 === hasContext) {
             if (
               getDerivedStateFromProps.children === context.children &&
@@ -4276,83 +4603,79 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
             }
           } else
             for (
-              getDerivedStateFromProps = workInProgress.child,
-                null !== getDerivedStateFromProps &&
-                  (getDerivedStateFromProps.return = workInProgress);
-              null !== getDerivedStateFromProps;
+              oldValue = workInProgress.child,
+                null !== oldValue && (oldValue.return = workInProgress);
+              null !== oldValue;
 
             ) {
-              oldValue = getDerivedStateFromProps.firstContextDependency;
-              if (null !== oldValue) {
-                do {
+              var list = oldValue.contextDependencies;
+              if (null !== list) {
+                getDerivedStateFromProps = oldValue.child;
+                for (var dependency = list.first; null !== dependency; ) {
                   if (
-                    oldValue.context === updateExpirationTime &&
-                    0 !== (oldValue.observedBits & hasContext)
+                    dependency.context === updateExpirationTime &&
+                    0 !== (dependency.observedBits & hasContext)
                   ) {
-                    if (1 === getDerivedStateFromProps.tag) {
-                      var nextFiber = createUpdate(renderExpirationTime);
-                      nextFiber.tag = 2;
-                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
-                    }
-                    getDerivedStateFromProps.expirationTime <
-                      renderExpirationTime &&
-                      (getDerivedStateFromProps.expirationTime = renderExpirationTime);
-                    nextFiber = getDerivedStateFromProps.alternate;
-                    null !== nextFiber &&
-                      nextFiber.expirationTime < renderExpirationTime &&
-                      (nextFiber.expirationTime = renderExpirationTime);
-                    for (
-                      var node = getDerivedStateFromProps.return;
-                      null !== node;
-
-                    ) {
-                      nextFiber = node.alternate;
+                    1 === oldValue.tag &&
+                      ((dependency = createUpdate(renderExpirationTime)),
+                      (dependency.tag = 2),
+                      enqueueUpdate(oldValue, dependency));
+                    oldValue.expirationTime < renderExpirationTime &&
+                      (oldValue.expirationTime = renderExpirationTime);
+                    dependency = oldValue.alternate;
+                    null !== dependency &&
+                      dependency.expirationTime < renderExpirationTime &&
+                      (dependency.expirationTime = renderExpirationTime);
+                    for (var node = oldValue.return; null !== node; ) {
+                      dependency = node.alternate;
                       if (node.childExpirationTime < renderExpirationTime)
                         (node.childExpirationTime = renderExpirationTime),
-                          null !== nextFiber &&
-                            nextFiber.childExpirationTime <
+                          null !== dependency &&
+                            dependency.childExpirationTime <
                               renderExpirationTime &&
-                            (nextFiber.childExpirationTime = renderExpirationTime);
+                            (dependency.childExpirationTime = renderExpirationTime);
                       else if (
-                        null !== nextFiber &&
-                        nextFiber.childExpirationTime < renderExpirationTime
+                        null !== dependency &&
+                        dependency.childExpirationTime < renderExpirationTime
                       )
-                        nextFiber.childExpirationTime = renderExpirationTime;
+                        dependency.childExpirationTime = renderExpirationTime;
                       else break;
                       node = node.return;
                     }
+                    list.expirationTime < renderExpirationTime &&
+                      (list.expirationTime = renderExpirationTime);
+                    break;
                   }
-                  nextFiber = getDerivedStateFromProps.child;
-                  oldValue = oldValue.next;
-                } while (null !== oldValue);
+                  dependency = dependency.next;
+                }
               } else
-                nextFiber =
-                  10 === getDerivedStateFromProps.tag
-                    ? getDerivedStateFromProps.type === workInProgress.type
+                getDerivedStateFromProps =
+                  10 === oldValue.tag
+                    ? oldValue.type === workInProgress.type
                       ? null
-                      : getDerivedStateFromProps.child
-                    : getDerivedStateFromProps.child;
-              if (null !== nextFiber)
-                nextFiber.return = getDerivedStateFromProps;
+                      : oldValue.child
+                    : oldValue.child;
+              if (null !== getDerivedStateFromProps)
+                getDerivedStateFromProps.return = oldValue;
               else
                 for (
-                  nextFiber = getDerivedStateFromProps;
-                  null !== nextFiber;
+                  getDerivedStateFromProps = oldValue;
+                  null !== getDerivedStateFromProps;
 
                 ) {
-                  if (nextFiber === workInProgress) {
-                    nextFiber = null;
+                  if (getDerivedStateFromProps === workInProgress) {
+                    getDerivedStateFromProps = null;
                     break;
                   }
-                  getDerivedStateFromProps = nextFiber.sibling;
-                  if (null !== getDerivedStateFromProps) {
-                    getDerivedStateFromProps.return = nextFiber.return;
-                    nextFiber = getDerivedStateFromProps;
+                  oldValue = getDerivedStateFromProps.sibling;
+                  if (null !== oldValue) {
+                    oldValue.return = getDerivedStateFromProps.return;
+                    getDerivedStateFromProps = oldValue;
                     break;
                   }
-                  nextFiber = nextFiber.return;
+                  getDerivedStateFromProps = getDerivedStateFromProps.return;
                 }
-              getDerivedStateFromProps = nextFiber;
+              oldValue = getDerivedStateFromProps;
             }
         }
         reconcileChildren(
@@ -4452,6 +4775,69 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
+var valueCursor = { current: null },
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastContextWithAllBitsObserved = null,
+  stashedCurrentlyRenderingFiber = null,
+  stashedLastContextDependency = null,
+  stashedLastContextWithAllBitsObserved = null;
+function resetContextDependences() {
+  stashedLastContextWithAllBitsObserved = stashedLastContextDependency = stashedCurrentlyRenderingFiber = lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function stashContextDependencies() {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function unstashContextDependencies() {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+}
+function pushProvider(providerFiber, nextValue) {
+  var context = providerFiber.type._context;
+  push(valueCursor, context._currentValue2, providerFiber);
+  context._currentValue2 = nextValue;
+}
+function popProvider(providerFiber) {
+  var currentValue = valueCursor.current;
+  pop(valueCursor, providerFiber);
+  providerFiber.type._context._currentValue2 = currentValue;
+}
+function prepareToReadContext(workInProgress, renderExpirationTime) {
+  currentlyRenderingFiber = workInProgress;
+  lastContextWithAllBitsObserved = lastContextDependency = null;
+  var currentDependencies = workInProgress.contextDependencies;
+  null !== currentDependencies &&
+    currentDependencies.expirationTime >= renderExpirationTime &&
+    (didReceiveUpdate = !0);
+  workInProgress.contextDependencies = null;
+}
+function readContext(context, observedBits) {
+  if (
+    lastContextWithAllBitsObserved !== context &&
+    !1 !== observedBits &&
+    0 !== observedBits
+  ) {
+    if ("number" !== typeof observedBits || 1073741823 === observedBits)
+      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
+    observedBits = { context: context, observedBits: observedBits, next: null };
+    null === lastContextDependency
+      ? (invariant(
+          null !== currentlyRenderingFiber,
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        ),
+        (lastContextDependency = observedBits),
+        (currentlyRenderingFiber.contextDependencies = {
+          first: observedBits,
+          expirationTime: 0
+        }))
+      : (lastContextDependency = lastContextDependency.next = observedBits);
+  }
+  return context._currentValue2;
+}
 var appendAllChildren = void 0,
   updateHostContainer = void 0,
   updateHostComponent$1 = void 0,
@@ -4695,12 +5081,33 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & unmountTag) !== NoEffect$1) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      (effect.tag & mountTag) !== NoEffect$1 &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
 function commitWork(current$$1, finishedWork) {
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 14:
     case 15:
+      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
       return;
   }
   switch (finishedWork.tag) {
@@ -4720,6 +5127,7 @@ function commitWork(current$$1, finishedWork) {
       );
   }
 }
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
   expirationTime = createUpdate(expirationTime);
   expirationTime.tag = 3;
@@ -4797,7 +5205,87 @@ function unwindWork(workInProgress) {
       return null;
   }
 }
-var DispatcherWithoutHooks = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, deps) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, deps];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, deps) {
+      useEffectImpl(516, UnmountPassive | MountPassive, create, deps);
+    },
+    useImperativeHandle: function(ref, create, deps) {
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : [ref];
+      useLayoutEffect(function() {
+        if ("function" === typeof ref) {
+          var _inst = create();
+          ref(_inst);
+          return function() {
+            return ref(null);
+          };
+        }
+        if (null !== ref && void 0 !== ref)
+          return (
+            (_inst = create()),
+            (ref.current = _inst),
+            function() {
+              ref.current = null;
+            }
+          );
+      }, deps);
+    },
+    useDebugValue: function() {
+      resolveCurrentlyRenderingFiber();
+    },
+    useLayoutEffect: useLayoutEffect,
+    useMemo: function(nextCreate, deps) {
+      var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      currentlyRenderingFiber$1 = null;
+      stashContextDependencies();
+      nextCreate = nextCreate();
+      currentlyRenderingFiber$1 = fiber;
+      unstashContextDependencies();
+      workInProgressHook.memoizedState = [nextCreate, deps];
+      return nextCreate;
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
   isWorking = !1,
   nextUnitOfWork = null,
@@ -4807,6 +5295,7 @@ var DispatcherWithoutHooks = { readContext: readContext },
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
   passiveEffectCallbackHandle = null,
   passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
@@ -4847,6 +5336,29 @@ function resetStack() {
   nextRenderDidError = !1;
   nextUnitOfWork = null;
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
+        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
 function flushPassiveEffects() {
   null !== passiveEffectCallback &&
     (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
@@ -4989,11 +5501,7 @@ function completeUnitOfWork(workInProgress) {
                   : ((current$$1.firstEffect = current$$1.lastEffect = current),
                     (current.nextEffect = null)),
                 (current.effectTag = 8)));
-            if (
-              instance !== renderExpirationTime ||
-              (0 === (current$$1.effectTag & 1) && instance)
-            )
-              current$$1.effectTag |= 4;
+            if (instance || renderExpirationTime) current$$1.effectTag |= 4;
             break;
           case 7:
             break;
@@ -5084,7 +5592,7 @@ function renderRoot(root$jscomp$0, isYieldy) {
   );
   flushPassiveEffects();
   isWorking = !0;
-  ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
+  ReactCurrentDispatcher.current = Dispatcher;
   var expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn;
   if (
     expirationTime !== nextRenderExpirationTime ||
@@ -5110,10 +5618,7 @@ function renderRoot(root$jscomp$0, isYieldy) {
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (
-        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
-        null === nextUnitOfWork)
-      )
+      if ((resetContextDependences(), resetHooks(), null === nextUnitOfWork))
         (didFatal = !0), onUncaughtError(thrownValue);
       else {
         invariant(
@@ -5171,23 +5676,47 @@ function renderRoot(root$jscomp$0, isYieldy) {
                       ? !1
                       : null === value.memoizedState;
                 if (current$$1) {
-                  returnFiber$jscomp$0 = retrySuspendedRoot.bind(
-                    null,
-                    root,
-                    value,
-                    sourceFiber$jscomp$0,
-                    0 === (value.mode & 1) ? 1073741823 : returnFiber
-                  );
-                  thenable.then(returnFiber$jscomp$0, returnFiber$jscomp$0);
+                  returnFiber$jscomp$0 = value.updateQueue;
+                  null === returnFiber$jscomp$0
+                    ? ((returnFiber$jscomp$0 = new Set()),
+                      returnFiber$jscomp$0.add(thenable),
+                      (value.updateQueue = returnFiber$jscomp$0))
+                    : returnFiber$jscomp$0.add(thenable);
                   if (0 === (value.mode & 1)) {
                     value.effectTag |= 64;
                     sourceFiber$jscomp$0.effectTag &= -1957;
                     1 === sourceFiber$jscomp$0.tag &&
-                      null === sourceFiber$jscomp$0.alternate &&
-                      (sourceFiber$jscomp$0.tag = 17);
-                    sourceFiber$jscomp$0.expirationTime = returnFiber;
+                      (null === sourceFiber$jscomp$0.alternate
+                        ? (sourceFiber$jscomp$0.tag = 17)
+                        : ((returnFiber = createUpdate(1073741823)),
+                          (returnFiber.tag = 2),
+                          enqueueUpdate(sourceFiber$jscomp$0, returnFiber)));
+                    sourceFiber$jscomp$0.expirationTime = 1073741823;
                     break a;
                   }
+                  sourceFiber$jscomp$0 = root.pingCache;
+                  null === sourceFiber$jscomp$0
+                    ? ((sourceFiber$jscomp$0 = root.pingCache = new PossiblyWeakMap()),
+                      (returnFiber$jscomp$0 = new Set()),
+                      sourceFiber$jscomp$0.set(thenable, returnFiber$jscomp$0))
+                    : ((returnFiber$jscomp$0 = sourceFiber$jscomp$0.get(
+                        thenable
+                      )),
+                      void 0 === returnFiber$jscomp$0 &&
+                        ((returnFiber$jscomp$0 = new Set()),
+                        sourceFiber$jscomp$0.set(
+                          thenable,
+                          returnFiber$jscomp$0
+                        )));
+                  returnFiber$jscomp$0.has(returnFiber) ||
+                    (returnFiber$jscomp$0.add(returnFiber),
+                    (sourceFiber$jscomp$0 = pingSuspendedRoot.bind(
+                      null,
+                      root,
+                      thenable,
+                      returnFiber
+                    )),
+                    thenable.then(sourceFiber$jscomp$0, sourceFiber$jscomp$0));
                   -1 === earliestTimeoutMs
                     ? (root = 1073741823)
                     : (-1 === startTimeMs &&
@@ -5222,36 +5751,31 @@ function renderRoot(root$jscomp$0, isYieldy) {
             do {
               switch (root.tag) {
                 case 3:
-                  sourceFiber$jscomp$0 = value;
                   root.effectTag |= 2048;
                   root.expirationTime = returnFiber;
-                  returnFiber = createRootErrorUpdate(
-                    root,
-                    sourceFiber$jscomp$0,
-                    returnFiber
-                  );
+                  returnFiber = createRootErrorUpdate(root, value, returnFiber);
                   enqueueCapturedUpdate(root, returnFiber);
                   break a;
                 case 1:
                   if (
-                    ((sourceFiber$jscomp$0 = value),
-                    (returnFiber$jscomp$0 = root.type),
-                    (thenable = root.stateNode),
+                    ((thenable = value),
+                    (earliestTimeoutMs = root.type),
+                    (startTimeMs = root.stateNode),
                     0 === (root.effectTag & 64) &&
                       ("function" ===
-                        typeof returnFiber$jscomp$0.getDerivedStateFromError ||
-                        (null !== thenable &&
-                          "function" === typeof thenable.componentDidCatch &&
+                        typeof earliestTimeoutMs.getDerivedStateFromError ||
+                        (null !== startTimeMs &&
+                          "function" === typeof startTimeMs.componentDidCatch &&
                           (null === legacyErrorBoundariesThatAlreadyFailed ||
                             !legacyErrorBoundariesThatAlreadyFailed.has(
-                              thenable
+                              startTimeMs
                             )))))
                   ) {
                     root.effectTag |= 2048;
                     root.expirationTime = returnFiber;
                     returnFiber = createClassErrorUpdate(
                       root,
-                      sourceFiber$jscomp$0,
+                      thenable,
                       returnFiber
                     );
                     enqueueCapturedUpdate(root, returnFiber);
@@ -5269,7 +5793,9 @@ function renderRoot(root$jscomp$0, isYieldy) {
     break;
   } while (1);
   isWorking = !1;
-  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
+  ReactCurrentDispatcher.current = null;
+  resetContextDependences();
+  resetHooks();
   if (didFatal) (nextRoot = null), (root$jscomp$0.finishedWork = null);
   else if (null !== nextUnitOfWork) root$jscomp$0.finishedWork = null;
   else {
@@ -5381,40 +5907,25 @@ function computeExpirationForFiber(currentTime, fiber) {
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
-function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
-  var retryTime = root.earliestSuspendedTime;
-  var latestSuspendedTime = root.latestSuspendedTime;
-  if (
-    0 !== retryTime &&
-    suspendedTime <= retryTime &&
-    suspendedTime >= latestSuspendedTime
+function pingSuspendedRoot(root, thenable, pingTime) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(thenable);
+  if (null !== nextRoot && nextRenderExpirationTime === pingTime)
+    nextRoot = null;
+  else if (
+    ((thenable = root.earliestSuspendedTime),
+    (pingCache = root.latestSuspendedTime),
+    0 !== thenable && pingTime <= thenable && pingTime >= pingCache)
   ) {
-    latestSuspendedTime = retryTime = suspendedTime;
     root.didError = !1;
-    var latestPingedTime = root.latestPingedTime;
-    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
-      root.latestPingedTime = latestSuspendedTime;
-    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
-  } else
-    (retryTime = requestCurrentTime()),
-      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
-      markPendingPriorityLevel(root, retryTime);
-  0 !== (boundaryFiber.mode & 1) &&
-    root === nextRoot &&
-    nextRenderExpirationTime === suspendedTime &&
-    (nextRoot = null);
-  scheduleWorkToRoot(boundaryFiber, retryTime);
-  0 === (boundaryFiber.mode & 1) &&
-    (scheduleWorkToRoot(sourceFiber, retryTime),
-    1 === sourceFiber.tag &&
-      null !== sourceFiber.stateNode &&
-      ((boundaryFiber = createUpdate(retryTime)),
-      (boundaryFiber.tag = 2),
-      enqueueUpdate(sourceFiber, boundaryFiber)));
-  sourceFiber = root.expirationTime;
-  0 !== sourceFiber && requestWork(root, sourceFiber);
-}
-function scheduleWorkToRoot(fiber, expirationTime) {
+    thenable = root.latestPingedTime;
+    if (0 === thenable || thenable > pingTime) root.latestPingedTime = pingTime;
+    findNextExpirationTimeToWorkOn(pingTime, root);
+    pingTime = root.expirationTime;
+    0 !== pingTime && requestWork(root, pingTime);
+  }
+}
+function scheduleWork(fiber, expirationTime) {
   fiber.expirationTime < expirationTime &&
     (fiber.expirationTime = expirationTime);
   var alternate = fiber.alternate;
@@ -5438,10 +5949,7 @@ function scheduleWorkToRoot(fiber, expirationTime) {
       }
       node = node.return;
     }
-  return root;
-}
-function scheduleWork(fiber, expirationTime) {
-  fiber = scheduleWorkToRoot(fiber, expirationTime);
+  fiber = root;
   null !== fiber &&
     (!isWorking &&
       0 !== nextRenderExpirationTime &&
@@ -5755,7 +6263,8 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
       (root.earliestSuspendedTime = 0),
       (root.latestSuspendedTime = 0),
       (root.latestPingedTime = 0))
-    : ((childExpirationTimeBeforeCommit = root.latestPendingTime),
+    : (firstBatch < root.latestPingedTime && (root.latestPingedTime = 0),
+      (childExpirationTimeBeforeCommit = root.latestPendingTime),
       0 !== childExpirationTimeBeforeCommit &&
         (childExpirationTimeBeforeCommit > firstBatch
           ? (root.earliestPendingTime = root.latestPendingTime = 0)
@@ -5792,6 +6301,7 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
               case 0:
               case 11:
               case 15:
+                commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
                 break a;
               case 1:
                 if (finishedWork.effectTag & 256 && null !== current$$1) {
@@ -5962,28 +6472,33 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
     effectTag = !1;
     current$$1$jscomp$0 = void 0;
     try {
-      for (currentRef = expirationTime; null !== nextEffect; ) {
+      for (
+        currentRef = root, updateQueue = expirationTime;
+        null !== nextEffect;
+
+      ) {
         var effectTag$jscomp$0 = nextEffect.effectTag;
         if (effectTag$jscomp$0 & 36) {
           var current$$1$jscomp$1 = nextEffect.alternate;
-          updateQueue = nextEffect;
-          lastEffect = currentRef;
-          switch (updateQueue.tag) {
+          lastEffect = nextEffect;
+          firstEffect = updateQueue;
+          switch (lastEffect.tag) {
             case 0:
             case 11:
             case 15:
+              commitHookEffectList(UnmountLayout, MountLayout, lastEffect);
               break;
             case 1:
-              var instance$jscomp$1 = updateQueue.stateNode;
-              if (updateQueue.effectTag & 4)
+              var instance$jscomp$1 = lastEffect.stateNode;
+              if (lastEffect.effectTag & 4)
                 if (null === current$$1$jscomp$1)
                   instance$jscomp$1.componentDidMount();
                 else {
                   var prevProps$jscomp$0 =
-                    updateQueue.elementType === updateQueue.type
+                    lastEffect.elementType === lastEffect.type
                       ? current$$1$jscomp$1.memoizedProps
                       : resolveDefaultProps(
-                          updateQueue.type,
+                          lastEffect.type,
                           current$$1$jscomp$1.memoizedProps
                         );
                   instance$jscomp$1.componentDidUpdate(
@@ -5992,38 +6507,38 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
                     instance$jscomp$1.__reactInternalSnapshotBeforeUpdate
                   );
                 }
-              var updateQueue$jscomp$0 = updateQueue.updateQueue;
+              var updateQueue$jscomp$0 = lastEffect.updateQueue;
               null !== updateQueue$jscomp$0 &&
                 commitUpdateQueue(
-                  updateQueue,
+                  lastEffect,
                   updateQueue$jscomp$0,
                   instance$jscomp$1,
-                  lastEffect
+                  firstEffect
                 );
               break;
             case 3:
-              var _updateQueue = updateQueue.updateQueue;
+              var _updateQueue = lastEffect.updateQueue;
               if (null !== _updateQueue) {
-                firstEffect = null;
-                if (null !== updateQueue.child)
-                  switch (updateQueue.child.tag) {
+                destroy = null;
+                if (null !== lastEffect.child)
+                  switch (lastEffect.child.tag) {
                     case 5:
-                      firstEffect = updateQueue.child.stateNode.canonical;
+                      destroy = lastEffect.child.stateNode.canonical;
                       break;
                     case 1:
-                      firstEffect = updateQueue.child.stateNode;
+                      destroy = lastEffect.child.stateNode;
                   }
                 commitUpdateQueue(
-                  updateQueue,
+                  lastEffect,
                   _updateQueue,
-                  firstEffect,
-                  lastEffect
+                  destroy,
+                  firstEffect
                 );
               }
               break;
             case 5:
               null === current$$1$jscomp$1 &&
-                updateQueue.effectTag & 4 &&
+                lastEffect.effectTag & 4 &&
                 invariant(
                   !1,
                   "The current renderer does not support mutation. This error is likely caused by a bug in React. Please file an issue."
@@ -6062,6 +6577,8 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
               : (ref.current = instanceToUse);
           }
         }
+        effectTag$jscomp$0 & 512 &&
+          (rootWithPendingPassiveEffects = currentRef);
         nextEffect = nextEffect.nextEffect;
       }
     } catch (e) {
@@ -6075,6 +6592,13 @@ function completeRoot$1(root, finishedWork$jscomp$0, expirationTime) {
       captureCommitPhaseError(nextEffect, current$$1$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== firstBatch &&
+    null !== rootWithPendingPassiveEffects &&
+    ((effectTag$jscomp$0 = commitPassiveEffects.bind(null, root, firstBatch)),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      effectTag$jscomp$0
+    )),
+    (passiveEffectCallback = effectTag$jscomp$0));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork$jscomp$0.stateNode);
@@ -6316,6 +6840,7 @@ var roots = new Map(),
           current: root,
           containerInfo: containerTag,
           pendingChildren: null,
+          pingCache: null,
           earliestPendingTime: 0,
           latestPendingTime: 0,
           earliestSuspendedTime: 0,
@@ -6421,6 +6946,8 @@ var roots = new Map(),
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
   return injectInternals(
     Object.assign({}, devToolsConfig, {
+      overrideProps: null,
+      currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
       findHostInstanceByFiber: function(fiber) {
         fiber = findCurrentHostFiber(fiber);
         return null === fiber ? null : fiber.stateNode;
@@ -6436,7 +6963,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromInstance,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.6.1",
+  version: "16.7.0",
   rendererPackageName: "react-native-renderer"
 });
 var ReactFabric$2 = { default: ReactFabric },
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-profiling.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactFabric-profiling.js
@@ -1779,7 +1779,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
-  this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
+  this.contextDependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
   this.mode = mode;
   this.effectTag = 0;
   this.lastEffect = this.firstEffect = this.nextEffect = null;
@@ -1833,7 +1833,7 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.firstContextDependency = current.firstContextDependency;
+  workInProgress.contextDependencies = current.contextDependencies;
   workInProgress.sibling = current.sibling;
   workInProgress.index = current.index;
   workInProgress.ref = current.ref;
@@ -1968,6 +1968,8 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
       (root.latestSuspendedTime = 0),
       (root.latestPingedTime = 0);
   else {
+    earliestRemainingTime < root.latestPingedTime &&
+      (root.latestPingedTime = 0);
     var latestPendingTime = root.latestPendingTime;
     0 !== latestPendingTime &&
       (latestPendingTime > earliestRemainingTime
@@ -2000,24 +2002,21 @@ function hasLowerPriorityWork(root, erroredExpirationTime) {
 }
 function markSuspendedPriorityLevel(root, suspendedTime) {
   root.didError = !1;
-  var latestPingedTime = root.latestPingedTime;
-  0 !== latestPingedTime &&
-    latestPingedTime >= suspendedTime &&
-    (root.latestPingedTime = 0);
-  latestPingedTime = root.earliestPendingTime;
-  var latestPendingTime = root.latestPendingTime;
-  latestPingedTime === suspendedTime
+  root.latestPingedTime >= suspendedTime && (root.latestPingedTime = 0);
+  var earliestPendingTime = root.earliestPendingTime,
+    latestPendingTime = root.latestPendingTime;
+  earliestPendingTime === suspendedTime
     ? (root.earliestPendingTime =
         latestPendingTime === suspendedTime
           ? (root.latestPendingTime = 0)
           : latestPendingTime)
     : latestPendingTime === suspendedTime &&
-      (root.latestPendingTime = latestPingedTime);
-  latestPingedTime = root.earliestSuspendedTime;
+      (root.latestPendingTime = earliestPendingTime);
+  earliestPendingTime = root.earliestSuspendedTime;
   latestPendingTime = root.latestSuspendedTime;
-  0 === latestPingedTime
+  0 === earliestPendingTime
     ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
-    : latestPingedTime < suspendedTime
+    : earliestPendingTime < suspendedTime
       ? (root.earliestSuspendedTime = suspendedTime)
       : latestPendingTime > suspendedTime &&
         (root.latestSuspendedTime = suspendedTime);
@@ -2284,103 +2283,10 @@ function createCapturedValue(value, source) {
     stack: getStackByFiberInDevAndProd(source)
   };
 }
-var valueCursor = { current: null },
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastContextWithAllBitsObserved = null;
-function pushProvider(providerFiber, nextValue) {
-  var context = providerFiber.type._context;
-  push(valueCursor, context._currentValue2, providerFiber);
-  context._currentValue2 = nextValue;
-}
-function popProvider(providerFiber) {
-  var currentValue = valueCursor.current;
-  pop(valueCursor, providerFiber);
-  providerFiber.type._context._currentValue2 = currentValue;
-}
-function prepareToReadContext(workInProgress) {
-  currentlyRenderingFiber = workInProgress;
-  lastContextWithAllBitsObserved = lastContextDependency = null;
-  workInProgress.firstContextDependency = null;
-}
-function readContext(context, observedBits) {
-  if (
-    lastContextWithAllBitsObserved !== context &&
-    !1 !== observedBits &&
-    0 !== observedBits
-  ) {
-    if ("number" !== typeof observedBits || 1073741823 === observedBits)
-      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
-    observedBits = { context: context, observedBits: observedBits, next: null };
-    null === lastContextDependency
-      ? (invariant(
-          null !== currentlyRenderingFiber,
-          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
-        ),
-        (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
-      : (lastContextDependency = lastContextDependency.next = observedBits);
-  }
-  return context._currentValue2;
-}
-var NO_CONTEXT = {},
-  contextStackCursor$1 = { current: NO_CONTEXT },
-  contextFiberStackCursor = { current: NO_CONTEXT },
-  rootInstanceStackCursor = { current: NO_CONTEXT };
-function requiredContext(c) {
-  invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
-  );
-  return c;
-}
-function pushHostContainer(fiber, nextRootInstance) {
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
-}
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
-}
-function pushHostContext(fiber) {
-  requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = fiber.type;
-  nextContext =
-    "AndroidTextInput" === nextContext ||
-    "RCTMultilineTextInputView" === nextContext ||
-    "RCTSinglelineTextInputView" === nextContext ||
-    "RCTText" === nextContext ||
-    "RCTVirtualText" === nextContext;
-  nextContext =
-    context.isInAParentText !== nextContext
-      ? { isInAParentText: nextContext }
-      : context;
-  context !== nextContext &&
-    (push(contextFiberStackCursor, fiber, fiber),
-    push(contextStackCursor$1, nextContext, fiber));
-}
-function popHostContext(fiber) {
-  contextFiberStackCursor.current === fiber &&
-    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
-}
-var commitTime = 0,
-  profilerStartTime = -1;
-function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
-  if (0 <= profilerStartTime) {
-    var elapsedTime = now$1() - profilerStartTime;
-    fiber.actualDuration += elapsedTime;
-    overrideBaseTime && (fiber.selfBaseDuration = elapsedTime);
-    profilerStartTime = -1;
-  }
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty;
 function is(x, y) {
-  return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
+  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (is(objA, objB)) return !0;
   if (
@@ -2421,9 +2327,9 @@ function readLazyComponentType(lazyComponent) {
     case 0:
       throw result;
     default:
-      throw ((lazyComponent._status = 0),
-      (result = lazyComponent._ctor),
-      (result = result()),
+      lazyComponent._status = 0;
+      result = lazyComponent._ctor;
+      result = result();
       result.then(
         function(moduleObject) {
           0 === lazyComponent._status &&
@@ -2435,13 +2341,18 @@ function readLazyComponentType(lazyComponent) {
           0 === lazyComponent._status &&
             ((lazyComponent._status = 2), (lazyComponent._result = error));
         }
-      ),
-      (lazyComponent._result = result),
-      result);
+      );
+      switch (lazyComponent._status) {
+        case 1:
+          return lazyComponent._result;
+        case 2:
+          throw lazyComponent._result;
+      }
+      lazyComponent._result = result;
+      throw result;
   }
 }
-var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
-  emptyRefsObject = new React.Component().refs;
+var emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2522,7 +2433,7 @@ function constructClassInstance(workInProgress, ctor, props) {
     unmaskedContext = emptyContextObject;
   var context = ctor.contextType;
   "object" === typeof context && null !== context
-    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    ? (context = readContext(context))
     : ((unmaskedContext = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2569,9 +2480,7 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
-        contextType
-      ))
+    ? (instance.context = readContext(contextType))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2626,7 +2535,10 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(1 === element.tag, "Function components cannot have refs."),
+        (invariant(
+          1 === element.tag,
+          "Function components cannot have refs. Did you mean to use React.forwardRef()?"
+        ),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -3326,7 +3238,377 @@ function ChildReconciler(shouldTrackSideEffects) {
 }
 var reconcileChildFibers = ChildReconciler(!0),
   mountChildFibers = ChildReconciler(!1),
-  hydrationParentFiber = null,
+  NO_CONTEXT = {},
+  contextStackCursor$1 = { current: NO_CONTEXT },
+  contextFiberStackCursor = { current: NO_CONTEXT },
+  rootInstanceStackCursor = { current: NO_CONTEXT };
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
+  );
+  return c;
+}
+function pushHostContainer(fiber, nextRootInstance) {
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
+}
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+function pushHostContext(fiber) {
+  requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = fiber.type;
+  nextContext =
+    "AndroidTextInput" === nextContext ||
+    "RCTMultilineTextInputView" === nextContext ||
+    "RCTSinglelineTextInputView" === nextContext ||
+    "RCTText" === nextContext ||
+    "RCTVirtualText" === nextContext;
+  nextContext =
+    context.isInAParentText !== nextContext
+      ? { isInAParentText: nextContext }
+      : context;
+  context !== nextContext &&
+    (push(contextFiberStackCursor, fiber, fiber),
+    push(contextStackCursor$1, nextContext, fiber));
+}
+function popHostContext(fiber) {
+  contextFiberStackCursor.current === fiber &&
+    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
+}
+var NoEffect$1 = 0,
+  UnmountSnapshot = 2,
+  UnmountMutation = 4,
+  MountMutation = 8,
+  UnmountLayout = 16,
+  MountLayout = 32,
+  MountPassive = 64,
+  UnmountPassive = 128,
+  renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = -1;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (null === prevDeps) return !1;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+    if (!is(nextDeps[i], prevDeps[i])) return !1;
+  return !0;
+}
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  refOrContext,
+  nextRenderExpirationTime
+) {
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current ? current.memoizedState : null;
+  do
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (current = Component(props, refOrContext));
+  while (didScheduleRenderPhaseUpdate);
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return current;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.baseState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (0 < numberOfReRenders) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do {
+            var _action = firstRenderPhaseUpdate.action;
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            initialAction = reducer(initialAction, _action);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+            firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
+          } while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    initialAction = workInProgressHook.baseState;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      _action = firstRenderPhaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      _baseUpdate = initialState;
+      var didSkip = !1;
+      do {
+        var updateExpirationTime = _baseUpdate.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (_action = prevUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : _baseUpdate.eagerReducer === reducer
+            ? (initialAction = _baseUpdate.eagerState)
+            : ((prevUpdate = _baseUpdate.action),
+              (currentlyRenderingFiber$1 = null),
+              stashContextDependencies(),
+              (initialAction = reducer(initialAction, prevUpdate)),
+              (currentlyRenderingFiber$1 = fiber),
+              unstashContextDependencies());
+        prevUpdate = _baseUpdate;
+        _baseUpdate = _baseUpdate.next;
+      } while (null !== _baseUpdate && _baseUpdate !== initialState);
+      didSkip ||
+        ((_action = prevUpdate), (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = _action;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+      initialAction !== currentHook.memoizedState && (didReceiveUpdate = !0);
+      queue.eagerReducer = reducer;
+      queue.eagerState = initialAction;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null,
+    eagerReducer: reducer,
+    eagerState: initialState
+  };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, deps) {
+  tag = { tag: tag, create: create, destroy: destroy, deps: deps, next: null };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useLayoutEffect(create, deps) {
+  useEffectImpl(4, UnmountMutation | MountLayout, create, deps);
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
+      pushEffect(NoEffect$1, create, destroy, deps);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    deps
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (action = renderPhaseUpdates.get(queue)),
+      void 0 === action)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = action; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    flushPassiveEffects();
+    var currentTime = requestCurrentTime();
+    currentTime = computeExpirationForFiber(currentTime, fiber);
+    var _update2 = {
+        expirationTime: currentTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      },
+      _last2 = queue.last;
+    if (null === _last2) _update2.next = _update2;
+    else {
+      var first = _last2.next;
+      null !== first && (_update2.next = first);
+      _last2.next = _update2;
+    }
+    queue.last = _update2;
+    if (
+      0 === fiber.expirationTime &&
+      (null === alternate || 0 === alternate.expirationTime) &&
+      ((alternate = queue.eagerReducer), null !== alternate)
+    )
+      try {
+        var currentState = queue.eagerState;
+        queue = currentlyRenderingFiber$1;
+        currentlyRenderingFiber$1 = null;
+        stashContextDependencies();
+        var _eagerState = alternate(currentState, action);
+        currentlyRenderingFiber$1 = queue;
+        unstashContextDependencies();
+        _update2.eagerReducer = alternate;
+        _update2.eagerState = _eagerState;
+        if (_eagerState === currentState) return;
+      } catch (error) {}
+    scheduleWork(fiber, currentTime);
+  }
+}
+var commitTime = 0,
+  profilerStartTime = -1;
+function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
+  if (0 <= profilerStartTime) {
+    var elapsedTime = now$1() - profilerStartTime;
+    fiber.actualDuration += elapsedTime;
+    overrideBaseTime && (fiber.selfBaseDuration = elapsedTime);
+    profilerStartTime = -1;
+  }
+}
+var hydrationParentFiber = null,
   nextHydratableInstance = null,
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
@@ -3378,7 +3660,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
+var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner,
+  didReceiveUpdate = !1;
 function reconcileChildren(
   current$$1,
   workInProgress,
@@ -3410,7 +3693,26 @@ function updateForwardRef(
   Component = Component.render;
   var ref = workInProgress.ref;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  nextProps = Component(nextProps, ref);
+  nextProps = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    ref,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3490,9 +3792,9 @@ function updateSimpleMemoComponent(
   renderExpirationTime
 ) {
   return null !== current$$1 &&
-    updateExpirationTime < renderExpirationTime &&
     shallowEqual(current$$1.memoizedProps, nextProps) &&
-    current$$1.ref === workInProgress.ref
+    current$$1.ref === workInProgress.ref &&
+    ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
     ? bailoutOnAlreadyFinishedWork(
         current$$1,
         workInProgress,
@@ -3526,7 +3828,26 @@ function updateFunctionComponent(
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
   prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  Component = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    unmaskedContext,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3573,9 +3894,7 @@ function updateClassComponent(
     var oldContext = instance.context,
       contextType = Component.contextType;
     "object" === typeof contextType && null !== contextType
-      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-          contextType
-        ))
+      ? (contextType = readContext(contextType))
       : ((contextType = isContextProvider(Component)
           ? previousContext
           : contextStackCursor.current),
@@ -3660,9 +3979,7 @@ function updateClassComponent(
       (oldContext = instance.context),
       (contextType = Component.contextType),
       "object" === typeof contextType && null !== contextType
-        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-            contextType
-          ))
+        ? (contextType = readContext(contextType))
         : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
@@ -3848,104 +4165,119 @@ function updateSuspenseComponent(
       (nextDidTimeout = !0),
       (workInProgress.effectTag &= -65);
   if (null === current$$1)
-    nextDidTimeout
-      ? ((nextDidTimeout = nextProps.fallback),
-        (nextProps = createFiberFromFragment(null, mode, 0, null)),
-        0 === (workInProgress.mode & 1) &&
-          (nextProps.child =
-            null !== workInProgress.memoizedState
-              ? workInProgress.child.child
-              : workInProgress.child),
-        (renderExpirationTime = createFiberFromFragment(
-          nextDidTimeout,
-          mode,
-          renderExpirationTime,
-          null
-        )),
-        (nextProps.sibling = renderExpirationTime),
-        (mode = nextProps),
-        (mode.return = renderExpirationTime.return = workInProgress))
-      : (mode = renderExpirationTime = mountChildFibers(
-          workInProgress,
-          null,
-          nextProps.children,
-          renderExpirationTime
-        ));
-  else if (null !== current$$1.memoizedState)
-    if (
-      ((current$$1 = current$$1.child),
-      (mode = current$$1.sibling),
-      nextDidTimeout)
-    ) {
-      nextProps = nextProps.fallback;
-      renderExpirationTime = createWorkInProgress(
-        current$$1,
-        current$$1.pendingProps,
-        0
-      );
+    if (nextDidTimeout) {
+      var nextFallbackChildren = nextProps.fallback;
+      current$$1 = createFiberFromFragment(null, mode, 0, null);
       0 === (workInProgress.mode & 1) &&
-        ((nextDidTimeout =
+        (current$$1.child =
           null !== workInProgress.memoizedState
             ? workInProgress.child.child
-            : workInProgress.child),
-        nextDidTimeout !== current$$1.child &&
-          (renderExpirationTime.child = nextDidTimeout));
-      if (workInProgress.mode & 4) {
-        nextDidTimeout = 0;
-        for (current$$1 = renderExpirationTime.child; null !== current$$1; )
-          (nextDidTimeout += current$$1.treeBaseDuration),
-            (current$$1 = current$$1.sibling);
-        renderExpirationTime.treeBaseDuration = nextDidTimeout;
-      }
-      nextProps = renderExpirationTime.sibling = createWorkInProgress(
+            : workInProgress.child);
+      renderExpirationTime = createFiberFromFragment(
+        nextFallbackChildren,
         mode,
-        nextProps,
-        mode.expirationTime
+        renderExpirationTime,
+        null
       );
-      mode = renderExpirationTime;
-      renderExpirationTime.childExpirationTime = 0;
-      renderExpirationTime = nextProps;
+      current$$1.sibling = renderExpirationTime;
+      mode = current$$1;
       mode.return = renderExpirationTime.return = workInProgress;
     } else
-      mode = renderExpirationTime = reconcileChildFibers(
+      mode = renderExpirationTime = mountChildFibers(
         workInProgress,
-        current$$1.child,
+        null,
         nextProps.children,
         renderExpirationTime
       );
-  else if (((current$$1 = current$$1.child), nextDidTimeout)) {
-    nextDidTimeout = nextProps.fallback;
-    nextProps = createFiberFromFragment(null, mode, 0, null);
-    nextProps.child = current$$1;
-    0 === (workInProgress.mode & 1) &&
-      (nextProps.child =
-        null !== workInProgress.memoizedState
-          ? workInProgress.child.child
-          : workInProgress.child);
-    if (workInProgress.mode & 4) {
-      current$$1 = 0;
-      for (var _hiddenChild = nextProps.child; null !== _hiddenChild; )
-        (current$$1 += _hiddenChild.treeBaseDuration),
-          (_hiddenChild = _hiddenChild.sibling);
-      nextProps.treeBaseDuration = current$$1;
+  else {
+    if (null !== current$$1.memoizedState)
+      if (
+        ((nextFallbackChildren = current$$1.child),
+        (mode = nextFallbackChildren.sibling),
+        nextDidTimeout)
+      ) {
+        nextProps = nextProps.fallback;
+        renderExpirationTime = createWorkInProgress(
+          nextFallbackChildren,
+          nextFallbackChildren.pendingProps,
+          0
+        );
+        0 === (workInProgress.mode & 1) &&
+          ((nextDidTimeout =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child),
+          nextDidTimeout !== nextFallbackChildren.child &&
+            (renderExpirationTime.child = nextDidTimeout));
+        if (workInProgress.mode & 4) {
+          nextFallbackChildren = 0;
+          for (
+            nextDidTimeout = renderExpirationTime.child;
+            null !== nextDidTimeout;
+
+          )
+            (nextFallbackChildren += nextDidTimeout.treeBaseDuration),
+              (nextDidTimeout = nextDidTimeout.sibling);
+          renderExpirationTime.treeBaseDuration = nextFallbackChildren;
+        }
+        nextFallbackChildren = renderExpirationTime.sibling = createWorkInProgress(
+          mode,
+          nextProps,
+          mode.expirationTime
+        );
+        mode = renderExpirationTime;
+        renderExpirationTime.childExpirationTime = 0;
+        renderExpirationTime = nextFallbackChildren;
+        mode.return = renderExpirationTime.return = workInProgress;
+      } else
+        mode = renderExpirationTime = reconcileChildFibers(
+          workInProgress,
+          nextFallbackChildren.child,
+          nextProps.children,
+          renderExpirationTime
+        );
+    else {
+      var _currentPrimaryChild = current$$1.child;
+      if (nextDidTimeout) {
+        nextProps = nextProps.fallback;
+        nextFallbackChildren = createFiberFromFragment(null, mode, 0, null);
+        nextFallbackChildren.child = _currentPrimaryChild;
+        0 === (workInProgress.mode & 1) &&
+          (nextFallbackChildren.child =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child);
+        if (workInProgress.mode & 4) {
+          nextDidTimeout = 0;
+          for (
+            _currentPrimaryChild = nextFallbackChildren.child;
+            null !== _currentPrimaryChild;
+
+          )
+            (nextDidTimeout += _currentPrimaryChild.treeBaseDuration),
+              (_currentPrimaryChild = _currentPrimaryChild.sibling);
+          nextFallbackChildren.treeBaseDuration = nextDidTimeout;
+        }
+        renderExpirationTime = nextFallbackChildren.sibling = createFiberFromFragment(
+          nextProps,
+          mode,
+          renderExpirationTime,
+          null
+        );
+        renderExpirationTime.effectTag |= 2;
+        mode = nextFallbackChildren;
+        nextFallbackChildren.childExpirationTime = 0;
+        mode.return = renderExpirationTime.return = workInProgress;
+      } else
+        renderExpirationTime = mode = reconcileChildFibers(
+          workInProgress,
+          _currentPrimaryChild,
+          nextProps.children,
+          renderExpirationTime
+        );
     }
-    renderExpirationTime = nextProps.sibling = createFiberFromFragment(
-      nextDidTimeout,
-      mode,
-      renderExpirationTime,
-      null
-    );
-    renderExpirationTime.effectTag |= 2;
-    mode = nextProps;
-    nextProps.childExpirationTime = 0;
-    mode.return = renderExpirationTime.return = workInProgress;
-  } else
-    renderExpirationTime = mode = reconcileChildFibers(
-      workInProgress,
-      current$$1,
-      nextProps.children,
-      renderExpirationTime
-    );
+    workInProgress.stateNode = current$$1.stateNode;
+  }
   workInProgress.memoizedState = nextState;
   workInProgress.child = mode;
   return renderExpirationTime;
@@ -3956,7 +4288,7 @@ function bailoutOnAlreadyFinishedWork(
   renderExpirationTime
 ) {
   null !== current$$1 &&
-    (workInProgress.firstContextDependency = current$$1.firstContextDependency);
+    (workInProgress.contextDependencies = current$$1.contextDependencies);
   profilerStartTime = -1;
   if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
@@ -3989,61 +4321,66 @@ function bailoutOnAlreadyFinishedWork(
 }
 function beginWork(current$$1, workInProgress, renderExpirationTime) {
   var updateExpirationTime = workInProgress.expirationTime;
-  if (
-    null !== current$$1 &&
-    current$$1.memoizedProps === workInProgress.pendingProps &&
-    !didPerformWorkStackCursor.current &&
-    updateExpirationTime < renderExpirationTime
-  ) {
-    switch (workInProgress.tag) {
-      case 3:
-        pushHostRootContext(workInProgress);
-        break;
-      case 5:
-        pushHostContext(workInProgress);
-        break;
-      case 1:
-        isContextProvider(workInProgress.type) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 4:
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        );
-        break;
-      case 10:
-        pushProvider(workInProgress, workInProgress.memoizedProps.value);
-        break;
-      case 12:
-        workInProgress.effectTag |= 4;
-        break;
-      case 13:
-        if (null !== workInProgress.memoizedState) {
-          updateExpirationTime = workInProgress.child.childExpirationTime;
-          if (
-            0 !== updateExpirationTime &&
-            updateExpirationTime >= renderExpirationTime
-          )
-            return updateSuspenseComponent(
-              current$$1,
+  if (null !== current$$1)
+    if (
+      current$$1.memoizedProps !== workInProgress.pendingProps ||
+      didPerformWorkStackCursor.current
+    )
+      didReceiveUpdate = !0;
+    else {
+      if (updateExpirationTime < renderExpirationTime) {
+        didReceiveUpdate = !1;
+        switch (workInProgress.tag) {
+          case 3:
+            pushHostRootContext(workInProgress);
+            break;
+          case 5:
+            pushHostContext(workInProgress);
+            break;
+          case 1:
+            isContextProvider(workInProgress.type) &&
+              pushContextProvider(workInProgress);
+            break;
+          case 4:
+            pushHostContainer(
               workInProgress,
-              renderExpirationTime
+              workInProgress.stateNode.containerInfo
             );
-          workInProgress = bailoutOnAlreadyFinishedWork(
-            current$$1,
-            workInProgress,
-            renderExpirationTime
-          );
-          return null !== workInProgress ? workInProgress.sibling : null;
+            break;
+          case 10:
+            pushProvider(workInProgress, workInProgress.memoizedProps.value);
+            break;
+          case 12:
+            workInProgress.effectTag |= 4;
+            break;
+          case 13:
+            if (null !== workInProgress.memoizedState) {
+              updateExpirationTime = workInProgress.child.childExpirationTime;
+              if (
+                0 !== updateExpirationTime &&
+                updateExpirationTime >= renderExpirationTime
+              )
+                return updateSuspenseComponent(
+                  current$$1,
+                  workInProgress,
+                  renderExpirationTime
+                );
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+              return null !== workInProgress ? workInProgress.sibling : null;
+            }
         }
+        return bailoutOnAlreadyFinishedWork(
+          current$$1,
+          workInProgress,
+          renderExpirationTime
+        );
+      }
     }
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  }
+  else didReceiveUpdate = !1;
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
     case 2:
@@ -4058,7 +4395,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         contextStackCursor.current
       );
       prepareToReadContext(workInProgress, renderExpirationTime);
-      context = updateExpirationTime(current$$1, context);
+      context = renderWithHooks(
+        null,
+        workInProgress,
+        updateExpirationTime,
+        current$$1,
+        context,
+        renderExpirationTime
+      );
       workInProgress.effectTag |= 1;
       if (
         "object" === typeof context &&
@@ -4067,6 +4411,7 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         void 0 === context.$$typeof
       ) {
         workInProgress.tag = 1;
+        resetHooks();
         if (isContextProvider(updateExpirationTime)) {
           var hasContext = !0;
           pushContextProvider(workInProgress);
@@ -4339,18 +4684,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         pushProvider(workInProgress, hasContext);
         if (null !== getDerivedStateFromProps) {
           var oldValue = getDerivedStateFromProps.value;
-          hasContext =
-            (oldValue === hasContext &&
-              (0 !== oldValue || 1 / oldValue === 1 / hasContext)) ||
-            (oldValue !== oldValue && hasContext !== hasContext)
-              ? 0
-              : ("function" ===
-                typeof updateExpirationTime._calculateChangedBits
-                  ? updateExpirationTime._calculateChangedBits(
-                      oldValue,
-                      hasContext
-                    )
-                  : 1073741823) | 0;
+          hasContext = is(oldValue, hasContext)
+            ? 0
+            : ("function" === typeof updateExpirationTime._calculateChangedBits
+                ? updateExpirationTime._calculateChangedBits(
+                    oldValue,
+                    hasContext
+                  )
+                : 1073741823) | 0;
           if (0 === hasContext) {
             if (
               getDerivedStateFromProps.children === context.children &&
@@ -4365,83 +4706,79 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
             }
           } else
             for (
-              getDerivedStateFromProps = workInProgress.child,
-                null !== getDerivedStateFromProps &&
-                  (getDerivedStateFromProps.return = workInProgress);
-              null !== getDerivedStateFromProps;
+              oldValue = workInProgress.child,
+                null !== oldValue && (oldValue.return = workInProgress);
+              null !== oldValue;
 
             ) {
-              oldValue = getDerivedStateFromProps.firstContextDependency;
-              if (null !== oldValue) {
-                do {
+              var list = oldValue.contextDependencies;
+              if (null !== list) {
+                getDerivedStateFromProps = oldValue.child;
+                for (var dependency = list.first; null !== dependency; ) {
                   if (
-                    oldValue.context === updateExpirationTime &&
-                    0 !== (oldValue.observedBits & hasContext)
+                    dependency.context === updateExpirationTime &&
+                    0 !== (dependency.observedBits & hasContext)
                   ) {
-                    if (1 === getDerivedStateFromProps.tag) {
-                      var nextFiber = createUpdate(renderExpirationTime);
-                      nextFiber.tag = 2;
-                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
-                    }
-                    getDerivedStateFromProps.expirationTime <
-                      renderExpirationTime &&
-                      (getDerivedStateFromProps.expirationTime = renderExpirationTime);
-                    nextFiber = getDerivedStateFromProps.alternate;
-                    null !== nextFiber &&
-                      nextFiber.expirationTime < renderExpirationTime &&
-                      (nextFiber.expirationTime = renderExpirationTime);
-                    for (
-                      var node = getDerivedStateFromProps.return;
-                      null !== node;
-
-                    ) {
-                      nextFiber = node.alternate;
+                    1 === oldValue.tag &&
+                      ((dependency = createUpdate(renderExpirationTime)),
+                      (dependency.tag = 2),
+                      enqueueUpdate(oldValue, dependency));
+                    oldValue.expirationTime < renderExpirationTime &&
+                      (oldValue.expirationTime = renderExpirationTime);
+                    dependency = oldValue.alternate;
+                    null !== dependency &&
+                      dependency.expirationTime < renderExpirationTime &&
+                      (dependency.expirationTime = renderExpirationTime);
+                    for (var node = oldValue.return; null !== node; ) {
+                      dependency = node.alternate;
                       if (node.childExpirationTime < renderExpirationTime)
                         (node.childExpirationTime = renderExpirationTime),
-                          null !== nextFiber &&
-                            nextFiber.childExpirationTime <
+                          null !== dependency &&
+                            dependency.childExpirationTime <
                               renderExpirationTime &&
-                            (nextFiber.childExpirationTime = renderExpirationTime);
+                            (dependency.childExpirationTime = renderExpirationTime);
                       else if (
-                        null !== nextFiber &&
-                        nextFiber.childExpirationTime < renderExpirationTime
+                        null !== dependency &&
+                        dependency.childExpirationTime < renderExpirationTime
                       )
-                        nextFiber.childExpirationTime = renderExpirationTime;
+                        dependency.childExpirationTime = renderExpirationTime;
                       else break;
                       node = node.return;
                     }
+                    list.expirationTime < renderExpirationTime &&
+                      (list.expirationTime = renderExpirationTime);
+                    break;
                   }
-                  nextFiber = getDerivedStateFromProps.child;
-                  oldValue = oldValue.next;
-                } while (null !== oldValue);
+                  dependency = dependency.next;
+                }
               } else
-                nextFiber =
-                  10 === getDerivedStateFromProps.tag
-                    ? getDerivedStateFromProps.type === workInProgress.type
+                getDerivedStateFromProps =
+                  10 === oldValue.tag
+                    ? oldValue.type === workInProgress.type
                       ? null
-                      : getDerivedStateFromProps.child
-                    : getDerivedStateFromProps.child;
-              if (null !== nextFiber)
-                nextFiber.return = getDerivedStateFromProps;
+                      : oldValue.child
+                    : oldValue.child;
+              if (null !== getDerivedStateFromProps)
+                getDerivedStateFromProps.return = oldValue;
               else
                 for (
-                  nextFiber = getDerivedStateFromProps;
-                  null !== nextFiber;
+                  getDerivedStateFromProps = oldValue;
+                  null !== getDerivedStateFromProps;
 
                 ) {
-                  if (nextFiber === workInProgress) {
-                    nextFiber = null;
+                  if (getDerivedStateFromProps === workInProgress) {
+                    getDerivedStateFromProps = null;
                     break;
                   }
-                  getDerivedStateFromProps = nextFiber.sibling;
-                  if (null !== getDerivedStateFromProps) {
-                    getDerivedStateFromProps.return = nextFiber.return;
-                    nextFiber = getDerivedStateFromProps;
+                  oldValue = getDerivedStateFromProps.sibling;
+                  if (null !== oldValue) {
+                    oldValue.return = getDerivedStateFromProps.return;
+                    getDerivedStateFromProps = oldValue;
                     break;
                   }
-                  nextFiber = nextFiber.return;
+                  getDerivedStateFromProps = getDerivedStateFromProps.return;
                 }
-              getDerivedStateFromProps = nextFiber;
+              oldValue = getDerivedStateFromProps;
             }
         }
         reconcileChildren(
@@ -4541,6 +4878,69 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
+var valueCursor = { current: null },
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastContextWithAllBitsObserved = null,
+  stashedCurrentlyRenderingFiber = null,
+  stashedLastContextDependency = null,
+  stashedLastContextWithAllBitsObserved = null;
+function resetContextDependences() {
+  stashedLastContextWithAllBitsObserved = stashedLastContextDependency = stashedCurrentlyRenderingFiber = lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function stashContextDependencies() {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function unstashContextDependencies() {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+}
+function pushProvider(providerFiber, nextValue) {
+  var context = providerFiber.type._context;
+  push(valueCursor, context._currentValue2, providerFiber);
+  context._currentValue2 = nextValue;
+}
+function popProvider(providerFiber) {
+  var currentValue = valueCursor.current;
+  pop(valueCursor, providerFiber);
+  providerFiber.type._context._currentValue2 = currentValue;
+}
+function prepareToReadContext(workInProgress, renderExpirationTime) {
+  currentlyRenderingFiber = workInProgress;
+  lastContextWithAllBitsObserved = lastContextDependency = null;
+  var currentDependencies = workInProgress.contextDependencies;
+  null !== currentDependencies &&
+    currentDependencies.expirationTime >= renderExpirationTime &&
+    (didReceiveUpdate = !0);
+  workInProgress.contextDependencies = null;
+}
+function readContext(context, observedBits) {
+  if (
+    lastContextWithAllBitsObserved !== context &&
+    !1 !== observedBits &&
+    0 !== observedBits
+  ) {
+    if ("number" !== typeof observedBits || 1073741823 === observedBits)
+      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
+    observedBits = { context: context, observedBits: observedBits, next: null };
+    null === lastContextDependency
+      ? (invariant(
+          null !== currentlyRenderingFiber,
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        ),
+        (lastContextDependency = observedBits),
+        (currentlyRenderingFiber.contextDependencies = {
+          first: observedBits,
+          expirationTime: 0
+        }))
+      : (lastContextDependency = lastContextDependency.next = observedBits);
+  }
+  return context._currentValue2;
+}
 var appendAllChildren = void 0,
   updateHostContainer = void 0,
   updateHostComponent$1 = void 0,
@@ -4784,12 +5184,33 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & unmountTag) !== NoEffect$1) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      (effect.tag & mountTag) !== NoEffect$1 &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
 function commitWork(current$$1, finishedWork) {
   switch (finishedWork.tag) {
     case 0:
     case 11:
     case 14:
     case 15:
+      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
       return;
   }
   switch (finishedWork.tag) {
@@ -4809,6 +5230,7 @@ function commitWork(current$$1, finishedWork) {
       );
   }
 }
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
   expirationTime = createUpdate(expirationTime);
   expirationTime.tag = 3;
@@ -4891,24 +5313,43 @@ function throwException(
             ? !1
             : null === value.memoizedState;
       if (current$$1) {
-        returnFiber = retrySuspendedRoot.bind(
-          null,
-          root,
-          value,
-          sourceFiber,
-          0 === (value.mode & 1) ? 1073741823 : renderExpirationTime
-        );
-        returnFiber = tracing.unstable_wrap(returnFiber);
-        thenable.then(returnFiber, returnFiber);
+        returnFiber = value.updateQueue;
+        null === returnFiber
+          ? ((returnFiber = new Set()),
+            returnFiber.add(thenable),
+            (value.updateQueue = returnFiber))
+          : returnFiber.add(thenable);
         if (0 === (value.mode & 1)) {
           value.effectTag |= 64;
           sourceFiber.effectTag &= -1957;
           1 === sourceFiber.tag &&
-            null === sourceFiber.alternate &&
-            (sourceFiber.tag = 17);
-          sourceFiber.expirationTime = renderExpirationTime;
+            (null === sourceFiber.alternate
+              ? (sourceFiber.tag = 17)
+              : ((renderExpirationTime = createUpdate(1073741823)),
+                (renderExpirationTime.tag = 2),
+                enqueueUpdate(sourceFiber, renderExpirationTime)));
+          sourceFiber.expirationTime = 1073741823;
           return;
         }
+        sourceFiber = root.pingCache;
+        null === sourceFiber
+          ? ((sourceFiber = root.pingCache = new PossiblyWeakMap()),
+            (returnFiber = new Set()),
+            sourceFiber.set(thenable, returnFiber))
+          : ((returnFiber = sourceFiber.get(thenable)),
+            void 0 === returnFiber &&
+              ((returnFiber = new Set()),
+              sourceFiber.set(thenable, returnFiber)));
+        returnFiber.has(renderExpirationTime) ||
+          (returnFiber.add(renderExpirationTime),
+          (sourceFiber = pingSuspendedRoot.bind(
+            null,
+            root,
+            thenable,
+            renderExpirationTime
+          )),
+          (sourceFiber = tracing.unstable_wrap(sourceFiber)),
+          thenable.then(sourceFiber, sourceFiber));
         -1 === earliestTimeoutMs
           ? (root = 1073741823)
           : (-1 === startTimeMs &&
@@ -4942,33 +5383,32 @@ function throwException(
   do {
     switch (root.tag) {
       case 3:
-        sourceFiber = value;
         root.effectTag |= 2048;
         root.expirationTime = renderExpirationTime;
         renderExpirationTime = createRootErrorUpdate(
           root,
-          sourceFiber,
+          value,
           renderExpirationTime
         );
         enqueueCapturedUpdate(root, renderExpirationTime);
         return;
       case 1:
         if (
-          ((sourceFiber = value),
-          (returnFiber = root.type),
-          (thenable = root.stateNode),
+          ((thenable = value),
+          (earliestTimeoutMs = root.type),
+          (startTimeMs = root.stateNode),
           0 === (root.effectTag & 64) &&
-            ("function" === typeof returnFiber.getDerivedStateFromError ||
-              (null !== thenable &&
-                "function" === typeof thenable.componentDidCatch &&
+            ("function" === typeof earliestTimeoutMs.getDerivedStateFromError ||
+              (null !== startTimeMs &&
+                "function" === typeof startTimeMs.componentDidCatch &&
                 (null === legacyErrorBoundariesThatAlreadyFailed ||
-                  !legacyErrorBoundariesThatAlreadyFailed.has(thenable)))))
+                  !legacyErrorBoundariesThatAlreadyFailed.has(startTimeMs)))))
         ) {
           root.effectTag |= 2048;
           root.expirationTime = renderExpirationTime;
           renderExpirationTime = createClassErrorUpdate(
             root,
-            sourceFiber,
+            thenable,
             renderExpirationTime
           );
           enqueueCapturedUpdate(root, renderExpirationTime);
@@ -5017,7 +5457,87 @@ function unwindWork(workInProgress) {
       return null;
   }
 }
-var DispatcherWithoutHooks = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, deps) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, deps];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, deps) {
+      useEffectImpl(516, UnmountPassive | MountPassive, create, deps);
+    },
+    useImperativeHandle: function(ref, create, deps) {
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : [ref];
+      useLayoutEffect(function() {
+        if ("function" === typeof ref) {
+          var _inst = create();
+          ref(_inst);
+          return function() {
+            return ref(null);
+          };
+        }
+        if (null !== ref && void 0 !== ref)
+          return (
+            (_inst = create()),
+            (ref.current = _inst),
+            function() {
+              ref.current = null;
+            }
+          );
+      }, deps);
+    },
+    useDebugValue: function() {
+      resolveCurrentlyRenderingFiber();
+    },
+    useLayoutEffect: useLayoutEffect,
+    useMemo: function(nextCreate, deps) {
+      var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      currentlyRenderingFiber$1 = null;
+      stashContextDependencies();
+      nextCreate = nextCreate();
+      currentlyRenderingFiber$1 = fiber;
+      unstashContextDependencies();
+      workInProgressHook.memoizedState = [nextCreate, deps];
+      return nextCreate;
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
 invariant(
   null != tracing.__interactionsRef &&
@@ -5032,6 +5552,7 @@ var isWorking = !1,
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
   passiveEffectCallbackHandle = null,
   passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
@@ -5182,6 +5703,7 @@ function commitBeforeMutationLifecycles() {
           case 0:
           case 11:
           case 15:
+            commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
             break a;
           case 1:
             if (finishedWork.effectTag & 256 && null !== current$$1) {
@@ -5228,6 +5750,7 @@ function commitAllLifeCycles(
         case 0:
         case 11:
         case 15:
+          commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
           break;
         case 1:
           finishedRoot = finishedWork.stateNode;
@@ -5311,19 +5834,46 @@ function commitAllLifeCycles(
           );
       }
     }
-    if (effectTag & 128 && ((effectTag = nextEffect.ref), null !== effectTag)) {
-      finishedWork = nextEffect.stateNode;
+    if (
+      effectTag & 128 &&
+      ((finishedWork = nextEffect.ref), null !== finishedWork)
+    ) {
+      committedExpirationTime = nextEffect.stateNode;
       switch (nextEffect.tag) {
         case 5:
-          finishedWork = finishedWork.canonical;
+          committedExpirationTime = committedExpirationTime.canonical;
       }
-      "function" === typeof effectTag
-        ? effectTag(finishedWork)
-        : (effectTag.current = finishedWork);
+      "function" === typeof finishedWork
+        ? finishedWork(committedExpirationTime)
+        : (finishedWork.current = committedExpirationTime);
     }
+    effectTag & 512 && (rootWithPendingPassiveEffects = finishedRoot$jscomp$0);
     nextEffect = nextEffect.nextEffect;
   }
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
+        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
 function flushPassiveEffects() {
   null !== passiveEffectCallback &&
     (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
@@ -5395,21 +5945,35 @@ function commitRoot(root, finishedWork) {
   }
   root.current = finishedWork;
   for (nextEffect = childExpirationTimeBeforeCommit; null !== nextEffect; ) {
-    childExpirationTimeBeforeCommit = !1;
-    didError = void 0;
+    didError = !1;
+    error$jscomp$0 = void 0;
     try {
       commitAllLifeCycles(root, committedExpirationTime);
     } catch (e) {
-      (childExpirationTimeBeforeCommit = !0), (didError = e);
+      (didError = !0), (error$jscomp$0 = e);
     }
-    childExpirationTimeBeforeCommit &&
+    didError &&
       (invariant(
         null !== nextEffect,
         "Should have next effect. This error is likely caused by a bug in React. Please file an issue."
       ),
-      captureCommitPhaseError(nextEffect, didError),
+      captureCommitPhaseError(nextEffect, error$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== childExpirationTimeBeforeCommit &&
+    null !== rootWithPendingPassiveEffects &&
+    ((childExpirationTimeBeforeCommit = commitPassiveEffects.bind(
+      null,
+      root,
+      childExpirationTimeBeforeCommit
+    )),
+    (childExpirationTimeBeforeCommit = tracing.unstable_wrap(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallback = childExpirationTimeBeforeCommit));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork.stateNode);
@@ -5594,11 +6158,7 @@ function completeUnitOfWork(workInProgress) {
                   : ((current$$1.firstEffect = current$$1.lastEffect = current),
                     (current.nextEffect = null)),
                 (current.effectTag = 8)));
-            if (
-              fiber !== renderExpirationTime ||
-              (0 === (current$$1.effectTag & 1) && fiber)
-            )
-              current$$1.effectTag |= 4;
+            if (fiber || renderExpirationTime) current$$1.effectTag |= 4;
             break;
           case 7:
             break;
@@ -5718,7 +6278,7 @@ function renderRoot(root, isYieldy) {
   );
   flushPassiveEffects();
   isWorking = !0;
-  ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
+  ReactCurrentDispatcher.current = Dispatcher;
   var expirationTime = root.nextExpirationTimeToWorkOn;
   if (
     expirationTime !== nextRenderExpirationTime ||
@@ -5771,10 +6331,7 @@ function renderRoot(root, isYieldy) {
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (
-        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
-        null === nextUnitOfWork)
-      )
+      if ((resetContextDependences(), resetHooks(), null === nextUnitOfWork))
         (threadID = !0), onUncaughtError(thrownValue);
       else {
         nextUnitOfWork.mode & 4 &&
@@ -5803,7 +6360,9 @@ function renderRoot(root, isYieldy) {
   } while (1);
   tracing.__interactionsRef.current = subscriber;
   isWorking = !1;
-  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
+  ReactCurrentDispatcher.current = null;
+  resetContextDependences();
+  resetHooks();
   if (threadID) (nextRoot = null), (root.finishedWork = null);
   else if (null !== nextUnitOfWork) root.finishedWork = null;
   else {
@@ -5898,38 +6457,23 @@ function computeExpirationForFiber(currentTime, fiber) {
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
-function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
-  var retryTime = root.earliestSuspendedTime;
-  var latestSuspendedTime = root.latestSuspendedTime;
-  if (
-    0 !== retryTime &&
-    suspendedTime <= retryTime &&
-    suspendedTime >= latestSuspendedTime
+function pingSuspendedRoot(root, thenable, pingTime) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(thenable);
+  if (null !== nextRoot && nextRenderExpirationTime === pingTime)
+    nextRoot = null;
+  else if (
+    ((thenable = root.earliestSuspendedTime),
+    (pingCache = root.latestSuspendedTime),
+    0 !== thenable && pingTime <= thenable && pingTime >= pingCache)
   ) {
-    latestSuspendedTime = retryTime = suspendedTime;
     root.didError = !1;
-    var latestPingedTime = root.latestPingedTime;
-    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
-      root.latestPingedTime = latestSuspendedTime;
-    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
-  } else
-    (retryTime = requestCurrentTime()),
-      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
-      markPendingPriorityLevel(root, retryTime);
-  0 !== (boundaryFiber.mode & 1) &&
-    root === nextRoot &&
-    nextRenderExpirationTime === suspendedTime &&
-    (nextRoot = null);
-  scheduleWorkToRoot(boundaryFiber, retryTime);
-  0 === (boundaryFiber.mode & 1) &&
-    (scheduleWorkToRoot(sourceFiber, retryTime),
-    1 === sourceFiber.tag &&
-      null !== sourceFiber.stateNode &&
-      ((boundaryFiber = createUpdate(retryTime)),
-      (boundaryFiber.tag = 2),
-      enqueueUpdate(sourceFiber, boundaryFiber)));
-  sourceFiber = root.expirationTime;
-  0 !== sourceFiber && requestWork(root, sourceFiber);
+    thenable = root.latestPingedTime;
+    if (0 === thenable || thenable > pingTime) root.latestPingedTime = pingTime;
+    findNextExpirationTimeToWorkOn(pingTime, root);
+    pingTime = root.expirationTime;
+    0 !== pingTime && requestWork(root, pingTime);
+  }
 }
 function scheduleWorkToRoot(fiber, expirationTime) {
   fiber.expirationTime < expirationTime &&
@@ -6513,6 +7057,7 @@ var roots = new Map(),
           earliestSuspendedTime: 0,
           latestSuspendedTime: 0,
           latestPingedTime: 0,
+          pingCache: null,
           didError: !1,
           pendingCommitExpirationTime: 0,
           finishedWork: null,
@@ -6616,6 +7161,8 @@ var roots = new Map(),
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
   return injectInternals(
     Object.assign({}, devToolsConfig, {
+      overrideProps: null,
+      currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
       findHostInstanceByFiber: function(fiber) {
         fiber = findCurrentHostFiber(fiber);
         return null === fiber ? null : fiber.stateNode;
@@ -6631,7 +7178,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromInstance,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.6.1",
+  version: "16.7.0",
   rendererPackageName: "react-native-renderer"
 });
 var ReactFabric$2 = { default: ReactFabric },
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-dev.js
@@ -4403,7 +4403,6 @@ function setCurrentPhase(lifeCyclePhase) {
 
 var debugRenderPhaseSideEffects = false;
 var debugRenderPhaseSideEffectsForStrictMode = false;
-var enableHooks = false;
 var enableUserTimingAPI = true;
 var replayFailedUnitOfWorkWithInvokeGuardedCallback = true;
 var warnAboutDeprecatedLifecycles = false;
@@ -5407,7 +5406,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.memoizedProps = null;
   this.updateQueue = null;
   this.memoizedState = null;
-  this.firstContextDependency = null;
+  this.contextDependencies = null;
 
   this.mode = mode;
 
@@ -5424,14 +5423,16 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.alternate = null;
 
   if (enableProfilerTimer) {
-    // Note: The following is done to avoid a v8 deopt.
+    // Note: The following is done to avoid a v8 performance cliff.
     //
-    // It is important to initialize the fields below with doubles.
-    // Otherwise Fibers will deopt and end up having separate shapes when
-    // doubles are later assigned to fields that initially contained smis.
-    // This is a bug in v8 having something to do with Object.preventExtension().
+    // Initializing the fields below to smis and later updating them with
+    // double values will cause Fibers to end up having separate shapes.
+    // This behavior/bug has something to do with Object.preventExtension().
+    // Fortunately this only impacts DEV builds.
+    // Unfortunately it makes React unusably slow for some applications.
+    // To work around this, initialize the fields below with doubles.
     //
-    // Learn more about this deopt here:
+    // Learn more about this here:
     // https://github.com/facebook/react/issues/14365
     // https://bugs.chromium.org/p/v8/issues/detail?id=8538
     this.actualDuration = Number.NaN;
@@ -5440,7 +5441,8 @@ function FiberNode(tag, pendingProps, key, mode) {
     this.treeBaseDuration = Number.NaN;
 
     // It's okay to replace the initial doubles with smis after initialization.
-    // This simplifies other profiler code and doesn't trigger the deopt.
+    // This won't trigger the performance cliff mentioned above,
+    // and it simplifies other profiler code (including DevTools).
     this.actualDuration = 0;
     this.actualStartTime = -1;
     this.selfBaseDuration = 0;
@@ -5561,7 +5563,7 @@ function createWorkInProgress(current, pendingProps, expirationTime) {
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.firstContextDependency = current.firstContextDependency;
+  workInProgress.contextDependencies = current.contextDependencies;
 
   // These will be overridden during the parent's reconciliation
   workInProgress.sibling = current.sibling;
@@ -5827,7 +5829,7 @@ function assignFiberPropertiesInDEV(target, source) {
   target.memoizedProps = source.memoizedProps;
   target.updateQueue = source.updateQueue;
   target.memoizedState = source.memoizedState;
-  target.firstContextDependency = source.firstContextDependency;
+  target.contextDependencies = source.contextDependencies;
   target.mode = source.mode;
   target.effectTag = source.effectTag;
   target.nextEffect = source.nextEffect;
@@ -5880,6 +5882,8 @@ function createFiberRoot(containerInfo, isConcurrent, hydrate) {
       latestSuspendedTime: NoWork,
       latestPingedTime: NoWork,
 
+      pingCache: null,
+
       didError: false,
 
       pendingCommitExpirationTime: NoWork,
@@ -5903,6 +5907,8 @@ function createFiberRoot(containerInfo, isConcurrent, hydrate) {
       containerInfo: containerInfo,
       pendingChildren: null,
 
+      pingCache: null,
+
       earliestPendingTime: NoWork,
       latestPendingTime: NoWork,
       earliestSuspendedTime: NoWork,
@@ -6052,7 +6058,7 @@ var ReactStrictModeWarnings = {
       lifecycleWarningsMap,
       strictRoot
     ) {
-      var lifecyclesWarningMesages = [];
+      var lifecyclesWarningMessages = [];
 
       Object.keys(lifecycleWarningsMap).forEach(function(lifecycle) {
         var lifecycleWarnings = lifecycleWarningsMap[lifecycle];
@@ -6067,7 +6073,7 @@ var ReactStrictModeWarnings = {
           var suggestion = LIFECYCLE_SUGGESTIONS[lifecycle];
           var sortedComponentNames = setToSortedString(componentNames);
 
-          lifecyclesWarningMesages.push(
+          lifecyclesWarningMessages.push(
             formatted +
               ": Please update the following components to use " +
               (suggestion + " instead: " + sortedComponentNames)
@@ -6075,7 +6081,7 @@ var ReactStrictModeWarnings = {
         }
       });
 
-      if (lifecyclesWarningMesages.length > 0) {
+      if (lifecyclesWarningMessages.length > 0) {
         var strictRootComponentStack = getStackByFiberInDevAndProd(strictRoot);
 
         warningWithoutStack$1(
@@ -6085,7 +6091,7 @@ var ReactStrictModeWarnings = {
             "\n\nLearn more about this warning here:" +
             "\nhttps://fb.me/react-strict-mode-warnings",
           strictRootComponentStack,
-          lifecyclesWarningMesages.join("\n\n")
+          lifecyclesWarningMessages.join("\n\n")
         );
       }
     });
@@ -6386,6 +6392,10 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
     return;
   }
 
+  if (earliestRemainingTime < root.latestPingedTime) {
+    root.latestPingedTime = NoWork;
+  }
+
   // Let's see if the previous latest known pending level was just flushed.
   var latestPendingTime = root.latestPendingTime;
   if (latestPendingTime !== NoWork) {
@@ -6521,10 +6531,8 @@ function markPingedPriorityLevel(root, pingedTime) {
 }
 
 function clearPing(root, completedTime) {
-  // TODO: Track whether the root was pinged during the render phase. If so,
-  // we need to make sure we don't lose track of it.
   var latestPingedTime = root.latestPingedTime;
-  if (latestPingedTime !== NoWork && latestPingedTime >= completedTime) {
+  if (latestPingedTime >= completedTime) {
     root.latestPingedTime = NoWork;
   }
 }
@@ -6588,10 +6596,10 @@ function findNextExpirationTimeToWorkOn(completedExpirationTime, root) {
 // UpdateQueue is a linked list of prioritized updates.
 //
 // Like fibers, update queues come in pairs: a current queue, which represents
-// the visible state of the screen, and a work-in-progress queue, which is
-// can be mutated and processed asynchronously before it is committed — a form
-// of double buffering. If a work-in-progress render is discarded before
-// finishing, we create a new work-in-progress by cloning the current queue.
+// the visible state of the screen, and a work-in-progress queue, which can be
+// mutated and processed asynchronously before it is committed — a form of
+// double buffering. If a work-in-progress render is discarded before finishing,
+// we create a new work-in-progress by cloning the current queue.
 //
 // Both queues share a persistent, singly-linked list structure. To schedule an
 // update, we append it to the end of both queues. Each queue maintains a
@@ -7177,3575 +7185,3612 @@ var warning = warningWithoutStack$1;
 
 var warning$1 = warning;
 
-var valueCursor = createCursor(null);
-
-var rendererSigil = void 0;
-{
-  // Use this to detect multiple renderers using the same context
-  rendererSigil = {};
+/**
+ * inlined Object.is polyfill to avoid requiring consumers ship their own
+ * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
+ */
+function is(x, y) {
+  return (
+    (x === y && (x !== 0 || 1 / x === 1 / y)) || (x !== x && y !== y) // eslint-disable-line no-self-compare
+  );
 }
 
-var currentlyRenderingFiber = null;
-var lastContextDependency = null;
-var lastContextWithAllBitsObserved = null;
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 
-function resetContextDependences() {
-  // This is called right before React yields execution, to ensure `readContext`
-  // cannot be called outside the render phase.
-  currentlyRenderingFiber = null;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
-}
+/**
+ * Performs equality by iterating through keys on an object and returning false
+ * when any key has values which are not strictly equal between the arguments.
+ * Returns true when the values of all keys are strictly equal.
+ */
+function shallowEqual(objA, objB) {
+  if (is(objA, objB)) {
+    return true;
+  }
 
-function pushProvider(providerFiber, nextValue) {
-  var context = providerFiber.type._context;
+  if (
+    typeof objA !== "object" ||
+    objA === null ||
+    typeof objB !== "object" ||
+    objB === null
+  ) {
+    return false;
+  }
 
-  if (isPrimaryRenderer) {
-    push(valueCursor, context._currentValue, providerFiber);
+  var keysA = Object.keys(objA);
+  var keysB = Object.keys(objB);
 
-    context._currentValue = nextValue;
-    {
-      !(
-        context._currentRenderer === undefined ||
-        context._currentRenderer === null ||
-        context._currentRenderer === rendererSigil
-      )
-        ? warningWithoutStack$1(
-            false,
-            "Detected multiple renderers concurrently rendering the " +
-              "same context provider. This is currently unsupported."
-          )
-        : void 0;
-      context._currentRenderer = rendererSigil;
-    }
-  } else {
-    push(valueCursor, context._currentValue2, providerFiber);
+  if (keysA.length !== keysB.length) {
+    return false;
+  }
 
-    context._currentValue2 = nextValue;
-    {
-      !(
-        context._currentRenderer2 === undefined ||
-        context._currentRenderer2 === null ||
-        context._currentRenderer2 === rendererSigil
-      )
-        ? warningWithoutStack$1(
-            false,
-            "Detected multiple renderers concurrently rendering the " +
-              "same context provider. This is currently unsupported."
-          )
-        : void 0;
-      context._currentRenderer2 = rendererSigil;
+  // Test for A's keys different from B.
+  for (var i = 0; i < keysA.length; i++) {
+    if (
+      !hasOwnProperty.call(objB, keysA[i]) ||
+      !is(objA[keysA[i]], objB[keysA[i]])
+    ) {
+      return false;
     }
   }
-}
-
-function popProvider(providerFiber) {
-  var currentValue = valueCursor.current;
-
-  pop(valueCursor, providerFiber);
 
-  var context = providerFiber.type._context;
-  if (isPrimaryRenderer) {
-    context._currentValue = currentValue;
-  } else {
-    context._currentValue2 = currentValue;
-  }
+  return true;
 }
 
-function calculateChangedBits(context, newValue, oldValue) {
-  // Use Object.is to compare the new context value to the old value. Inlined
-  // Object.is polyfill.
-  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-  if (
-    (oldValue === newValue &&
-      (oldValue !== 0 || 1 / oldValue === 1 / newValue)) ||
-    (oldValue !== oldValue && newValue !== newValue) // eslint-disable-line no-self-compare
-  ) {
-    // No change
-    return 0;
-  } else {
-    var changedBits =
-      typeof context._calculateChangedBits === "function"
-        ? context._calculateChangedBits(oldValue, newValue)
-        : maxSigned31BitInt;
-
-    {
-      !((changedBits & maxSigned31BitInt) === changedBits)
-        ? warning$1(
-            false,
-            "calculateChangedBits: Expected the return value to be a " +
-              "31-bit integer. Instead received: %s",
-            changedBits
-          )
-        : void 0;
+function resolveDefaultProps(Component, baseProps) {
+  if (Component && Component.defaultProps) {
+    // Resolve default props. Taken from ReactElement
+    var props = Object.assign({}, baseProps);
+    var defaultProps = Component.defaultProps;
+    for (var propName in defaultProps) {
+      if (props[propName] === undefined) {
+        props[propName] = defaultProps[propName];
+      }
     }
-    return changedBits | 0;
+    return props;
   }
+  return baseProps;
 }
 
-function propagateContextChange(
-  workInProgress,
-  context,
-  changedBits,
-  renderExpirationTime
-) {
-  var fiber = workInProgress.child;
-  if (fiber !== null) {
-    // Set the return pointer of the child to the work-in-progress fiber.
-    fiber.return = workInProgress;
-  }
-  while (fiber !== null) {
-    var nextFiber = void 0;
-
-    // Visit this fiber.
-    var dependency = fiber.firstContextDependency;
-    if (dependency !== null) {
-      do {
-        // Check if the context matches.
-        if (
-          dependency.context === context &&
-          (dependency.observedBits & changedBits) !== 0
-        ) {
-          // Match! Schedule an update on this fiber.
-
-          if (fiber.tag === ClassComponent) {
-            // Schedule a force update on the work-in-progress.
-            var update = createUpdate(renderExpirationTime);
-            update.tag = ForceUpdate;
-            // TODO: Because we don't have a work-in-progress, this will add the
-            // update to the current fiber, too, which means it will persist even if
-            // this render is thrown away. Since it's a race condition, not sure it's
-            // worth fixing.
-            enqueueUpdate(fiber, update);
-          }
-
-          if (fiber.expirationTime < renderExpirationTime) {
-            fiber.expirationTime = renderExpirationTime;
-          }
-          var alternate = fiber.alternate;
-          if (
-            alternate !== null &&
-            alternate.expirationTime < renderExpirationTime
-          ) {
-            alternate.expirationTime = renderExpirationTime;
-          }
-          // Update the child expiration time of all the ancestors, including
-          // the alternates.
-          var node = fiber.return;
-          while (node !== null) {
-            alternate = node.alternate;
-            if (node.childExpirationTime < renderExpirationTime) {
-              node.childExpirationTime = renderExpirationTime;
-              if (
-                alternate !== null &&
-                alternate.childExpirationTime < renderExpirationTime
-              ) {
-                alternate.childExpirationTime = renderExpirationTime;
+function readLazyComponentType(lazyComponent) {
+  var status = lazyComponent._status;
+  var result = lazyComponent._result;
+  switch (status) {
+    case Resolved: {
+      var Component = result;
+      return Component;
+    }
+    case Rejected: {
+      var error = result;
+      throw error;
+    }
+    case Pending: {
+      var thenable = result;
+      throw thenable;
+    }
+    default: {
+      lazyComponent._status = Pending;
+      var ctor = lazyComponent._ctor;
+      var _thenable = ctor();
+      _thenable.then(
+        function(moduleObject) {
+          if (lazyComponent._status === Pending) {
+            var defaultExport = moduleObject.default;
+            {
+              if (defaultExport === undefined) {
+                warning$1(
+                  false,
+                  "lazy: Expected the result of a dynamic import() call. " +
+                    "Instead received: %s\n\nYour code should look like: \n  " +
+                    "const MyComponent = lazy(() => import('./MyComponent'))",
+                  moduleObject
+                );
               }
-            } else if (
-              alternate !== null &&
-              alternate.childExpirationTime < renderExpirationTime
-            ) {
-              alternate.childExpirationTime = renderExpirationTime;
-            } else {
-              // Neither alternate was updated, which means the rest of the
-              // ancestor path already has sufficient priority.
-              break;
             }
-            node = node.return;
+            lazyComponent._status = Resolved;
+            lazyComponent._result = defaultExport;
+          }
+        },
+        function(error) {
+          if (lazyComponent._status === Pending) {
+            lazyComponent._status = Rejected;
+            lazyComponent._result = error;
           }
         }
-        nextFiber = fiber.child;
-        dependency = dependency.next;
-      } while (dependency !== null);
-    } else if (fiber.tag === ContextProvider) {
-      // Don't scan deeper if this is a matching provider
-      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
-    } else {
-      // Traverse down.
-      nextFiber = fiber.child;
+      );
+      // Handle synchronous thenables.
+      switch (lazyComponent._status) {
+        case Resolved:
+          return lazyComponent._result;
+        case Rejected:
+          throw lazyComponent._result;
+      }
+      lazyComponent._result = _thenable;
+      throw _thenable;
     }
-
-    if (nextFiber !== null) {
-      // Set the return pointer of the child to the work-in-progress fiber.
-      nextFiber.return = fiber;
-    } else {
-      // No child. Traverse to next sibling.
-      nextFiber = fiber;
-      while (nextFiber !== null) {
-        if (nextFiber === workInProgress) {
-          // We're back to the root of this subtree. Exit.
-          nextFiber = null;
-          break;
-        }
-        var sibling = nextFiber.sibling;
-        if (sibling !== null) {
-          // Set the return pointer of the sibling to the work-in-progress fiber.
-          sibling.return = nextFiber.return;
-          nextFiber = sibling;
-          break;
-        }
-        // No more siblings. Traverse up.
-        nextFiber = nextFiber.return;
-      }
-    }
-    fiber = nextFiber;
   }
 }
 
-function prepareToReadContext(workInProgress, renderExpirationTime) {
-  currentlyRenderingFiber = workInProgress;
-  lastContextDependency = null;
-  lastContextWithAllBitsObserved = null;
+var fakeInternalInstance = {};
+var isArray$1 = Array.isArray;
 
-  // Reset the work-in-progress list
-  workInProgress.firstContextDependency = null;
-}
+// React.Component uses a shared frozen object by default.
+// We'll use it to determine whether we need to initialize legacy refs.
+var emptyRefsObject = new React.Component().refs;
 
-function readContext(context, observedBits) {
-  if (lastContextWithAllBitsObserved === context) {
-    // Nothing to do. We already observe everything in this context.
-  } else if (observedBits === false || observedBits === 0) {
-    // Do not observe any updates.
-  } else {
-    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
-    if (
-      typeof observedBits !== "number" ||
-      observedBits === maxSigned31BitInt
-    ) {
-      // Observe all updates.
-      lastContextWithAllBitsObserved = context;
-      resolvedObservedBits = maxSigned31BitInt;
-    } else {
-      resolvedObservedBits = observedBits;
+var didWarnAboutStateAssignmentForComponent = void 0;
+var didWarnAboutUninitializedState = void 0;
+var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
+var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
+var didWarnAboutUndefinedDerivedState = void 0;
+var warnOnUndefinedDerivedState = void 0;
+var warnOnInvalidCallback = void 0;
+var didWarnAboutDirectlyAssigningPropsToState = void 0;
+var didWarnAboutContextTypeAndContextTypes = void 0;
+var didWarnAboutInvalidateContextType = void 0;
+
+{
+  didWarnAboutStateAssignmentForComponent = new Set();
+  didWarnAboutUninitializedState = new Set();
+  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
+  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
+  didWarnAboutDirectlyAssigningPropsToState = new Set();
+  didWarnAboutUndefinedDerivedState = new Set();
+  didWarnAboutContextTypeAndContextTypes = new Set();
+  didWarnAboutInvalidateContextType = new Set();
+
+  var didWarnOnInvalidCallback = new Set();
+
+  warnOnInvalidCallback = function(callback, callerName) {
+    if (callback === null || typeof callback === "function") {
+      return;
+    }
+    var key = callerName + "_" + callback;
+    if (!didWarnOnInvalidCallback.has(key)) {
+      didWarnOnInvalidCallback.add(key);
+      warningWithoutStack$1(
+        false,
+        "%s(...): Expected the last optional `callback` argument to be a " +
+          "function. Instead received: %s.",
+        callerName,
+        callback
+      );
     }
+  };
 
-    var contextItem = {
-      context: context,
-      observedBits: resolvedObservedBits,
-      next: null
-    };
+  warnOnUndefinedDerivedState = function(type, partialState) {
+    if (partialState === undefined) {
+      var componentName = getComponentName(type) || "Component";
+      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
+        didWarnAboutUndefinedDerivedState.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " +
+            "You have returned undefined.",
+          componentName
+        );
+      }
+    }
+  };
 
-    if (lastContextDependency === null) {
+  // This is so gross but it's at least non-critical and can be removed if
+  // it causes problems. This is meant to give a nicer error message for
+  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
+  // ...)) which otherwise throws a "_processChildContext is not a function"
+  // exception.
+  Object.defineProperty(fakeInternalInstance, "_processChildContext", {
+    enumerable: false,
+    value: function() {
       invariant(
-        currentlyRenderingFiber !== null,
-        "Context can only be read while React is " +
-          "rendering, e.g. inside the render method or getDerivedStateFromProps."
+        false,
+        "_processChildContext is not available in React 16+. This likely " +
+          "means you have multiple copies of React and are attempting to nest " +
+          "a React 15 tree inside a React 16 tree using " +
+          "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
+          "to make sure you have only one copy of React (and ideally, switch " +
+          "to ReactDOM.createPortal)."
       );
-      // This is the first dependency in the list
-      currentlyRenderingFiber.firstContextDependency = lastContextDependency = contextItem;
-    } else {
-      // Append a new context item.
-      lastContextDependency = lastContextDependency.next = contextItem;
     }
-  }
-  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
+  });
+  Object.freeze(fakeInternalInstance);
 }
 
-var NoEffect$1 = /*             */ 0;
-var UnmountSnapshot = /*      */ 2;
-var UnmountMutation = /*      */ 4;
-var MountMutation = /*        */ 8;
-var UnmountLayout = /*        */ 16;
-var MountLayout = /*          */ 32;
-var MountPassive = /*         */ 64;
-var UnmountPassive = /*       */ 128;
+function applyDerivedStateFromProps(
+  workInProgress,
+  ctor,
+  getDerivedStateFromProps,
+  nextProps
+) {
+  var prevState = workInProgress.memoizedState;
 
-function areHookInputsEqual(arr1, arr2) {
-  // Don't bother comparing lengths in prod because these arrays should be
-  // passed inline.
   {
-    !(arr1.length === arr2.length)
-      ? warning$1(
-          false,
-          "Detected a variable number of hook dependencies. The length of the " +
-            "dependencies array should be constant between renders.\n\n" +
-            "Previous: %s\n" +
-            "Incoming: %s",
-          arr1.join(", "),
-          arr2.join(", ")
-        )
-      : void 0;
-  }
-  for (var i = 0; i < arr1.length; i++) {
-    // Inlined Object.is polyfill.
-    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-    var val1 = arr1[i];
-    var val2 = arr2[i];
     if (
-      (val1 === val2 && (val1 !== 0 || 1 / val1 === 1 / val2)) ||
-      (val1 !== val1 && val2 !== val2) // eslint-disable-line no-self-compare
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
     ) {
-      continue;
+      // Invoke the function an extra time to help detect side-effects.
+      getDerivedStateFromProps(nextProps, prevState);
     }
-    return false;
   }
-  return true;
-}
-
-// These are set right before calling the component.
-var renderExpirationTime = NoWork;
-// The work-in-progress fiber. I've named it differently to distinguish it from
-// the work-in-progress hook.
-var currentlyRenderingFiber$1 = null;
-
-// Hooks are stored as a linked list on the fiber's memoizedState field. The
-// current hook list is the list that belongs to the current fiber. The
-// work-in-progress hook list is a new list that will be added to the
-// work-in-progress fiber.
-var firstCurrentHook = null;
-var currentHook = null;
-var firstWorkInProgressHook = null;
-var workInProgressHook = null;
-
-var remainingExpirationTime = NoWork;
-var componentUpdateQueue = null;
-
-// Updates scheduled during render will trigger an immediate re-render at the
-// end of the current pass. We can't store these updates on the normal queue,
-// because if the work is aborted, they should be discarded. Because this is
-// a relatively rare case, we also don't want to add an additional field to
-// either the hook or queue object types. So we store them in a lazily create
-// map of queue -> render-phase updates, which are discarded once the component
-// completes without re-rendering.
-
-// Whether the work-in-progress hook is a re-rendered hook
-var isReRender = false;
-// Whether an update was scheduled during the currently executing render pass.
-var didScheduleRenderPhaseUpdate = false;
-// Lazily created map of render-phase updates
-var renderPhaseUpdates = null;
-// Counter to prevent infinite loops.
-var numberOfReRenders = 0;
-var RE_RENDER_LIMIT = 25;
 
-function resolveCurrentlyRenderingFiber() {
-  invariant(
-    currentlyRenderingFiber$1 !== null,
-    "Hooks can only be called inside the body of a function component."
-  );
-  return currentlyRenderingFiber$1;
-}
+  var partialState = getDerivedStateFromProps(nextProps, prevState);
 
-function prepareToUseHooks(current, workInProgress, nextRenderExpirationTime) {
-  if (!enableHooks) {
-    return;
+  {
+    warnOnUndefinedDerivedState(ctor, partialState);
   }
-  renderExpirationTime = nextRenderExpirationTime;
-  currentlyRenderingFiber$1 = workInProgress;
-  firstCurrentHook = current !== null ? current.memoizedState : null;
-
-  // The following should have already been reset
-  // currentHook = null;
-  // workInProgressHook = null;
-
-  // remainingExpirationTime = NoWork;
-  // componentUpdateQueue = null;
+  // Merge the partial state and the previous state.
+  var memoizedState =
+    partialState === null || partialState === undefined
+      ? prevState
+      : Object.assign({}, prevState, partialState);
+  workInProgress.memoizedState = memoizedState;
 
-  // isReRender = false;
-  // didScheduleRenderPhaseUpdate = false;
-  // renderPhaseUpdates = null;
-  // numberOfReRenders = 0;
+  // Once the update queue is empty, persist the derived state onto the
+  // base state.
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
+    updateQueue.baseState = memoizedState;
+  }
 }
 
-function finishHooks(Component, props, children, refOrContext) {
-  if (!enableHooks) {
-    return children;
-  }
+var classComponentUpdater = {
+  isMounted: isMounted,
+  enqueueSetState: function(inst, payload, callback) {
+    var fiber = get$1(inst);
+    var currentTime = requestCurrentTime();
+    var expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-  // This must be called after every function component to prevent hooks from
-  // being used in classes.
+    var update = createUpdate(expirationTime);
+    update.payload = payload;
+    if (callback !== undefined && callback !== null) {
+      {
+        warnOnInvalidCallback(callback, "setState");
+      }
+      update.callback = callback;
+    }
 
-  while (didScheduleRenderPhaseUpdate) {
-    // Updates were scheduled during the render phase. They are stored in
-    // the `renderPhaseUpdates` map. Call the component again, reusing the
-    // work-in-progress hooks and applying the additional updates on top. Keep
-    // restarting until no more updates are scheduled.
-    didScheduleRenderPhaseUpdate = false;
-    numberOfReRenders += 1;
+    flushPassiveEffects();
+    enqueueUpdate(fiber, update);
+    scheduleWork(fiber, expirationTime);
+  },
+  enqueueReplaceState: function(inst, payload, callback) {
+    var fiber = get$1(inst);
+    var currentTime = requestCurrentTime();
+    var expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-    // Start over from the beginning of the list
-    currentHook = null;
-    workInProgressHook = null;
-    componentUpdateQueue = null;
-
-    children = Component(props, refOrContext);
-  }
-  renderPhaseUpdates = null;
-  numberOfReRenders = 0;
-
-  var renderedWork = currentlyRenderingFiber$1;
-
-  renderedWork.memoizedState = firstWorkInProgressHook;
-  renderedWork.expirationTime = remainingExpirationTime;
-  renderedWork.updateQueue = componentUpdateQueue;
-
-  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
-
-  renderExpirationTime = NoWork;
-  currentlyRenderingFiber$1 = null;
-
-  firstCurrentHook = null;
-  currentHook = null;
-  firstWorkInProgressHook = null;
-  workInProgressHook = null;
-
-  remainingExpirationTime = NoWork;
-  componentUpdateQueue = null;
+    var update = createUpdate(expirationTime);
+    update.tag = ReplaceState;
+    update.payload = payload;
 
-  // Always set during createWorkInProgress
-  // isReRender = false;
+    if (callback !== undefined && callback !== null) {
+      {
+        warnOnInvalidCallback(callback, "replaceState");
+      }
+      update.callback = callback;
+    }
 
-  // These were reset above
-  // didScheduleRenderPhaseUpdate = false;
-  // renderPhaseUpdates = null;
-  // numberOfReRenders = 0;
+    flushPassiveEffects();
+    enqueueUpdate(fiber, update);
+    scheduleWork(fiber, expirationTime);
+  },
+  enqueueForceUpdate: function(inst, callback) {
+    var fiber = get$1(inst);
+    var currentTime = requestCurrentTime();
+    var expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-  invariant(
-    !didRenderTooFewHooks,
-    "Rendered fewer hooks than expected. This may be caused by an accidental " +
-      "early return statement."
-  );
+    var update = createUpdate(expirationTime);
+    update.tag = ForceUpdate;
 
-  return children;
-}
+    if (callback !== undefined && callback !== null) {
+      {
+        warnOnInvalidCallback(callback, "forceUpdate");
+      }
+      update.callback = callback;
+    }
 
-function resetHooks() {
-  if (!enableHooks) {
-    return;
+    flushPassiveEffects();
+    enqueueUpdate(fiber, update);
+    scheduleWork(fiber, expirationTime);
   }
+};
 
-  // This is called instead of `finishHooks` if the component throws. It's also
-  // called inside mountIndeterminateComponent if we determine the component
-  // is a module-style component.
-  renderExpirationTime = NoWork;
-  currentlyRenderingFiber$1 = null;
-
-  firstCurrentHook = null;
-  currentHook = null;
-  firstWorkInProgressHook = null;
-  workInProgressHook = null;
-
-  remainingExpirationTime = NoWork;
-  componentUpdateQueue = null;
-
-  // Always set during createWorkInProgress
-  // isReRender = false;
+function checkShouldComponentUpdate(
+  workInProgress,
+  ctor,
+  oldProps,
+  newProps,
+  oldState,
+  newState,
+  nextContext
+) {
+  var instance = workInProgress.stateNode;
+  if (typeof instance.shouldComponentUpdate === "function") {
+    startPhaseTimer(workInProgress, "shouldComponentUpdate");
+    var shouldUpdate = instance.shouldComponentUpdate(
+      newProps,
+      newState,
+      nextContext
+    );
+    stopPhaseTimer();
 
-  didScheduleRenderPhaseUpdate = false;
-  renderPhaseUpdates = null;
-  numberOfReRenders = 0;
-}
+    {
+      !(shouldUpdate !== undefined)
+        ? warningWithoutStack$1(
+            false,
+            "%s.shouldComponentUpdate(): Returned undefined instead of a " +
+              "boolean value. Make sure to return true or false.",
+            getComponentName(ctor) || "Component"
+          )
+        : void 0;
+    }
 
-function createHook() {
-  return {
-    memoizedState: null,
+    return shouldUpdate;
+  }
 
-    baseState: null,
-    queue: null,
-    baseUpdate: null,
+  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
+    return (
+      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
+    );
+  }
 
-    next: null
-  };
+  return true;
 }
 
-function cloneHook(hook) {
-  return {
-    memoizedState: hook.memoizedState,
-
-    baseState: hook.baseState,
-    queue: hook.queue,
-    baseUpdate: hook.baseUpdate,
-
-    next: null
-  };
-}
+function checkClassInstance(workInProgress, ctor, newProps) {
+  var instance = workInProgress.stateNode;
+  {
+    var name = getComponentName(ctor) || "Component";
+    var renderPresent = instance.render;
 
-function createWorkInProgressHook() {
-  if (workInProgressHook === null) {
-    // This is the first hook in the list
-    if (firstWorkInProgressHook === null) {
-      isReRender = false;
-      currentHook = firstCurrentHook;
-      if (currentHook === null) {
-        // This is a newly mounted hook
-        workInProgressHook = createHook();
-      } else {
-        // Clone the current hook.
-        workInProgressHook = cloneHook(currentHook);
-      }
-      firstWorkInProgressHook = workInProgressHook;
-    } else {
-      // There's already a work-in-progress. Reuse it.
-      isReRender = true;
-      currentHook = firstCurrentHook;
-      workInProgressHook = firstWorkInProgressHook;
-    }
-  } else {
-    if (workInProgressHook.next === null) {
-      isReRender = false;
-      var hook = void 0;
-      if (currentHook === null) {
-        // This is a newly mounted hook
-        hook = createHook();
+    if (!renderPresent) {
+      if (ctor.prototype && typeof ctor.prototype.render === "function") {
+        warningWithoutStack$1(
+          false,
+          "%s(...): No `render` method found on the returned component " +
+            "instance: did you accidentally return an object from the constructor?",
+          name
+        );
       } else {
-        currentHook = currentHook.next;
-        if (currentHook === null) {
-          // This is a newly mounted hook
-          hook = createHook();
-        } else {
-          // Clone the current hook.
-          hook = cloneHook(currentHook);
-        }
+        warningWithoutStack$1(
+          false,
+          "%s(...): No `render` method found on the returned component " +
+            "instance: you may have forgotten to define `render`.",
+          name
+        );
       }
-      // Append to the end of the list
-      workInProgressHook = workInProgressHook.next = hook;
-    } else {
-      // There's already a work-in-progress. Reuse it.
-      isReRender = true;
-      workInProgressHook = workInProgressHook.next;
-      currentHook = currentHook !== null ? currentHook.next : null;
     }
-  }
-  return workInProgressHook;
-}
 
-function createFunctionComponentUpdateQueue() {
-  return {
-    lastEffect: null
-  };
-}
+    var noGetInitialStateOnES6 =
+      !instance.getInitialState ||
+      instance.getInitialState.isReactClassApproved ||
+      instance.state;
+    !noGetInitialStateOnES6
+      ? warningWithoutStack$1(
+          false,
+          "getInitialState was defined on %s, a plain JavaScript class. " +
+            "This is only supported for classes created using React.createClass. " +
+            "Did you mean to define a state property instead?",
+          name
+        )
+      : void 0;
+    var noGetDefaultPropsOnES6 =
+      !instance.getDefaultProps ||
+      instance.getDefaultProps.isReactClassApproved;
+    !noGetDefaultPropsOnES6
+      ? warningWithoutStack$1(
+          false,
+          "getDefaultProps was defined on %s, a plain JavaScript class. " +
+            "This is only supported for classes created using React.createClass. " +
+            "Use a static property to define defaultProps instead.",
+          name
+        )
+      : void 0;
+    var noInstancePropTypes = !instance.propTypes;
+    !noInstancePropTypes
+      ? warningWithoutStack$1(
+          false,
+          "propTypes was defined as an instance property on %s. Use a static " +
+            "property to define propTypes instead.",
+          name
+        )
+      : void 0;
+    var noInstanceContextType = !instance.contextType;
+    !noInstanceContextType
+      ? warningWithoutStack$1(
+          false,
+          "contextType was defined as an instance property on %s. Use a static " +
+            "property to define contextType instead.",
+          name
+        )
+      : void 0;
+    var noInstanceContextTypes = !instance.contextTypes;
+    !noInstanceContextTypes
+      ? warningWithoutStack$1(
+          false,
+          "contextTypes was defined as an instance property on %s. Use a static " +
+            "property to define contextTypes instead.",
+          name
+        )
+      : void 0;
 
-function basicStateReducer(state, action) {
-  return typeof action === "function" ? action(state) : action;
-}
-
-function useContext(context, observedBits) {
-  // Ensure we're in a function component (class components support only the
-  // .unstable_read() form)
-  resolveCurrentlyRenderingFiber();
-  return readContext(context, observedBits);
-}
-
-function useState(initialState) {
-  return useReducer(
-    basicStateReducer,
-    // useReducer has a special case to support lazy useState initializers
-    initialState
-  );
-}
-
-function useReducer(reducer, initialState, initialAction) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
-  var queue = workInProgressHook.queue;
-  if (queue !== null) {
-    // Already have a queue, so this is an update.
-    if (isReRender) {
-      // This is a re-render. Apply the new render phase updates to the previous
-      var _dispatch2 = queue.dispatch;
-      if (renderPhaseUpdates !== null) {
-        // Render phase updates are stored in a map of queue -> linked list
-        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
-        if (firstRenderPhaseUpdate !== undefined) {
-          renderPhaseUpdates.delete(queue);
-          var newState = workInProgressHook.memoizedState;
-          var update = firstRenderPhaseUpdate;
-          do {
-            // Process this render phase update. We don't have to check the
-            // priority because it will always be the same as the current
-            // render's.
-            var _action = update.action;
-            newState = reducer(newState, _action);
-            update = update.next;
-          } while (update !== null);
-
-          workInProgressHook.memoizedState = newState;
-
-          // Don't persist the state accumlated from the render phase updates to
-          // the base state unless the queue is empty.
-          // TODO: Not sure if this is the desired semantics, but it's what we
-          // do for gDSFP. I can't remember why.
-          if (workInProgressHook.baseUpdate === queue.last) {
-            workInProgressHook.baseState = newState;
-          }
-
-          return [newState, _dispatch2];
-        }
-      }
-      return [workInProgressHook.memoizedState, _dispatch2];
+    if (
+      ctor.contextType &&
+      ctor.contextTypes &&
+      !didWarnAboutContextTypeAndContextTypes.has(ctor)
+    ) {
+      didWarnAboutContextTypeAndContextTypes.add(ctor);
+      warningWithoutStack$1(
+        false,
+        "%s declares both contextTypes and contextType static properties. " +
+          "The legacy contextTypes property will be ignored.",
+        name
+      );
     }
 
-    // The last update in the entire queue
-    var _last = queue.last;
-    // The last update that is part of the base state.
-    var _baseUpdate = workInProgressHook.baseUpdate;
-
-    // Find the first unprocessed update.
-    var first = void 0;
-    if (_baseUpdate !== null) {
-      if (_last !== null) {
-        // For the first update, the queue is a circular linked list where
-        // `queue.last.next = queue.first`. Once the first update commits, and
-        // the `baseUpdate` is no longer empty, we can unravel the list.
-        _last.next = null;
-      }
-      first = _baseUpdate.next;
-    } else {
-      first = _last !== null ? _last.next : null;
+    var noComponentShouldUpdate =
+      typeof instance.componentShouldUpdate !== "function";
+    !noComponentShouldUpdate
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
+            "The name is phrased as a question because the function is " +
+            "expected to return a value.",
+          name
+        )
+      : void 0;
+    if (
+      ctor.prototype &&
+      ctor.prototype.isPureReactComponent &&
+      typeof instance.shouldComponentUpdate !== "undefined"
+    ) {
+      warningWithoutStack$1(
+        false,
+        "%s has a method called shouldComponentUpdate(). " +
+          "shouldComponentUpdate should not be used when extending React.PureComponent. " +
+          "Please extend React.Component if shouldComponentUpdate is used.",
+        getComponentName(ctor) || "A pure component"
+      );
     }
-    if (first !== null) {
-      var _newState = workInProgressHook.baseState;
-      var newBaseState = null;
-      var newBaseUpdate = null;
-      var prevUpdate = _baseUpdate;
-      var _update = first;
-      var didSkip = false;
-      do {
-        var updateExpirationTime = _update.expirationTime;
-        if (updateExpirationTime < renderExpirationTime) {
-          // Priority is insufficient. Skip this update. If this is the first
-          // skipped update, the previous update/state is the new base
-          // update/state.
-          if (!didSkip) {
-            didSkip = true;
-            newBaseUpdate = prevUpdate;
-            newBaseState = _newState;
-          }
-          // Update the remaining priority in the queue.
-          if (updateExpirationTime > remainingExpirationTime) {
-            remainingExpirationTime = updateExpirationTime;
-          }
-        } else {
-          // Process this update.
-          var _action2 = _update.action;
-          _newState = reducer(_newState, _action2);
-        }
-        prevUpdate = _update;
-        _update = _update.next;
-      } while (_update !== null && _update !== first);
-
-      if (!didSkip) {
-        newBaseUpdate = prevUpdate;
-        newBaseState = _newState;
-      }
+    var noComponentDidUnmount =
+      typeof instance.componentDidUnmount !== "function";
+    !noComponentDidUnmount
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentDidUnmount(). But there is no such lifecycle method. " +
+            "Did you mean componentWillUnmount()?",
+          name
+        )
+      : void 0;
+    var noComponentDidReceiveProps =
+      typeof instance.componentDidReceiveProps !== "function";
+    !noComponentDidReceiveProps
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentDidReceiveProps(). But there is no such lifecycle method. " +
+            "If you meant to update the state in response to changing props, " +
+            "use componentWillReceiveProps(). If you meant to fetch data or " +
+            "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
+          name
+        )
+      : void 0;
+    var noComponentWillRecieveProps =
+      typeof instance.componentWillRecieveProps !== "function";
+    !noComponentWillRecieveProps
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
+          name
+        )
+      : void 0;
+    var noUnsafeComponentWillRecieveProps =
+      typeof instance.UNSAFE_componentWillRecieveProps !== "function";
+    !noUnsafeComponentWillRecieveProps
+      ? warningWithoutStack$1(
+          false,
+          "%s has a method called " +
+            "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
+          name
+        )
+      : void 0;
+    var hasMutatedProps = instance.props !== newProps;
+    !(instance.props === undefined || !hasMutatedProps)
+      ? warningWithoutStack$1(
+          false,
+          "%s(...): When calling super() in `%s`, make sure to pass " +
+            "up the same props that your component's constructor was passed.",
+          name,
+          name
+        )
+      : void 0;
+    var noInstanceDefaultProps = !instance.defaultProps;
+    !noInstanceDefaultProps
+      ? warningWithoutStack$1(
+          false,
+          "Setting defaultProps as an instance property on %s is not supported and will be ignored." +
+            " Instead, define defaultProps as a static property on %s.",
+          name,
+          name
+        )
+      : void 0;
 
-      workInProgressHook.memoizedState = _newState;
-      workInProgressHook.baseUpdate = newBaseUpdate;
-      workInProgressHook.baseState = newBaseState;
+    if (
+      typeof instance.getSnapshotBeforeUpdate === "function" &&
+      typeof instance.componentDidUpdate !== "function" &&
+      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
+    ) {
+      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
+      warningWithoutStack$1(
+        false,
+        "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " +
+          "This component defines getSnapshotBeforeUpdate() only.",
+        getComponentName(ctor)
+      );
     }
 
-    var _dispatch = queue.dispatch;
-    return [workInProgressHook.memoizedState, _dispatch];
+    var noInstanceGetDerivedStateFromProps =
+      typeof instance.getDerivedStateFromProps !== "function";
+    !noInstanceGetDerivedStateFromProps
+      ? warningWithoutStack$1(
+          false,
+          "%s: getDerivedStateFromProps() is defined as an instance method " +
+            "and will be ignored. Instead, declare it as a static method.",
+          name
+        )
+      : void 0;
+    var noInstanceGetDerivedStateFromCatch =
+      typeof instance.getDerivedStateFromError !== "function";
+    !noInstanceGetDerivedStateFromCatch
+      ? warningWithoutStack$1(
+          false,
+          "%s: getDerivedStateFromError() is defined as an instance method " +
+            "and will be ignored. Instead, declare it as a static method.",
+          name
+        )
+      : void 0;
+    var noStaticGetSnapshotBeforeUpdate =
+      typeof ctor.getSnapshotBeforeUpdate !== "function";
+    !noStaticGetSnapshotBeforeUpdate
+      ? warningWithoutStack$1(
+          false,
+          "%s: getSnapshotBeforeUpdate() is defined as a static method " +
+            "and will be ignored. Instead, declare it as an instance method.",
+          name
+        )
+      : void 0;
+    var _state = instance.state;
+    if (_state && (typeof _state !== "object" || isArray$1(_state))) {
+      warningWithoutStack$1(
+        false,
+        "%s.state: must be set to an object or null",
+        name
+      );
+    }
+    if (typeof instance.getChildContext === "function") {
+      !(typeof ctor.childContextTypes === "object")
+        ? warningWithoutStack$1(
+            false,
+            "%s.getChildContext(): childContextTypes must be defined in order to " +
+              "use getChildContext().",
+            name
+          )
+        : void 0;
+    }
   }
+}
 
-  // There's no existing queue, so this is the initial render.
-  if (reducer === basicStateReducer) {
-    // Special case for `useState`.
-    if (typeof initialState === "function") {
-      initialState = initialState();
-    }
-  } else if (initialAction !== undefined && initialAction !== null) {
-    initialState = reducer(initialState, initialAction);
+function adoptClassInstance(workInProgress, instance) {
+  instance.updater = classComponentUpdater;
+  workInProgress.stateNode = instance;
+  // The instance needs access to the fiber so that it can schedule updates
+  set(instance, workInProgress);
+  {
+    instance._reactInternalInstance = fakeInternalInstance;
   }
-  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
-  queue = workInProgressHook.queue = {
-    last: null,
-    dispatch: null
-  };
-  var dispatch = (queue.dispatch = dispatchAction.bind(
-    null,
-    currentlyRenderingFiber$1,
-    queue
-  ));
-  return [workInProgressHook.memoizedState, dispatch];
 }
 
-function pushEffect(tag, create, destroy, inputs) {
-  var effect = {
-    tag: tag,
-    create: create,
-    destroy: destroy,
-    inputs: inputs,
-    // Circular
-    next: null
-  };
-  if (componentUpdateQueue === null) {
-    componentUpdateQueue = createFunctionComponentUpdateQueue();
-    componentUpdateQueue.lastEffect = effect.next = effect;
+function constructClassInstance(
+  workInProgress,
+  ctor,
+  props,
+  renderExpirationTime
+) {
+  var isLegacyContextConsumer = false;
+  var unmaskedContext = emptyContextObject;
+  var context = null;
+  var contextType = ctor.contextType;
+  if (typeof contextType === "object" && contextType !== null) {
+    {
+      if (
+        contextType.$$typeof !== REACT_CONTEXT_TYPE &&
+        !didWarnAboutInvalidateContextType.has(ctor)
+      ) {
+        didWarnAboutInvalidateContextType.add(ctor);
+        warningWithoutStack$1(
+          false,
+          "%s defines an invalid contextType. " +
+            "contextType should point to the Context object returned by React.createContext(). " +
+            "Did you accidentally pass the Context.Provider instead?",
+          getComponentName(ctor) || "Component"
+        );
+      }
+    }
+
+    context = readContext(contextType);
   } else {
-    var _lastEffect = componentUpdateQueue.lastEffect;
-    if (_lastEffect === null) {
-      componentUpdateQueue.lastEffect = effect.next = effect;
-    } else {
-      var firstEffect = _lastEffect.next;
-      _lastEffect.next = effect;
-      effect.next = firstEffect;
-      componentUpdateQueue.lastEffect = effect;
+    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
+    var contextTypes = ctor.contextTypes;
+    isLegacyContextConsumer =
+      contextTypes !== null && contextTypes !== undefined;
+    context = isLegacyContextConsumer
+      ? getMaskedContext(workInProgress, unmaskedContext)
+      : emptyContextObject;
+  }
+
+  // Instantiate twice to help detect side-effects.
+  {
+    if (
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
+    ) {
+      new ctor(props, context); // eslint-disable-line no-new
     }
   }
-  return effect;
-}
 
-function useRef(initialValue) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
-  var ref = void 0;
+  var instance = new ctor(props, context);
+  var state = (workInProgress.memoizedState =
+    instance.state !== null && instance.state !== undefined
+      ? instance.state
+      : null);
+  adoptClassInstance(workInProgress, instance);
 
-  if (workInProgressHook.memoizedState === null) {
-    ref = { current: initialValue };
-    {
-      Object.seal(ref);
+  {
+    if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
+      var componentName = getComponentName(ctor) || "Component";
+      if (!didWarnAboutUninitializedState.has(componentName)) {
+        didWarnAboutUninitializedState.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "`%s` uses `getDerivedStateFromProps` but its initial state is " +
+            "%s. This is not recommended. Instead, define the initial state by " +
+            "assigning an object to `this.state` in the constructor of `%s`. " +
+            "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
+          componentName,
+          instance.state === null ? "null" : "undefined",
+          componentName
+        );
+      }
+    }
+
+    // If new component APIs are defined, "unsafe" lifecycles won't be called.
+    // Warn about these lifecycles if they are present.
+    // Don't warn about react-lifecycles-compat polyfilled methods though.
+    if (
+      typeof ctor.getDerivedStateFromProps === "function" ||
+      typeof instance.getSnapshotBeforeUpdate === "function"
+    ) {
+      var foundWillMountName = null;
+      var foundWillReceivePropsName = null;
+      var foundWillUpdateName = null;
+      if (
+        typeof instance.componentWillMount === "function" &&
+        instance.componentWillMount.__suppressDeprecationWarning !== true
+      ) {
+        foundWillMountName = "componentWillMount";
+      } else if (typeof instance.UNSAFE_componentWillMount === "function") {
+        foundWillMountName = "UNSAFE_componentWillMount";
+      }
+      if (
+        typeof instance.componentWillReceiveProps === "function" &&
+        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
+      ) {
+        foundWillReceivePropsName = "componentWillReceiveProps";
+      } else if (
+        typeof instance.UNSAFE_componentWillReceiveProps === "function"
+      ) {
+        foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
+      }
+      if (
+        typeof instance.componentWillUpdate === "function" &&
+        instance.componentWillUpdate.__suppressDeprecationWarning !== true
+      ) {
+        foundWillUpdateName = "componentWillUpdate";
+      } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
+        foundWillUpdateName = "UNSAFE_componentWillUpdate";
+      }
+      if (
+        foundWillMountName !== null ||
+        foundWillReceivePropsName !== null ||
+        foundWillUpdateName !== null
+      ) {
+        var _componentName = getComponentName(ctor) || "Component";
+        var newApiName =
+          typeof ctor.getDerivedStateFromProps === "function"
+            ? "getDerivedStateFromProps()"
+            : "getSnapshotBeforeUpdate()";
+        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
+          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
+          warningWithoutStack$1(
+            false,
+            "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
+              "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
+              "The above lifecycles should be removed. Learn more about this warning here:\n" +
+              "https://fb.me/react-async-component-lifecycle-hooks",
+            _componentName,
+            newApiName,
+            foundWillMountName !== null ? "\n  " + foundWillMountName : "",
+            foundWillReceivePropsName !== null
+              ? "\n  " + foundWillReceivePropsName
+              : "",
+            foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : ""
+          );
+        }
+      }
     }
-    workInProgressHook.memoizedState = ref;
-  } else {
-    ref = workInProgressHook.memoizedState;
   }
-  return ref;
-}
 
-function useLayoutEffect(create, inputs) {
-  useEffectImpl(Update, UnmountMutation | MountLayout, create, inputs);
-}
+  // Cache unmasked context so we can avoid recreating masked context unless necessary.
+  // ReactFiberContext usually updates this cache but can't for newly-created instances.
+  if (isLegacyContextConsumer) {
+    cacheContext(workInProgress, unmaskedContext, context);
+  }
 
-function useEffect(create, inputs) {
-  useEffectImpl(
-    Update | Passive,
-    UnmountPassive | MountPassive,
-    create,
-    inputs
-  );
+  return instance;
 }
 
-function useEffectImpl(fiberEffectTag, hookEffectTag, create, inputs) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
+function callComponentWillMount(workInProgress, instance) {
+  startPhaseTimer(workInProgress, "componentWillMount");
+  var oldState = instance.state;
 
-  var nextInputs = inputs !== undefined && inputs !== null ? inputs : [create];
-  var destroy = null;
-  if (currentHook !== null) {
-    var prevEffect = currentHook.memoizedState;
-    destroy = prevEffect.destroy;
-    if (areHookInputsEqual(nextInputs, prevEffect.inputs)) {
-      pushEffect(NoEffect$1, create, destroy, nextInputs);
-      return;
-    }
+  if (typeof instance.componentWillMount === "function") {
+    instance.componentWillMount();
+  }
+  if (typeof instance.UNSAFE_componentWillMount === "function") {
+    instance.UNSAFE_componentWillMount();
   }
 
-  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
-  workInProgressHook.memoizedState = pushEffect(
-    hookEffectTag,
-    create,
-    destroy,
-    nextInputs
-  );
+  stopPhaseTimer();
+
+  if (oldState !== instance.state) {
+    {
+      warningWithoutStack$1(
+        false,
+        "%s.componentWillMount(): Assigning directly to this.state is " +
+          "deprecated (except inside a component's " +
+          "constructor). Use setState instead.",
+        getComponentName(workInProgress.type) || "Component"
+      );
+    }
+    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+  }
 }
 
-function useImperativeMethods(ref, create, inputs) {
-  // TODO: If inputs are provided, should we skip comparing the ref itself?
-  var nextInputs =
-    inputs !== null && inputs !== undefined
-      ? inputs.concat([ref])
-      : [ref, create];
+function callComponentWillReceiveProps(
+  workInProgress,
+  instance,
+  newProps,
+  nextContext
+) {
+  var oldState = instance.state;
+  startPhaseTimer(workInProgress, "componentWillReceiveProps");
+  if (typeof instance.componentWillReceiveProps === "function") {
+    instance.componentWillReceiveProps(newProps, nextContext);
+  }
+  if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
+    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
+  }
+  stopPhaseTimer();
 
-  // TODO: I've implemented this on top of useEffect because it's almost the
-  // same thing, and it would require an equal amount of code. It doesn't seem
-  // like a common enough use case to justify the additional size.
-  useLayoutEffect(function() {
-    if (typeof ref === "function") {
-      var refCallback = ref;
-      var _inst = create();
-      refCallback(_inst);
-      return function() {
-        return refCallback(null);
-      };
-    } else if (ref !== null && ref !== undefined) {
-      var refObject = ref;
-      var _inst2 = create();
-      refObject.current = _inst2;
-      return function() {
-        refObject.current = null;
-      };
+  if (instance.state !== oldState) {
+    {
+      var componentName = getComponentName(workInProgress.type) || "Component";
+      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
+        didWarnAboutStateAssignmentForComponent.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "%s.componentWillReceiveProps(): Assigning directly to " +
+            "this.state is deprecated (except inside a component's " +
+            "constructor). Use setState instead.",
+          componentName
+        );
+      }
     }
-  }, nextInputs);
+    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+  }
 }
 
-function useCallback(callback, inputs) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
+// Invokes the mount life-cycles on a previously never rendered instance.
+function mountClassInstance(
+  workInProgress,
+  ctor,
+  newProps,
+  renderExpirationTime
+) {
+  {
+    checkClassInstance(workInProgress, ctor, newProps);
+  }
 
-  var nextInputs =
-    inputs !== undefined && inputs !== null ? inputs : [callback];
+  var instance = workInProgress.stateNode;
+  instance.props = newProps;
+  instance.state = workInProgress.memoizedState;
+  instance.refs = emptyRefsObject;
 
-  var prevState = workInProgressHook.memoizedState;
-  if (prevState !== null) {
-    var prevInputs = prevState[1];
-    if (areHookInputsEqual(nextInputs, prevInputs)) {
-      return prevState[0];
-    }
+  var contextType = ctor.contextType;
+  if (typeof contextType === "object" && contextType !== null) {
+    instance.context = readContext(contextType);
+  } else {
+    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
+    instance.context = getMaskedContext(workInProgress, unmaskedContext);
   }
-  workInProgressHook.memoizedState = [callback, nextInputs];
-  return callback;
-}
 
-function useMemo(nextCreate, inputs) {
-  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
-  workInProgressHook = createWorkInProgressHook();
+  {
+    if (instance.state === newProps) {
+      var componentName = getComponentName(ctor) || "Component";
+      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
+        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
+        warningWithoutStack$1(
+          false,
+          "%s: It is not recommended to assign props directly to state " +
+            "because updates to props won't be reflected in state. " +
+            "In most cases, it is better to use props directly.",
+          componentName
+        );
+      }
+    }
 
-  var nextInputs =
-    inputs !== undefined && inputs !== null ? inputs : [nextCreate];
+    if (workInProgress.mode & StrictMode) {
+      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
+        workInProgress,
+        instance
+      );
 
-  var prevState = workInProgressHook.memoizedState;
-  if (prevState !== null) {
-    var prevInputs = prevState[1];
-    if (areHookInputsEqual(nextInputs, prevInputs)) {
-      return prevState[0];
+      ReactStrictModeWarnings.recordLegacyContextWarning(
+        workInProgress,
+        instance
+      );
+    }
+
+    if (warnAboutDeprecatedLifecycles) {
+      ReactStrictModeWarnings.recordDeprecationWarnings(
+        workInProgress,
+        instance
+      );
     }
   }
 
-  var nextValue = nextCreate();
-  workInProgressHook.memoizedState = [nextValue, nextInputs];
-  return nextValue;
-}
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null) {
+    processUpdateQueue(
+      workInProgress,
+      updateQueue,
+      newProps,
+      instance,
+      renderExpirationTime
+    );
+    instance.state = workInProgress.memoizedState;
+  }
 
-function dispatchAction(fiber, queue, action) {
-  invariant(
-    numberOfReRenders < RE_RENDER_LIMIT,
-    "Too many re-renders. React limits the number of renders to prevent " +
-      "an infinite loop."
-  );
+  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
+  if (typeof getDerivedStateFromProps === "function") {
+    applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      newProps
+    );
+    instance.state = workInProgress.memoizedState;
+  }
 
-  var alternate = fiber.alternate;
+  // In order to support react-lifecycles-compat polyfilled components,
+  // Unsafe lifecycles should not be invoked for components using the new APIs.
   if (
-    fiber === currentlyRenderingFiber$1 ||
-    (alternate !== null && alternate === currentlyRenderingFiber$1)
+    typeof ctor.getDerivedStateFromProps !== "function" &&
+    typeof instance.getSnapshotBeforeUpdate !== "function" &&
+    (typeof instance.UNSAFE_componentWillMount === "function" ||
+      typeof instance.componentWillMount === "function")
   ) {
-    // This is a render phase update. Stash it in a lazily-created map of
-    // queue -> linked list of updates. After this render pass, we'll restart
-    // and apply the stashed updates on top of the work-in-progress hook.
-    didScheduleRenderPhaseUpdate = true;
-    var update = {
-      expirationTime: renderExpirationTime,
-      action: action,
-      next: null
-    };
-    if (renderPhaseUpdates === null) {
-      renderPhaseUpdates = new Map();
-    }
-    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
-    if (firstRenderPhaseUpdate === undefined) {
-      renderPhaseUpdates.set(queue, update);
-    } else {
-      // Append the update to the end of the list.
-      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
-      while (lastRenderPhaseUpdate.next !== null) {
-        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
-      }
-      lastRenderPhaseUpdate.next = update;
-    }
-  } else {
-    var currentTime = requestCurrentTime();
-    var _expirationTime = computeExpirationForFiber(currentTime, fiber);
-    var _update2 = {
-      expirationTime: _expirationTime,
-      action: action,
-      next: null
-    };
-    flushPassiveEffects();
-    // Append the update to the end of the list.
-    var _last2 = queue.last;
-    if (_last2 === null) {
-      // This is the first update. Create a circular list.
-      _update2.next = _update2;
-    } else {
-      var first = _last2.next;
-      if (first !== null) {
-        // Still circular.
-        _update2.next = first;
-      }
-      _last2.next = _update2;
+    callComponentWillMount(workInProgress, instance);
+    // If we had additional state updates during this life-cycle, let's
+    // process them now.
+    updateQueue = workInProgress.updateQueue;
+    if (updateQueue !== null) {
+      processUpdateQueue(
+        workInProgress,
+        updateQueue,
+        newProps,
+        instance,
+        renderExpirationTime
+      );
+      instance.state = workInProgress.memoizedState;
     }
-    queue.last = _update2;
-    scheduleWork(fiber, _expirationTime);
   }
-}
-
-var NO_CONTEXT = {};
-
-var contextStackCursor$1 = createCursor(NO_CONTEXT);
-var contextFiberStackCursor = createCursor(NO_CONTEXT);
-var rootInstanceStackCursor = createCursor(NO_CONTEXT);
-
-function requiredContext(c) {
-  invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug " +
-      "in React. Please file an issue."
-  );
-  return c;
-}
 
-function getRootHostContainer() {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  return rootInstance;
+  if (typeof instance.componentDidMount === "function") {
+    workInProgress.effectTag |= Update;
+  }
 }
 
-function pushHostContainer(fiber, nextRootInstance) {
-  // Push current root instance onto the stack;
-  // This allows us to reset root when portals are popped.
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
+function resumeMountClassInstance(
+  workInProgress,
+  ctor,
+  newProps,
+  renderExpirationTime
+) {
+  var instance = workInProgress.stateNode;
 
-  // Finally, we need to push the host context to the stack.
-  // However, we can't just call getRootHostContext() and push it because
-  // we'd have a different number of entries on the stack depending on
-  // whether getRootHostContext() throws somewhere in renderer code or not.
-  // So we push an empty value first. This lets us safely unwind on errors.
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  var nextRootContext = getRootHostContext(nextRootInstance);
-  // Now that we know this function doesn't throw, replace it.
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, nextRootContext, fiber);
-}
+  var oldProps = workInProgress.memoizedProps;
+  instance.props = oldProps;
 
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
-}
+  var oldContext = instance.context;
+  var contextType = ctor.contextType;
+  var nextContext = void 0;
+  if (typeof contextType === "object" && contextType !== null) {
+    nextContext = readContext(contextType);
+  } else {
+    var nextLegacyUnmaskedContext = getUnmaskedContext(
+      workInProgress,
+      ctor,
+      true
+    );
+    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
+  }
 
-function getHostContext() {
-  var context = requiredContext(contextStackCursor$1.current);
-  return context;
-}
+  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
+  var hasNewLifecycles =
+    typeof getDerivedStateFromProps === "function" ||
+    typeof instance.getSnapshotBeforeUpdate === "function";
 
-function pushHostContext(fiber) {
-  var rootInstance = requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+  // Note: During these life-cycles, instance.props/instance.state are what
+  // ever the previously attempted to render - not the "current". However,
+  // during componentDidUpdate we pass the "current" props.
 
-  // Don't push this Fiber's context unless it's unique.
-  if (context === nextContext) {
-    return;
+  // In order to support react-lifecycles-compat polyfilled components,
+  // Unsafe lifecycles should not be invoked for components using the new APIs.
+  if (
+    !hasNewLifecycles &&
+    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
+      typeof instance.componentWillReceiveProps === "function")
+  ) {
+    if (oldProps !== newProps || oldContext !== nextContext) {
+      callComponentWillReceiveProps(
+        workInProgress,
+        instance,
+        newProps,
+        nextContext
+      );
+    }
   }
 
-  // Track the context and the Fiber that provided it.
-  // This enables us to pop only Fibers that provide unique contexts.
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, nextContext, fiber);
-}
+  resetHasForceUpdateBeforeProcessing();
 
-function popHostContext(fiber) {
-  // Do not pop unless this Fiber provided the current context.
-  // pushHostContext() only pushes Fibers that provide unique contexts.
-  if (contextFiberStackCursor.current !== fiber) {
-    return;
+  var oldState = workInProgress.memoizedState;
+  var newState = (instance.state = oldState);
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null) {
+    processUpdateQueue(
+      workInProgress,
+      updateQueue,
+      newProps,
+      instance,
+      renderExpirationTime
+    );
+    newState = workInProgress.memoizedState;
+  }
+  if (
+    oldProps === newProps &&
+    oldState === newState &&
+    !hasContextChanged() &&
+    !checkHasForceUpdateAfterProcessing()
+  ) {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidMount === "function") {
+      workInProgress.effectTag |= Update;
+    }
+    return false;
   }
 
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-}
-
-var commitTime = 0;
-var profilerStartTime = -1;
+  if (typeof getDerivedStateFromProps === "function") {
+    applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      newProps
+    );
+    newState = workInProgress.memoizedState;
+  }
 
-function getCommitTime() {
-  return commitTime;
-}
+  var shouldUpdate =
+    checkHasForceUpdateAfterProcessing() ||
+    checkShouldComponentUpdate(
+      workInProgress,
+      ctor,
+      oldProps,
+      newProps,
+      oldState,
+      newState,
+      nextContext
+    );
 
-function recordCommitTime() {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  commitTime = now$$1();
-}
+  if (shouldUpdate) {
+    // In order to support react-lifecycles-compat polyfilled components,
+    // Unsafe lifecycles should not be invoked for components using the new APIs.
+    if (
+      !hasNewLifecycles &&
+      (typeof instance.UNSAFE_componentWillMount === "function" ||
+        typeof instance.componentWillMount === "function")
+    ) {
+      startPhaseTimer(workInProgress, "componentWillMount");
+      if (typeof instance.componentWillMount === "function") {
+        instance.componentWillMount();
+      }
+      if (typeof instance.UNSAFE_componentWillMount === "function") {
+        instance.UNSAFE_componentWillMount();
+      }
+      stopPhaseTimer();
+    }
+    if (typeof instance.componentDidMount === "function") {
+      workInProgress.effectTag |= Update;
+    }
+  } else {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidMount === "function") {
+      workInProgress.effectTag |= Update;
+    }
 
-function startProfilerTimer(fiber) {
-  if (!enableProfilerTimer) {
-    return;
+    // If shouldComponentUpdate returned false, we should still update the
+    // memoized state to indicate that this work can be reused.
+    workInProgress.memoizedProps = newProps;
+    workInProgress.memoizedState = newState;
   }
 
-  profilerStartTime = now$$1();
+  // Update the existing instance's state, props, and context pointers even
+  // if shouldComponentUpdate returns false.
+  instance.props = newProps;
+  instance.state = newState;
+  instance.context = nextContext;
 
-  if (fiber.actualStartTime < 0) {
-    fiber.actualStartTime = now$$1();
-  }
+  return shouldUpdate;
 }
 
-function stopProfilerTimerIfRunning(fiber) {
-  if (!enableProfilerTimer) {
-    return;
-  }
-  profilerStartTime = -1;
-}
+// Invokes the update life-cycles and returns false if it shouldn't rerender.
+function updateClassInstance(
+  current,
+  workInProgress,
+  ctor,
+  newProps,
+  renderExpirationTime
+) {
+  var instance = workInProgress.stateNode;
 
-function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
-  if (!enableProfilerTimer) {
-    return;
-  }
+  var oldProps = workInProgress.memoizedProps;
+  instance.props =
+    workInProgress.type === workInProgress.elementType
+      ? oldProps
+      : resolveDefaultProps(workInProgress.type, oldProps);
 
-  if (profilerStartTime >= 0) {
-    var elapsedTime = now$$1() - profilerStartTime;
-    fiber.actualDuration += elapsedTime;
-    if (overrideBaseTime) {
-      fiber.selfBaseDuration = elapsedTime;
-    }
-    profilerStartTime = -1;
+  var oldContext = instance.context;
+  var contextType = ctor.contextType;
+  var nextContext = void 0;
+  if (typeof contextType === "object" && contextType !== null) {
+    nextContext = readContext(contextType);
+  } else {
+    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
+    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
   }
-}
 
-/*eslint-disable no-self-compare */
+  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
+  var hasNewLifecycles =
+    typeof getDerivedStateFromProps === "function" ||
+    typeof instance.getSnapshotBeforeUpdate === "function";
 
-var hasOwnProperty = Object.prototype.hasOwnProperty;
+  // Note: During these life-cycles, instance.props/instance.state are what
+  // ever the previously attempted to render - not the "current". However,
+  // during componentDidUpdate we pass the "current" props.
 
-/**
- * inlined Object.is polyfill to avoid requiring consumers ship their own
- * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
- */
-function is(x, y) {
-  // SameValue algorithm
-  if (x === y) {
-    // Steps 1-5, 7-10
-    // Steps 6.b-6.e: +0 != -0
-    // Added the nonzero y check to make Flow happy, but it is redundant
-    return x !== 0 || y !== 0 || 1 / x === 1 / y;
-  } else {
-    // Step 6.a: NaN == NaN
-    return x !== x && y !== y;
+  // In order to support react-lifecycles-compat polyfilled components,
+  // Unsafe lifecycles should not be invoked for components using the new APIs.
+  if (
+    !hasNewLifecycles &&
+    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
+      typeof instance.componentWillReceiveProps === "function")
+  ) {
+    if (oldProps !== newProps || oldContext !== nextContext) {
+      callComponentWillReceiveProps(
+        workInProgress,
+        instance,
+        newProps,
+        nextContext
+      );
+    }
   }
-}
 
-/**
- * Performs equality by iterating through keys on an object and returning false
- * when any key has values which are not strictly equal between the arguments.
- * Returns true when the values of all keys are strictly equal.
- */
-function shallowEqual(objA, objB) {
-  if (is(objA, objB)) {
-    return true;
+  resetHasForceUpdateBeforeProcessing();
+
+  var oldState = workInProgress.memoizedState;
+  var newState = (instance.state = oldState);
+  var updateQueue = workInProgress.updateQueue;
+  if (updateQueue !== null) {
+    processUpdateQueue(
+      workInProgress,
+      updateQueue,
+      newProps,
+      instance,
+      renderExpirationTime
+    );
+    newState = workInProgress.memoizedState;
   }
 
   if (
-    typeof objA !== "object" ||
-    objA === null ||
-    typeof objB !== "object" ||
-    objB === null
+    oldProps === newProps &&
+    oldState === newState &&
+    !hasContextChanged() &&
+    !checkHasForceUpdateAfterProcessing()
   ) {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Update;
+      }
+    }
+    if (typeof instance.getSnapshotBeforeUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Snapshot;
+      }
+    }
     return false;
   }
 
-  var keysA = Object.keys(objA);
-  var keysB = Object.keys(objB);
-
-  if (keysA.length !== keysB.length) {
-    return false;
+  if (typeof getDerivedStateFromProps === "function") {
+    applyDerivedStateFromProps(
+      workInProgress,
+      ctor,
+      getDerivedStateFromProps,
+      newProps
+    );
+    newState = workInProgress.memoizedState;
   }
 
-  // Test for A's keys different from B.
-  for (var i = 0; i < keysA.length; i++) {
+  var shouldUpdate =
+    checkHasForceUpdateAfterProcessing() ||
+    checkShouldComponentUpdate(
+      workInProgress,
+      ctor,
+      oldProps,
+      newProps,
+      oldState,
+      newState,
+      nextContext
+    );
+
+  if (shouldUpdate) {
+    // In order to support react-lifecycles-compat polyfilled components,
+    // Unsafe lifecycles should not be invoked for components using the new APIs.
     if (
-      !hasOwnProperty.call(objB, keysA[i]) ||
-      !is(objA[keysA[i]], objB[keysA[i]])
+      !hasNewLifecycles &&
+      (typeof instance.UNSAFE_componentWillUpdate === "function" ||
+        typeof instance.componentWillUpdate === "function")
     ) {
-      return false;
-    }
-  }
-
-  return true;
-}
-
-function resolveDefaultProps(Component, baseProps) {
-  if (Component && Component.defaultProps) {
-    // Resolve default props. Taken from ReactElement
-    var props = Object.assign({}, baseProps);
-    var defaultProps = Component.defaultProps;
-    for (var propName in defaultProps) {
-      if (props[propName] === undefined) {
-        props[propName] = defaultProps[propName];
+      startPhaseTimer(workInProgress, "componentWillUpdate");
+      if (typeof instance.componentWillUpdate === "function") {
+        instance.componentWillUpdate(newProps, newState, nextContext);
+      }
+      if (typeof instance.UNSAFE_componentWillUpdate === "function") {
+        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
       }
+      stopPhaseTimer();
     }
-    return props;
-  }
-  return baseProps;
-}
-
-function readLazyComponentType(lazyComponent) {
-  var status = lazyComponent._status;
-  var result = lazyComponent._result;
-  switch (status) {
-    case Resolved: {
-      var Component = result;
-      return Component;
+    if (typeof instance.componentDidUpdate === "function") {
+      workInProgress.effectTag |= Update;
     }
-    case Rejected: {
-      var error = result;
-      throw error;
+    if (typeof instance.getSnapshotBeforeUpdate === "function") {
+      workInProgress.effectTag |= Snapshot;
     }
-    case Pending: {
-      var thenable = result;
-      throw thenable;
+  } else {
+    // If an update was already in progress, we should schedule an Update
+    // effect even though we're bailing out, so that cWU/cDU are called.
+    if (typeof instance.componentDidUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Update;
+      }
     }
-    default: {
-      lazyComponent._status = Pending;
-      var ctor = lazyComponent._ctor;
-      var _thenable = ctor();
-      _thenable.then(
-        function(moduleObject) {
-          if (lazyComponent._status === Pending) {
-            var defaultExport = moduleObject.default;
-            {
-              if (defaultExport === undefined) {
-                warning$1(
-                  false,
-                  "lazy: Expected the result of a dynamic import() call. " +
-                    "Instead received: %s\n\nYour code should look like: \n  " +
-                    "const MyComponent = lazy(() => import('./MyComponent'))",
-                  moduleObject
-                );
-              }
-            }
-            lazyComponent._status = Resolved;
-            lazyComponent._result = defaultExport;
-          }
-        },
-        function(error) {
-          if (lazyComponent._status === Pending) {
-            lazyComponent._status = Rejected;
-            lazyComponent._result = error;
-          }
-        }
-      );
-      lazyComponent._result = _thenable;
-      throw _thenable;
+    if (typeof instance.getSnapshotBeforeUpdate === "function") {
+      if (
+        oldProps !== current.memoizedProps ||
+        oldState !== current.memoizedState
+      ) {
+        workInProgress.effectTag |= Snapshot;
+      }
     }
+
+    // If shouldComponentUpdate returned false, we should still update the
+    // memoized props/state to indicate that this work can be reused.
+    workInProgress.memoizedProps = newProps;
+    workInProgress.memoizedState = newState;
   }
-}
 
-var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner;
+  // Update the existing instance's state, props, and context pointers even
+  // if shouldComponentUpdate returns false.
+  instance.props = newProps;
+  instance.state = newState;
+  instance.context = nextContext;
 
-function readContext$1(contextType) {
-  var dispatcher = ReactCurrentOwner$4.currentDispatcher;
-  return dispatcher.readContext(contextType);
+  return shouldUpdate;
 }
 
-var fakeInternalInstance = {};
-var isArray$1 = Array.isArray;
-
-// React.Component uses a shared frozen object by default.
-// We'll use it to determine whether we need to initialize legacy refs.
-var emptyRefsObject = new React.Component().refs;
-
-var didWarnAboutStateAssignmentForComponent = void 0;
-var didWarnAboutUninitializedState = void 0;
-var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = void 0;
-var didWarnAboutLegacyLifecyclesAndDerivedState = void 0;
-var didWarnAboutUndefinedDerivedState = void 0;
-var warnOnUndefinedDerivedState = void 0;
-var warnOnInvalidCallback = void 0;
-var didWarnAboutDirectlyAssigningPropsToState = void 0;
-var didWarnAboutContextTypeAndContextTypes = void 0;
-var didWarnAboutInvalidateContextType = void 0;
+var didWarnAboutMaps = void 0;
+var didWarnAboutGenerators = void 0;
+var didWarnAboutStringRefInStrictMode = void 0;
+var ownerHasKeyUseWarning = void 0;
+var ownerHasFunctionTypeWarning = void 0;
+var warnForMissingKey = function(child) {};
 
 {
-  didWarnAboutStateAssignmentForComponent = new Set();
-  didWarnAboutUninitializedState = new Set();
-  didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();
-  didWarnAboutLegacyLifecyclesAndDerivedState = new Set();
-  didWarnAboutDirectlyAssigningPropsToState = new Set();
-  didWarnAboutUndefinedDerivedState = new Set();
-  didWarnAboutContextTypeAndContextTypes = new Set();
-  didWarnAboutInvalidateContextType = new Set();
+  didWarnAboutMaps = false;
+  didWarnAboutGenerators = false;
+  didWarnAboutStringRefInStrictMode = {};
 
-  var didWarnOnInvalidCallback = new Set();
+  /**
+   * Warn if there's no key explicitly set on dynamic arrays of children or
+   * object keys are not valid. This allows us to keep track of children between
+   * updates.
+   */
+  ownerHasKeyUseWarning = {};
+  ownerHasFunctionTypeWarning = {};
 
-  warnOnInvalidCallback = function(callback, callerName) {
-    if (callback === null || typeof callback === "function") {
+  warnForMissingKey = function(child) {
+    if (child === null || typeof child !== "object") {
       return;
     }
-    var key = callerName + "_" + callback;
-    if (!didWarnOnInvalidCallback.has(key)) {
-      didWarnOnInvalidCallback.add(key);
-      warningWithoutStack$1(
-        false,
-        "%s(...): Expected the last optional `callback` argument to be a " +
-          "function. Instead received: %s.",
-        callerName,
-        callback
-      );
+    if (!child._store || child._store.validated || child.key != null) {
+      return;
+    }
+    invariant(
+      typeof child._store === "object",
+      "React Component in warnForMissingKey should have a _store. " +
+        "This error is likely caused by a bug in React. Please file an issue."
+    );
+    child._store.validated = true;
+
+    var currentComponentErrorInfo =
+      "Each child in a list should have a unique " +
+      '"key" prop. See https://fb.me/react-warning-keys for ' +
+      "more information." +
+      getCurrentFiberStackInDev();
+    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
+      return;
     }
+    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
+
+    warning$1(
+      false,
+      "Each child in a list should have a unique " +
+        '"key" prop. See https://fb.me/react-warning-keys for ' +
+        "more information."
+    );
   };
+}
 
-  warnOnUndefinedDerivedState = function(type, partialState) {
-    if (partialState === undefined) {
-      var componentName = getComponentName(type) || "Component";
-      if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
-        didWarnAboutUndefinedDerivedState.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " +
-            "You have returned undefined.",
-          componentName
-        );
+var isArray = Array.isArray;
+
+function coerceRef(returnFiber, current$$1, element) {
+  var mixedRef = element.ref;
+  if (
+    mixedRef !== null &&
+    typeof mixedRef !== "function" &&
+    typeof mixedRef !== "object"
+  ) {
+    {
+      if (returnFiber.mode & StrictMode) {
+        var componentName = getComponentName(returnFiber.type) || "Component";
+        if (!didWarnAboutStringRefInStrictMode[componentName]) {
+          warningWithoutStack$1(
+            false,
+            'A string ref, "%s", has been found within a strict mode tree. ' +
+              "String refs are a source of potential bugs and should be avoided. " +
+              "We recommend using createRef() instead." +
+              "\n%s" +
+              "\n\nLearn more about using refs safely here:" +
+              "\nhttps://fb.me/react-strict-mode-string-ref",
+            mixedRef,
+            getStackByFiberInDevAndProd(returnFiber)
+          );
+          didWarnAboutStringRefInStrictMode[componentName] = true;
+        }
       }
     }
-  };
 
-  // This is so gross but it's at least non-critical and can be removed if
-  // it causes problems. This is meant to give a nicer error message for
-  // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
-  // ...)) which otherwise throws a "_processChildContext is not a function"
-  // exception.
-  Object.defineProperty(fakeInternalInstance, "_processChildContext", {
-    enumerable: false,
-    value: function() {
+    if (element._owner) {
+      var owner = element._owner;
+      var inst = void 0;
+      if (owner) {
+        var ownerFiber = owner;
+        invariant(
+          ownerFiber.tag === ClassComponent,
+          "Function components cannot have refs. " +
+            "Did you mean to use React.forwardRef()?"
+        );
+        inst = ownerFiber.stateNode;
+      }
       invariant(
-        false,
-        "_processChildContext is not available in React 16+. This likely " +
-          "means you have multiple copies of React and are attempting to nest " +
-          "a React 15 tree inside a React 16 tree using " +
-          "unstable_renderSubtreeIntoContainer, which isn't supported. Try " +
-          "to make sure you have only one copy of React (and ideally, switch " +
-          "to ReactDOM.createPortal)."
+        inst,
+        "Missing owner for string ref %s. This error is likely caused by a " +
+          "bug in React. Please file an issue.",
+        mixedRef
+      );
+      var stringRef = "" + mixedRef;
+      // Check if previous string ref matches new string ref
+      if (
+        current$$1 !== null &&
+        current$$1.ref !== null &&
+        typeof current$$1.ref === "function" &&
+        current$$1.ref._stringRef === stringRef
+      ) {
+        return current$$1.ref;
+      }
+      var ref = function(value) {
+        var refs = inst.refs;
+        if (refs === emptyRefsObject) {
+          // This is a lazy pooled frozen object, so we need to initialize.
+          refs = inst.refs = {};
+        }
+        if (value === null) {
+          delete refs[stringRef];
+        } else {
+          refs[stringRef] = value;
+        }
+      };
+      ref._stringRef = stringRef;
+      return ref;
+    } else {
+      invariant(
+        typeof mixedRef === "string",
+        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
+      );
+      invariant(
+        element._owner,
+        "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" +
+          " the following reasons:\n" +
+          "1. You may be adding a ref to a function component\n" +
+          "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
+          "3. You have multiple copies of React loaded\n" +
+          "See https://fb.me/react-refs-must-have-owner for more information.",
+        mixedRef
       );
     }
-  });
-  Object.freeze(fakeInternalInstance);
+  }
+  return mixedRef;
 }
 
-function applyDerivedStateFromProps(
-  workInProgress,
-  ctor,
-  getDerivedStateFromProps,
-  nextProps
-) {
-  var prevState = workInProgress.memoizedState;
-
-  {
-    if (
-      debugRenderPhaseSideEffects ||
-      (debugRenderPhaseSideEffectsForStrictMode &&
-        workInProgress.mode & StrictMode)
-    ) {
-      // Invoke the function an extra time to help detect side-effects.
-      getDerivedStateFromProps(nextProps, prevState);
+function throwOnInvalidObjectType(returnFiber, newChild) {
+  if (returnFiber.type !== "textarea") {
+    var addendum = "";
+    {
+      addendum =
+        " If you meant to render a collection of children, use an array " +
+        "instead." +
+        getCurrentFiberStackInDev();
     }
+    invariant(
+      false,
+      "Objects are not valid as a React child (found: %s).%s",
+      Object.prototype.toString.call(newChild) === "[object Object]"
+        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
+        : newChild,
+      addendum
+    );
   }
+}
 
-  var partialState = getDerivedStateFromProps(nextProps, prevState);
+function warnOnFunctionType() {
+  var currentComponentErrorInfo =
+    "Functions are not valid as a React child. This may happen if " +
+    "you return a Component instead of <Component /> from render. " +
+    "Or maybe you meant to call this function rather than return it." +
+    getCurrentFiberStackInDev();
 
-  {
-    warnOnUndefinedDerivedState(ctor, partialState);
+  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
+    return;
   }
-  // Merge the partial state and the previous state.
-  var memoizedState =
-    partialState === null || partialState === undefined
-      ? prevState
-      : Object.assign({}, prevState, partialState);
-  workInProgress.memoizedState = memoizedState;
+  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
 
-  // Once the update queue is empty, persist the derived state onto the
-  // base state.
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null && workInProgress.expirationTime === NoWork) {
-    updateQueue.baseState = memoizedState;
-  }
+  warning$1(
+    false,
+    "Functions are not valid as a React child. This may happen if " +
+      "you return a Component instead of <Component /> from render. " +
+      "Or maybe you meant to call this function rather than return it."
+  );
 }
 
-var classComponentUpdater = {
-  isMounted: isMounted,
-  enqueueSetState: function(inst, payload, callback) {
-    var fiber = get$1(inst);
-    var currentTime = requestCurrentTime();
-    var expirationTime = computeExpirationForFiber(currentTime, fiber);
-
-    var update = createUpdate(expirationTime);
-    update.payload = payload;
-    if (callback !== undefined && callback !== null) {
-      {
-        warnOnInvalidCallback(callback, "setState");
-      }
-      update.callback = callback;
+// This wrapper function exists because I expect to clone the code in each path
+// to be able to optimize each path individually by branching early. This needs
+// a compiler or we can do it manually. Helpers that don't need this branching
+// live outside of this function.
+function ChildReconciler(shouldTrackSideEffects) {
+  function deleteChild(returnFiber, childToDelete) {
+    if (!shouldTrackSideEffects) {
+      // Noop.
+      return;
+    }
+    // Deletions are added in reversed order so we add it to the front.
+    // At this point, the return fiber's effect list is empty except for
+    // deletions, so we can just append the deletion to the list. The remaining
+    // effects aren't added until the complete phase. Once we implement
+    // resuming, this may not be true.
+    var last = returnFiber.lastEffect;
+    if (last !== null) {
+      last.nextEffect = childToDelete;
+      returnFiber.lastEffect = childToDelete;
+    } else {
+      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
+    }
+    childToDelete.nextEffect = null;
+    childToDelete.effectTag = Deletion;
+  }
+
+  function deleteRemainingChildren(returnFiber, currentFirstChild) {
+    if (!shouldTrackSideEffects) {
+      // Noop.
+      return null;
     }
 
-    flushPassiveEffects();
-    enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
-  },
-  enqueueReplaceState: function(inst, payload, callback) {
-    var fiber = get$1(inst);
-    var currentTime = requestCurrentTime();
-    var expirationTime = computeExpirationForFiber(currentTime, fiber);
+    // TODO: For the shouldClone case, this could be micro-optimized a bit by
+    // assuming that after the first child we've already added everything.
+    var childToDelete = currentFirstChild;
+    while (childToDelete !== null) {
+      deleteChild(returnFiber, childToDelete);
+      childToDelete = childToDelete.sibling;
+    }
+    return null;
+  }
 
-    var update = createUpdate(expirationTime);
-    update.tag = ReplaceState;
-    update.payload = payload;
+  function mapRemainingChildren(returnFiber, currentFirstChild) {
+    // Add the remaining children to a temporary map so that we can find them by
+    // keys quickly. Implicit (null) keys get added to this set with their index
+    var existingChildren = new Map();
 
-    if (callback !== undefined && callback !== null) {
-      {
-        warnOnInvalidCallback(callback, "replaceState");
+    var existingChild = currentFirstChild;
+    while (existingChild !== null) {
+      if (existingChild.key !== null) {
+        existingChildren.set(existingChild.key, existingChild);
+      } else {
+        existingChildren.set(existingChild.index, existingChild);
       }
-      update.callback = callback;
+      existingChild = existingChild.sibling;
     }
+    return existingChildren;
+  }
 
-    flushPassiveEffects();
-    enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
-  },
-  enqueueForceUpdate: function(inst, callback) {
-    var fiber = get$1(inst);
-    var currentTime = requestCurrentTime();
-    var expirationTime = computeExpirationForFiber(currentTime, fiber);
-
-    var update = createUpdate(expirationTime);
-    update.tag = ForceUpdate;
+  function useFiber(fiber, pendingProps, expirationTime) {
+    // We currently set sibling to null and index to 0 here because it is easy
+    // to forget to do before returning it. E.g. for the single child case.
+    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
+    clone.index = 0;
+    clone.sibling = null;
+    return clone;
+  }
 
-    if (callback !== undefined && callback !== null) {
-      {
-        warnOnInvalidCallback(callback, "forceUpdate");
+  function placeChild(newFiber, lastPlacedIndex, newIndex) {
+    newFiber.index = newIndex;
+    if (!shouldTrackSideEffects) {
+      // Noop.
+      return lastPlacedIndex;
+    }
+    var current$$1 = newFiber.alternate;
+    if (current$$1 !== null) {
+      var oldIndex = current$$1.index;
+      if (oldIndex < lastPlacedIndex) {
+        // This is a move.
+        newFiber.effectTag = Placement;
+        return lastPlacedIndex;
+      } else {
+        // This item can stay in place.
+        return oldIndex;
       }
-      update.callback = callback;
+    } else {
+      // This is an insertion.
+      newFiber.effectTag = Placement;
+      return lastPlacedIndex;
     }
-
-    flushPassiveEffects();
-    enqueueUpdate(fiber, update);
-    scheduleWork(fiber, expirationTime);
   }
-};
-
-function checkShouldComponentUpdate(
-  workInProgress,
-  ctor,
-  oldProps,
-  newProps,
-  oldState,
-  newState,
-  nextContext
-) {
-  var instance = workInProgress.stateNode;
-  if (typeof instance.shouldComponentUpdate === "function") {
-    startPhaseTimer(workInProgress, "shouldComponentUpdate");
-    var shouldUpdate = instance.shouldComponentUpdate(
-      newProps,
-      newState,
-      nextContext
-    );
-    stopPhaseTimer();
 
-    {
-      !(shouldUpdate !== undefined)
-        ? warningWithoutStack$1(
-            false,
-            "%s.shouldComponentUpdate(): Returned undefined instead of a " +
-              "boolean value. Make sure to return true or false.",
-            getComponentName(ctor) || "Component"
-          )
-        : void 0;
+  function placeSingleChild(newFiber) {
+    // This is simpler for the single child case. We only need to do a
+    // placement for inserting new children.
+    if (shouldTrackSideEffects && newFiber.alternate === null) {
+      newFiber.effectTag = Placement;
     }
-
-    return shouldUpdate;
+    return newFiber;
   }
 
-  if (ctor.prototype && ctor.prototype.isPureReactComponent) {
-    return (
-      !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)
-    );
+  function updateTextNode(
+    returnFiber,
+    current$$1,
+    textContent,
+    expirationTime
+  ) {
+    if (current$$1 === null || current$$1.tag !== HostText) {
+      // Insert
+      var created = createFiberFromText(
+        textContent,
+        returnFiber.mode,
+        expirationTime
+      );
+      created.return = returnFiber;
+      return created;
+    } else {
+      // Update
+      var existing = useFiber(current$$1, textContent, expirationTime);
+      existing.return = returnFiber;
+      return existing;
+    }
   }
 
-  return true;
-}
-
-function checkClassInstance(workInProgress, ctor, newProps) {
-  var instance = workInProgress.stateNode;
-  {
-    var name = getComponentName(ctor) || "Component";
-    var renderPresent = instance.render;
-
-    if (!renderPresent) {
-      if (ctor.prototype && typeof ctor.prototype.render === "function") {
-        warningWithoutStack$1(
-          false,
-          "%s(...): No `render` method found on the returned component " +
-            "instance: did you accidentally return an object from the constructor?",
-          name
-        );
-      } else {
-        warningWithoutStack$1(
-          false,
-          "%s(...): No `render` method found on the returned component " +
-            "instance: you may have forgotten to define `render`.",
-          name
-        );
+  function updateElement(returnFiber, current$$1, element, expirationTime) {
+    if (current$$1 !== null && current$$1.elementType === element.type) {
+      // Move based on index
+      var existing = useFiber(current$$1, element.props, expirationTime);
+      existing.ref = coerceRef(returnFiber, current$$1, element);
+      existing.return = returnFiber;
+      {
+        existing._debugSource = element._source;
+        existing._debugOwner = element._owner;
       }
-    }
-
-    var noGetInitialStateOnES6 =
-      !instance.getInitialState ||
-      instance.getInitialState.isReactClassApproved ||
-      instance.state;
-    !noGetInitialStateOnES6
-      ? warningWithoutStack$1(
-          false,
-          "getInitialState was defined on %s, a plain JavaScript class. " +
-            "This is only supported for classes created using React.createClass. " +
-            "Did you mean to define a state property instead?",
-          name
-        )
-      : void 0;
-    var noGetDefaultPropsOnES6 =
-      !instance.getDefaultProps ||
-      instance.getDefaultProps.isReactClassApproved;
-    !noGetDefaultPropsOnES6
-      ? warningWithoutStack$1(
-          false,
-          "getDefaultProps was defined on %s, a plain JavaScript class. " +
-            "This is only supported for classes created using React.createClass. " +
-            "Use a static property to define defaultProps instead.",
-          name
-        )
-      : void 0;
-    var noInstancePropTypes = !instance.propTypes;
-    !noInstancePropTypes
-      ? warningWithoutStack$1(
-          false,
-          "propTypes was defined as an instance property on %s. Use a static " +
-            "property to define propTypes instead.",
-          name
-        )
-      : void 0;
-    var noInstanceContextType = !instance.contextType;
-    !noInstanceContextType
-      ? warningWithoutStack$1(
-          false,
-          "contextType was defined as an instance property on %s. Use a static " +
-            "property to define contextType instead.",
-          name
-        )
-      : void 0;
-    var noInstanceContextTypes = !instance.contextTypes;
-    !noInstanceContextTypes
-      ? warningWithoutStack$1(
-          false,
-          "contextTypes was defined as an instance property on %s. Use a static " +
-            "property to define contextTypes instead.",
-          name
-        )
-      : void 0;
-
-    if (
-      ctor.contextType &&
-      ctor.contextTypes &&
-      !didWarnAboutContextTypeAndContextTypes.has(ctor)
-    ) {
-      didWarnAboutContextTypeAndContextTypes.add(ctor);
-      warningWithoutStack$1(
-        false,
-        "%s declares both contextTypes and contextType static properties. " +
-          "The legacy contextTypes property will be ignored.",
-        name
+      return existing;
+    } else {
+      // Insert
+      var created = createFiberFromElement(
+        element,
+        returnFiber.mode,
+        expirationTime
       );
+      created.ref = coerceRef(returnFiber, current$$1, element);
+      created.return = returnFiber;
+      return created;
     }
+  }
 
-    var noComponentShouldUpdate =
-      typeof instance.componentShouldUpdate !== "function";
-    !noComponentShouldUpdate
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " +
-            "The name is phrased as a question because the function is " +
-            "expected to return a value.",
-          name
-        )
-      : void 0;
+  function updatePortal(returnFiber, current$$1, portal, expirationTime) {
     if (
-      ctor.prototype &&
-      ctor.prototype.isPureReactComponent &&
-      typeof instance.shouldComponentUpdate !== "undefined"
+      current$$1 === null ||
+      current$$1.tag !== HostPortal ||
+      current$$1.stateNode.containerInfo !== portal.containerInfo ||
+      current$$1.stateNode.implementation !== portal.implementation
     ) {
-      warningWithoutStack$1(
-        false,
-        "%s has a method called shouldComponentUpdate(). " +
-          "shouldComponentUpdate should not be used when extending React.PureComponent. " +
-          "Please extend React.Component if shouldComponentUpdate is used.",
-        getComponentName(ctor) || "A pure component"
+      // Insert
+      var created = createFiberFromPortal(
+        portal,
+        returnFiber.mode,
+        expirationTime
       );
-    }
-    var noComponentDidUnmount =
-      typeof instance.componentDidUnmount !== "function";
-    !noComponentDidUnmount
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentDidUnmount(). But there is no such lifecycle method. " +
-            "Did you mean componentWillUnmount()?",
-          name
-        )
-      : void 0;
-    var noComponentDidReceiveProps =
-      typeof instance.componentDidReceiveProps !== "function";
-    !noComponentDidReceiveProps
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentDidReceiveProps(). But there is no such lifecycle method. " +
-            "If you meant to update the state in response to changing props, " +
-            "use componentWillReceiveProps(). If you meant to fetch data or " +
-            "run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
-          name
-        )
-      : void 0;
-    var noComponentWillRecieveProps =
-      typeof instance.componentWillRecieveProps !== "function";
-    !noComponentWillRecieveProps
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
-          name
-        )
-      : void 0;
-    var noUnsafeComponentWillRecieveProps =
-      typeof instance.UNSAFE_componentWillRecieveProps !== "function";
-    !noUnsafeComponentWillRecieveProps
-      ? warningWithoutStack$1(
-          false,
-          "%s has a method called " +
-            "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
-          name
-        )
-      : void 0;
-    var hasMutatedProps = instance.props !== newProps;
-    !(instance.props === undefined || !hasMutatedProps)
-      ? warningWithoutStack$1(
-          false,
-          "%s(...): When calling super() in `%s`, make sure to pass " +
-            "up the same props that your component's constructor was passed.",
-          name,
-          name
-        )
-      : void 0;
-    var noInstanceDefaultProps = !instance.defaultProps;
-    !noInstanceDefaultProps
-      ? warningWithoutStack$1(
-          false,
-          "Setting defaultProps as an instance property on %s is not supported and will be ignored." +
-            " Instead, define defaultProps as a static property on %s.",
-          name,
-          name
-        )
-      : void 0;
-
-    if (
-      typeof instance.getSnapshotBeforeUpdate === "function" &&
-      typeof instance.componentDidUpdate !== "function" &&
-      !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)
-    ) {
-      didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
-      warningWithoutStack$1(
-        false,
-        "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " +
-          "This component defines getSnapshotBeforeUpdate() only.",
-        getComponentName(ctor)
+      created.return = returnFiber;
+      return created;
+    } else {
+      // Update
+      var existing = useFiber(
+        current$$1,
+        portal.children || [],
+        expirationTime
       );
+      existing.return = returnFiber;
+      return existing;
     }
+  }
 
-    var noInstanceGetDerivedStateFromProps =
-      typeof instance.getDerivedStateFromProps !== "function";
-    !noInstanceGetDerivedStateFromProps
-      ? warningWithoutStack$1(
-          false,
-          "%s: getDerivedStateFromProps() is defined as an instance method " +
-            "and will be ignored. Instead, declare it as a static method.",
-          name
-        )
-      : void 0;
-    var noInstanceGetDerivedStateFromCatch =
-      typeof instance.getDerivedStateFromError !== "function";
-    !noInstanceGetDerivedStateFromCatch
-      ? warningWithoutStack$1(
-          false,
-          "%s: getDerivedStateFromError() is defined as an instance method " +
-            "and will be ignored. Instead, declare it as a static method.",
-          name
-        )
-      : void 0;
-    var noStaticGetSnapshotBeforeUpdate =
-      typeof ctor.getSnapshotBeforeUpdate !== "function";
-    !noStaticGetSnapshotBeforeUpdate
-      ? warningWithoutStack$1(
-          false,
-          "%s: getSnapshotBeforeUpdate() is defined as a static method " +
-            "and will be ignored. Instead, declare it as an instance method.",
-          name
-        )
-      : void 0;
-    var _state = instance.state;
-    if (_state && (typeof _state !== "object" || isArray$1(_state))) {
-      warningWithoutStack$1(
-        false,
-        "%s.state: must be set to an object or null",
-        name
+  function updateFragment(
+    returnFiber,
+    current$$1,
+    fragment,
+    expirationTime,
+    key
+  ) {
+    if (current$$1 === null || current$$1.tag !== Fragment) {
+      // Insert
+      var created = createFiberFromFragment(
+        fragment,
+        returnFiber.mode,
+        expirationTime,
+        key
       );
-    }
-    if (typeof instance.getChildContext === "function") {
-      !(typeof ctor.childContextTypes === "object")
-        ? warningWithoutStack$1(
-            false,
-            "%s.getChildContext(): childContextTypes must be defined in order to " +
-              "use getChildContext().",
-            name
-          )
-        : void 0;
+      created.return = returnFiber;
+      return created;
+    } else {
+      // Update
+      var existing = useFiber(current$$1, fragment, expirationTime);
+      existing.return = returnFiber;
+      return existing;
     }
   }
-}
 
-function adoptClassInstance(workInProgress, instance) {
-  instance.updater = classComponentUpdater;
-  workInProgress.stateNode = instance;
-  // The instance needs access to the fiber so that it can schedule updates
-  set(instance, workInProgress);
-  {
-    instance._reactInternalInstance = fakeInternalInstance;
-  }
-}
+  function createChild(returnFiber, newChild, expirationTime) {
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      // Text nodes don't have keys. If the previous node is implicitly keyed
+      // we can continue to replace it without aborting even if it is not a text
+      // node.
+      var created = createFiberFromText(
+        "" + newChild,
+        returnFiber.mode,
+        expirationTime
+      );
+      created.return = returnFiber;
+      return created;
+    }
 
-function constructClassInstance(
-  workInProgress,
-  ctor,
-  props,
-  renderExpirationTime
-) {
-  var isLegacyContextConsumer = false;
-  var unmaskedContext = emptyContextObject;
-  var context = null;
-  var contextType = ctor.contextType;
-  if (typeof contextType === "object" && contextType !== null) {
-    {
-      if (
-        contextType.$$typeof !== REACT_CONTEXT_TYPE &&
-        !didWarnAboutInvalidateContextType.has(ctor)
-      ) {
-        didWarnAboutInvalidateContextType.add(ctor);
-        warningWithoutStack$1(
-          false,
-          "%s defines an invalid contextType. " +
-            "contextType should point to the Context object returned by React.createContext(). " +
-            "Did you accidentally pass the Context.Provider instead?",
-          getComponentName(ctor) || "Component"
+    if (typeof newChild === "object" && newChild !== null) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE: {
+          var _created = createFiberFromElement(
+            newChild,
+            returnFiber.mode,
+            expirationTime
+          );
+          _created.ref = coerceRef(returnFiber, null, newChild);
+          _created.return = returnFiber;
+          return _created;
+        }
+        case REACT_PORTAL_TYPE: {
+          var _created2 = createFiberFromPortal(
+            newChild,
+            returnFiber.mode,
+            expirationTime
+          );
+          _created2.return = returnFiber;
+          return _created2;
+        }
+      }
+
+      if (isArray(newChild) || getIteratorFn(newChild)) {
+        var _created3 = createFiberFromFragment(
+          newChild,
+          returnFiber.mode,
+          expirationTime,
+          null
         );
+        _created3.return = returnFiber;
+        return _created3;
       }
-    }
 
-    context = readContext$1(contextType);
-  } else {
-    unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-    var contextTypes = ctor.contextTypes;
-    isLegacyContextConsumer =
-      contextTypes !== null && contextTypes !== undefined;
-    context = isLegacyContextConsumer
-      ? getMaskedContext(workInProgress, unmaskedContext)
-      : emptyContextObject;
-  }
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
 
-  // Instantiate twice to help detect side-effects.
-  {
-    if (
-      debugRenderPhaseSideEffects ||
-      (debugRenderPhaseSideEffectsForStrictMode &&
-        workInProgress.mode & StrictMode)
-    ) {
-      new ctor(props, context); // eslint-disable-line no-new
+    {
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
+      }
     }
+
+    return null;
   }
 
-  var instance = new ctor(props, context);
-  var state = (workInProgress.memoizedState =
-    instance.state !== null && instance.state !== undefined
-      ? instance.state
-      : null);
-  adoptClassInstance(workInProgress, instance);
+  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
+    // Update the fiber if the keys match, otherwise return null.
 
-  {
-    if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
-      var componentName = getComponentName(ctor) || "Component";
-      if (!didWarnAboutUninitializedState.has(componentName)) {
-        didWarnAboutUninitializedState.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "`%s` uses `getDerivedStateFromProps` but its initial state is " +
-            "%s. This is not recommended. Instead, define the initial state by " +
-            "assigning an object to `this.state` in the constructor of `%s`. " +
-            "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
-          componentName,
-          instance.state === null ? "null" : "undefined",
-          componentName
-        );
+    var key = oldFiber !== null ? oldFiber.key : null;
+
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      // Text nodes don't have keys. If the previous node is implicitly keyed
+      // we can continue to replace it without aborting even if it is not a text
+      // node.
+      if (key !== null) {
+        return null;
       }
+      return updateTextNode(
+        returnFiber,
+        oldFiber,
+        "" + newChild,
+        expirationTime
+      );
     }
 
-    // If new component APIs are defined, "unsafe" lifecycles won't be called.
-    // Warn about these lifecycles if they are present.
-    // Don't warn about react-lifecycles-compat polyfilled methods though.
-    if (
-      typeof ctor.getDerivedStateFromProps === "function" ||
-      typeof instance.getSnapshotBeforeUpdate === "function"
-    ) {
-      var foundWillMountName = null;
-      var foundWillReceivePropsName = null;
-      var foundWillUpdateName = null;
-      if (
-        typeof instance.componentWillMount === "function" &&
-        instance.componentWillMount.__suppressDeprecationWarning !== true
-      ) {
-        foundWillMountName = "componentWillMount";
-      } else if (typeof instance.UNSAFE_componentWillMount === "function") {
-        foundWillMountName = "UNSAFE_componentWillMount";
+    if (typeof newChild === "object" && newChild !== null) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE: {
+          if (newChild.key === key) {
+            if (newChild.type === REACT_FRAGMENT_TYPE) {
+              return updateFragment(
+                returnFiber,
+                oldFiber,
+                newChild.props.children,
+                expirationTime,
+                key
+              );
+            }
+            return updateElement(
+              returnFiber,
+              oldFiber,
+              newChild,
+              expirationTime
+            );
+          } else {
+            return null;
+          }
+        }
+        case REACT_PORTAL_TYPE: {
+          if (newChild.key === key) {
+            return updatePortal(
+              returnFiber,
+              oldFiber,
+              newChild,
+              expirationTime
+            );
+          } else {
+            return null;
+          }
+        }
       }
-      if (
-        typeof instance.componentWillReceiveProps === "function" &&
-        instance.componentWillReceiveProps.__suppressDeprecationWarning !== true
-      ) {
-        foundWillReceivePropsName = "componentWillReceiveProps";
-      } else if (
-        typeof instance.UNSAFE_componentWillReceiveProps === "function"
-      ) {
-        foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
+
+      if (isArray(newChild) || getIteratorFn(newChild)) {
+        if (key !== null) {
+          return null;
+        }
+
+        return updateFragment(
+          returnFiber,
+          oldFiber,
+          newChild,
+          expirationTime,
+          null
+        );
       }
-      if (
-        typeof instance.componentWillUpdate === "function" &&
-        instance.componentWillUpdate.__suppressDeprecationWarning !== true
-      ) {
-        foundWillUpdateName = "componentWillUpdate";
-      } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
-        foundWillUpdateName = "UNSAFE_componentWillUpdate";
+
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
+
+    {
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
       }
-      if (
-        foundWillMountName !== null ||
-        foundWillReceivePropsName !== null ||
-        foundWillUpdateName !== null
-      ) {
-        var _componentName = getComponentName(ctor) || "Component";
-        var newApiName =
-          typeof ctor.getDerivedStateFromProps === "function"
-            ? "getDerivedStateFromProps()"
-            : "getSnapshotBeforeUpdate()";
-        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
-          didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
-          warningWithoutStack$1(
-            false,
-            "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" +
-              "%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\n" +
-              "The above lifecycles should be removed. Learn more about this warning here:\n" +
-              "https://fb.me/react-async-component-lifecycle-hooks",
-            _componentName,
-            newApiName,
-            foundWillMountName !== null ? "\n  " + foundWillMountName : "",
-            foundWillReceivePropsName !== null
-              ? "\n  " + foundWillReceivePropsName
-              : "",
-            foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : ""
+    }
+
+    return null;
+  }
+
+  function updateFromMap(
+    existingChildren,
+    returnFiber,
+    newIdx,
+    newChild,
+    expirationTime
+  ) {
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      // Text nodes don't have keys, so we neither have to check the old nor
+      // new node for the key. If both are text nodes, they match.
+      var matchedFiber = existingChildren.get(newIdx) || null;
+      return updateTextNode(
+        returnFiber,
+        matchedFiber,
+        "" + newChild,
+        expirationTime
+      );
+    }
+
+    if (typeof newChild === "object" && newChild !== null) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE: {
+          var _matchedFiber =
+            existingChildren.get(
+              newChild.key === null ? newIdx : newChild.key
+            ) || null;
+          if (newChild.type === REACT_FRAGMENT_TYPE) {
+            return updateFragment(
+              returnFiber,
+              _matchedFiber,
+              newChild.props.children,
+              expirationTime,
+              newChild.key
+            );
+          }
+          return updateElement(
+            returnFiber,
+            _matchedFiber,
+            newChild,
+            expirationTime
+          );
+        }
+        case REACT_PORTAL_TYPE: {
+          var _matchedFiber2 =
+            existingChildren.get(
+              newChild.key === null ? newIdx : newChild.key
+            ) || null;
+          return updatePortal(
+            returnFiber,
+            _matchedFiber2,
+            newChild,
+            expirationTime
           );
         }
       }
-    }
-  }
-
-  // Cache unmasked context so we can avoid recreating masked context unless necessary.
-  // ReactFiberContext usually updates this cache but can't for newly-created instances.
-  if (isLegacyContextConsumer) {
-    cacheContext(workInProgress, unmaskedContext, context);
-  }
 
-  return instance;
-}
+      if (isArray(newChild) || getIteratorFn(newChild)) {
+        var _matchedFiber3 = existingChildren.get(newIdx) || null;
+        return updateFragment(
+          returnFiber,
+          _matchedFiber3,
+          newChild,
+          expirationTime,
+          null
+        );
+      }
+
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
 
-function callComponentWillMount(workInProgress, instance) {
-  startPhaseTimer(workInProgress, "componentWillMount");
-  var oldState = instance.state;
+    {
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
+      }
+    }
 
-  if (typeof instance.componentWillMount === "function") {
-    instance.componentWillMount();
-  }
-  if (typeof instance.UNSAFE_componentWillMount === "function") {
-    instance.UNSAFE_componentWillMount();
+    return null;
   }
 
-  stopPhaseTimer();
-
-  if (oldState !== instance.state) {
+  /**
+   * Warns if there is a duplicate or missing key
+   */
+  function warnOnInvalidKey(child, knownKeys) {
     {
-      warningWithoutStack$1(
-        false,
-        "%s.componentWillMount(): Assigning directly to this.state is " +
-          "deprecated (except inside a component's " +
-          "constructor). Use setState instead.",
-        getComponentName(workInProgress.type) || "Component"
-      );
+      if (typeof child !== "object" || child === null) {
+        return knownKeys;
+      }
+      switch (child.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+        case REACT_PORTAL_TYPE:
+          warnForMissingKey(child);
+          var key = child.key;
+          if (typeof key !== "string") {
+            break;
+          }
+          if (knownKeys === null) {
+            knownKeys = new Set();
+            knownKeys.add(key);
+            break;
+          }
+          if (!knownKeys.has(key)) {
+            knownKeys.add(key);
+            break;
+          }
+          warning$1(
+            false,
+            "Encountered two children with the same key, `%s`. " +
+              "Keys should be unique so that components maintain their identity " +
+              "across updates. Non-unique keys may cause children to be " +
+              "duplicated and/or omitted — the behavior is unsupported and " +
+              "could change in a future version.",
+            key
+          );
+          break;
+        default:
+          break;
+      }
     }
-    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
+    return knownKeys;
   }
-}
 
-function callComponentWillReceiveProps(
-  workInProgress,
-  instance,
-  newProps,
-  nextContext
-) {
-  var oldState = instance.state;
-  startPhaseTimer(workInProgress, "componentWillReceiveProps");
-  if (typeof instance.componentWillReceiveProps === "function") {
-    instance.componentWillReceiveProps(newProps, nextContext);
-  }
-  if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
-    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
-  }
-  stopPhaseTimer();
+  function reconcileChildrenArray(
+    returnFiber,
+    currentFirstChild,
+    newChildren,
+    expirationTime
+  ) {
+    // This algorithm can't optimize by searching from boths ends since we
+    // don't have backpointers on fibers. I'm trying to see how far we can get
+    // with that model. If it ends up not being worth the tradeoffs, we can
+    // add it later.
+
+    // Even with a two ended optimization, we'd want to optimize for the case
+    // where there are few changes and brute force the comparison instead of
+    // going for the Map. It'd like to explore hitting that path first in
+    // forward-only mode and only go for the Map once we notice that we need
+    // lots of look ahead. This doesn't handle reversal as well as two ended
+    // search but that's unusual. Besides, for the two ended optimization to
+    // work on Iterables, we'd need to copy the whole set.
+
+    // In this first iteration, we'll just live with hitting the bad case
+    // (adding everything to a Map) in for every insert/move.
+
+    // If you change this code, also update reconcileChildrenIterator() which
+    // uses the same algorithm.
 
-  if (instance.state !== oldState) {
     {
-      var componentName = getComponentName(workInProgress.type) || "Component";
-      if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
-        didWarnAboutStateAssignmentForComponent.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "%s.componentWillReceiveProps(): Assigning directly to " +
-            "this.state is deprecated (except inside a component's " +
-            "constructor). Use setState instead.",
-          componentName
-        );
+      // First, validate keys.
+      var knownKeys = null;
+      for (var i = 0; i < newChildren.length; i++) {
+        var child = newChildren[i];
+        knownKeys = warnOnInvalidKey(child, knownKeys);
       }
     }
-    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
-  }
-}
 
-// Invokes the mount life-cycles on a previously never rendered instance.
-function mountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
-  {
-    checkClassInstance(workInProgress, ctor, newProps);
-  }
+    var resultingFirstChild = null;
+    var previousNewFiber = null;
 
-  var instance = workInProgress.stateNode;
-  instance.props = newProps;
-  instance.state = workInProgress.memoizedState;
-  instance.refs = emptyRefsObject;
+    var oldFiber = currentFirstChild;
+    var lastPlacedIndex = 0;
+    var newIdx = 0;
+    var nextOldFiber = null;
+    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
+      if (oldFiber.index > newIdx) {
+        nextOldFiber = oldFiber;
+        oldFiber = null;
+      } else {
+        nextOldFiber = oldFiber.sibling;
+      }
+      var newFiber = updateSlot(
+        returnFiber,
+        oldFiber,
+        newChildren[newIdx],
+        expirationTime
+      );
+      if (newFiber === null) {
+        // TODO: This breaks on empty slots like null children. That's
+        // unfortunate because it triggers the slow path all the time. We need
+        // a better way to communicate whether this was a miss or null,
+        // boolean, undefined, etc.
+        if (oldFiber === null) {
+          oldFiber = nextOldFiber;
+        }
+        break;
+      }
+      if (shouldTrackSideEffects) {
+        if (oldFiber && newFiber.alternate === null) {
+          // We matched the slot, but we didn't reuse the existing fiber, so we
+          // need to delete the existing child.
+          deleteChild(returnFiber, oldFiber);
+        }
+      }
+      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
+      if (previousNewFiber === null) {
+        // TODO: Move out of the loop. This only happens for the first run.
+        resultingFirstChild = newFiber;
+      } else {
+        // TODO: Defer siblings if we're not at the right index for this slot.
+        // I.e. if we had null values before, then we want to defer this
+        // for each null value. However, we also don't want to call updateSlot
+        // with the previous one.
+        previousNewFiber.sibling = newFiber;
+      }
+      previousNewFiber = newFiber;
+      oldFiber = nextOldFiber;
+    }
 
-  var contextType = ctor.contextType;
-  if (typeof contextType === "object" && contextType !== null) {
-    instance.context = readContext$1(contextType);
-  } else {
-    var unmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-    instance.context = getMaskedContext(workInProgress, unmaskedContext);
-  }
+    if (newIdx === newChildren.length) {
+      // We've reached the end of the new children. We can delete the rest.
+      deleteRemainingChildren(returnFiber, oldFiber);
+      return resultingFirstChild;
+    }
 
-  {
-    if (instance.state === newProps) {
-      var componentName = getComponentName(ctor) || "Component";
-      if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
-        didWarnAboutDirectlyAssigningPropsToState.add(componentName);
-        warningWithoutStack$1(
-          false,
-          "%s: It is not recommended to assign props directly to state " +
-            "because updates to props won't be reflected in state. " +
-            "In most cases, it is better to use props directly.",
-          componentName
+    if (oldFiber === null) {
+      // If we don't have any more existing children we can choose a fast path
+      // since the rest will all be insertions.
+      for (; newIdx < newChildren.length; newIdx++) {
+        var _newFiber = createChild(
+          returnFiber,
+          newChildren[newIdx],
+          expirationTime
         );
+        if (!_newFiber) {
+          continue;
+        }
+        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          // TODO: Move out of the loop. This only happens for the first run.
+          resultingFirstChild = _newFiber;
+        } else {
+          previousNewFiber.sibling = _newFiber;
+        }
+        previousNewFiber = _newFiber;
       }
+      return resultingFirstChild;
     }
 
-    if (workInProgress.mode & StrictMode) {
-      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
-        workInProgress,
-        instance
-      );
+    // Add all children to a key map for quick lookups.
+    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
 
-      ReactStrictModeWarnings.recordLegacyContextWarning(
-        workInProgress,
-        instance
+    // Keep scanning and use the map to restore deleted items as moves.
+    for (; newIdx < newChildren.length; newIdx++) {
+      var _newFiber2 = updateFromMap(
+        existingChildren,
+        returnFiber,
+        newIdx,
+        newChildren[newIdx],
+        expirationTime
       );
+      if (_newFiber2) {
+        if (shouldTrackSideEffects) {
+          if (_newFiber2.alternate !== null) {
+            // The new fiber is a work in progress, but if there exists a
+            // current, that means that we reused the fiber. We need to delete
+            // it from the child list so that we don't add it to the deletion
+            // list.
+            existingChildren.delete(
+              _newFiber2.key === null ? newIdx : _newFiber2.key
+            );
+          }
+        }
+        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          resultingFirstChild = _newFiber2;
+        } else {
+          previousNewFiber.sibling = _newFiber2;
+        }
+        previousNewFiber = _newFiber2;
+      }
     }
 
-    if (warnAboutDeprecatedLifecycles) {
-      ReactStrictModeWarnings.recordDeprecationWarnings(
-        workInProgress,
-        instance
-      );
+    if (shouldTrackSideEffects) {
+      // Any existing children that weren't consumed above were deleted. We need
+      // to add them to the deletion list.
+      existingChildren.forEach(function(child) {
+        return deleteChild(returnFiber, child);
+      });
     }
-  }
-
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null) {
-    processUpdateQueue(
-      workInProgress,
-      updateQueue,
-      newProps,
-      instance,
-      renderExpirationTime
-    );
-    instance.state = workInProgress.memoizedState;
-  }
 
-  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
-  if (typeof getDerivedStateFromProps === "function") {
-    applyDerivedStateFromProps(
-      workInProgress,
-      ctor,
-      getDerivedStateFromProps,
-      newProps
-    );
-    instance.state = workInProgress.memoizedState;
+    return resultingFirstChild;
   }
 
-  // In order to support react-lifecycles-compat polyfilled components,
-  // Unsafe lifecycles should not be invoked for components using the new APIs.
-  if (
-    typeof ctor.getDerivedStateFromProps !== "function" &&
-    typeof instance.getSnapshotBeforeUpdate !== "function" &&
-    (typeof instance.UNSAFE_componentWillMount === "function" ||
-      typeof instance.componentWillMount === "function")
+  function reconcileChildrenIterator(
+    returnFiber,
+    currentFirstChild,
+    newChildrenIterable,
+    expirationTime
   ) {
-    callComponentWillMount(workInProgress, instance);
-    // If we had additional state updates during this life-cycle, let's
-    // process them now.
-    updateQueue = workInProgress.updateQueue;
-    if (updateQueue !== null) {
-      processUpdateQueue(
-        workInProgress,
-        updateQueue,
-        newProps,
-        instance,
-        renderExpirationTime
-      );
-      instance.state = workInProgress.memoizedState;
-    }
-  }
-
-  if (typeof instance.componentDidMount === "function") {
-    workInProgress.effectTag |= Update;
-  }
-}
-
-function resumeMountClassInstance(
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
-  var instance = workInProgress.stateNode;
-
-  var oldProps = workInProgress.memoizedProps;
-  instance.props = oldProps;
+    // This is the same implementation as reconcileChildrenArray(),
+    // but using the iterator instead.
 
-  var oldContext = instance.context;
-  var contextType = ctor.contextType;
-  var nextContext = void 0;
-  if (typeof contextType === "object" && contextType !== null) {
-    nextContext = readContext$1(contextType);
-  } else {
-    var nextLegacyUnmaskedContext = getUnmaskedContext(
-      workInProgress,
-      ctor,
-      true
+    var iteratorFn = getIteratorFn(newChildrenIterable);
+    invariant(
+      typeof iteratorFn === "function",
+      "An object is not an iterable. This error is likely caused by a bug in " +
+        "React. Please file an issue."
     );
-    nextContext = getMaskedContext(workInProgress, nextLegacyUnmaskedContext);
-  }
 
-  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
-  var hasNewLifecycles =
-    typeof getDerivedStateFromProps === "function" ||
-    typeof instance.getSnapshotBeforeUpdate === "function";
+    {
+      // We don't support rendering Generators because it's a mutation.
+      // See https://github.com/facebook/react/issues/12995
+      if (
+        typeof Symbol === "function" &&
+        // $FlowFixMe Flow doesn't know about toStringTag
+        newChildrenIterable[Symbol.toStringTag] === "Generator"
+      ) {
+        !didWarnAboutGenerators
+          ? warning$1(
+              false,
+              "Using Generators as children is unsupported and will likely yield " +
+                "unexpected results because enumerating a generator mutates it. " +
+                "You may convert it to an array with `Array.from()` or the " +
+                "`[...spread]` operator before rendering. Keep in mind " +
+                "you might need to polyfill these features for older browsers."
+            )
+          : void 0;
+        didWarnAboutGenerators = true;
+      }
 
-  // Note: During these life-cycles, instance.props/instance.state are what
-  // ever the previously attempted to render - not the "current". However,
-  // during componentDidUpdate we pass the "current" props.
+      // Warn about using Maps as children
+      if (newChildrenIterable.entries === iteratorFn) {
+        !didWarnAboutMaps
+          ? warning$1(
+              false,
+              "Using Maps as children is unsupported and will likely yield " +
+                "unexpected results. Convert it to a sequence/iterable of keyed " +
+                "ReactElements instead."
+            )
+          : void 0;
+        didWarnAboutMaps = true;
+      }
 
-  // In order to support react-lifecycles-compat polyfilled components,
-  // Unsafe lifecycles should not be invoked for components using the new APIs.
-  if (
-    !hasNewLifecycles &&
-    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
-      typeof instance.componentWillReceiveProps === "function")
-  ) {
-    if (oldProps !== newProps || oldContext !== nextContext) {
-      callComponentWillReceiveProps(
-        workInProgress,
-        instance,
-        newProps,
-        nextContext
-      );
+      // First, validate keys.
+      // We'll get a different iterator later for the main pass.
+      var _newChildren = iteratorFn.call(newChildrenIterable);
+      if (_newChildren) {
+        var knownKeys = null;
+        var _step = _newChildren.next();
+        for (; !_step.done; _step = _newChildren.next()) {
+          var child = _step.value;
+          knownKeys = warnOnInvalidKey(child, knownKeys);
+        }
+      }
     }
-  }
-
-  resetHasForceUpdateBeforeProcessing();
 
-  var oldState = workInProgress.memoizedState;
-  var newState = (instance.state = oldState);
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null) {
-    processUpdateQueue(
-      workInProgress,
-      updateQueue,
-      newProps,
-      instance,
-      renderExpirationTime
-    );
-    newState = workInProgress.memoizedState;
-  }
-  if (
-    oldProps === newProps &&
-    oldState === newState &&
-    !hasContextChanged() &&
-    !checkHasForceUpdateAfterProcessing()
-  ) {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
-    }
-    return false;
-  }
+    var newChildren = iteratorFn.call(newChildrenIterable);
+    invariant(newChildren != null, "An iterable object provided no iterator.");
 
-  if (typeof getDerivedStateFromProps === "function") {
-    applyDerivedStateFromProps(
-      workInProgress,
-      ctor,
-      getDerivedStateFromProps,
-      newProps
-    );
-    newState = workInProgress.memoizedState;
-  }
+    var resultingFirstChild = null;
+    var previousNewFiber = null;
 
-  var shouldUpdate =
-    checkHasForceUpdateAfterProcessing() ||
-    checkShouldComponentUpdate(
-      workInProgress,
-      ctor,
-      oldProps,
-      newProps,
-      oldState,
-      newState,
-      nextContext
-    );
+    var oldFiber = currentFirstChild;
+    var lastPlacedIndex = 0;
+    var newIdx = 0;
+    var nextOldFiber = null;
 
-  if (shouldUpdate) {
-    // In order to support react-lifecycles-compat polyfilled components,
-    // Unsafe lifecycles should not be invoked for components using the new APIs.
-    if (
-      !hasNewLifecycles &&
-      (typeof instance.UNSAFE_componentWillMount === "function" ||
-        typeof instance.componentWillMount === "function")
+    var step = newChildren.next();
+    for (
+      ;
+      oldFiber !== null && !step.done;
+      newIdx++, step = newChildren.next()
     ) {
-      startPhaseTimer(workInProgress, "componentWillMount");
-      if (typeof instance.componentWillMount === "function") {
-        instance.componentWillMount();
+      if (oldFiber.index > newIdx) {
+        nextOldFiber = oldFiber;
+        oldFiber = null;
+      } else {
+        nextOldFiber = oldFiber.sibling;
       }
-      if (typeof instance.UNSAFE_componentWillMount === "function") {
-        instance.UNSAFE_componentWillMount();
+      var newFiber = updateSlot(
+        returnFiber,
+        oldFiber,
+        step.value,
+        expirationTime
+      );
+      if (newFiber === null) {
+        // TODO: This breaks on empty slots like null children. That's
+        // unfortunate because it triggers the slow path all the time. We need
+        // a better way to communicate whether this was a miss or null,
+        // boolean, undefined, etc.
+        if (!oldFiber) {
+          oldFiber = nextOldFiber;
+        }
+        break;
       }
-      stopPhaseTimer();
-    }
-    if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
-    }
-  } else {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidMount === "function") {
-      workInProgress.effectTag |= Update;
+      if (shouldTrackSideEffects) {
+        if (oldFiber && newFiber.alternate === null) {
+          // We matched the slot, but we didn't reuse the existing fiber, so we
+          // need to delete the existing child.
+          deleteChild(returnFiber, oldFiber);
+        }
+      }
+      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
+      if (previousNewFiber === null) {
+        // TODO: Move out of the loop. This only happens for the first run.
+        resultingFirstChild = newFiber;
+      } else {
+        // TODO: Defer siblings if we're not at the right index for this slot.
+        // I.e. if we had null values before, then we want to defer this
+        // for each null value. However, we also don't want to call updateSlot
+        // with the previous one.
+        previousNewFiber.sibling = newFiber;
+      }
+      previousNewFiber = newFiber;
+      oldFiber = nextOldFiber;
     }
 
-    // If shouldComponentUpdate returned false, we should still update the
-    // memoized state to indicate that this work can be reused.
-    workInProgress.memoizedProps = newProps;
-    workInProgress.memoizedState = newState;
-  }
+    if (step.done) {
+      // We've reached the end of the new children. We can delete the rest.
+      deleteRemainingChildren(returnFiber, oldFiber);
+      return resultingFirstChild;
+    }
 
-  // Update the existing instance's state, props, and context pointers even
-  // if shouldComponentUpdate returns false.
-  instance.props = newProps;
-  instance.state = newState;
-  instance.context = nextContext;
+    if (oldFiber === null) {
+      // If we don't have any more existing children we can choose a fast path
+      // since the rest will all be insertions.
+      for (; !step.done; newIdx++, step = newChildren.next()) {
+        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
+        if (_newFiber3 === null) {
+          continue;
+        }
+        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          // TODO: Move out of the loop. This only happens for the first run.
+          resultingFirstChild = _newFiber3;
+        } else {
+          previousNewFiber.sibling = _newFiber3;
+        }
+        previousNewFiber = _newFiber3;
+      }
+      return resultingFirstChild;
+    }
 
-  return shouldUpdate;
-}
+    // Add all children to a key map for quick lookups.
+    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
 
-// Invokes the update life-cycles and returns false if it shouldn't rerender.
-function updateClassInstance(
-  current,
-  workInProgress,
-  ctor,
-  newProps,
-  renderExpirationTime
-) {
-  var instance = workInProgress.stateNode;
+    // Keep scanning and use the map to restore deleted items as moves.
+    for (; !step.done; newIdx++, step = newChildren.next()) {
+      var _newFiber4 = updateFromMap(
+        existingChildren,
+        returnFiber,
+        newIdx,
+        step.value,
+        expirationTime
+      );
+      if (_newFiber4 !== null) {
+        if (shouldTrackSideEffects) {
+          if (_newFiber4.alternate !== null) {
+            // The new fiber is a work in progress, but if there exists a
+            // current, that means that we reused the fiber. We need to delete
+            // it from the child list so that we don't add it to the deletion
+            // list.
+            existingChildren.delete(
+              _newFiber4.key === null ? newIdx : _newFiber4.key
+            );
+          }
+        }
+        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
+        if (previousNewFiber === null) {
+          resultingFirstChild = _newFiber4;
+        } else {
+          previousNewFiber.sibling = _newFiber4;
+        }
+        previousNewFiber = _newFiber4;
+      }
+    }
 
-  var oldProps = workInProgress.memoizedProps;
-  instance.props =
-    workInProgress.type === workInProgress.elementType
-      ? oldProps
-      : resolveDefaultProps(workInProgress.type, oldProps);
+    if (shouldTrackSideEffects) {
+      // Any existing children that weren't consumed above were deleted. We need
+      // to add them to the deletion list.
+      existingChildren.forEach(function(child) {
+        return deleteChild(returnFiber, child);
+      });
+    }
 
-  var oldContext = instance.context;
-  var contextType = ctor.contextType;
-  var nextContext = void 0;
-  if (typeof contextType === "object" && contextType !== null) {
-    nextContext = readContext$1(contextType);
-  } else {
-    var nextUnmaskedContext = getUnmaskedContext(workInProgress, ctor, true);
-    nextContext = getMaskedContext(workInProgress, nextUnmaskedContext);
+    return resultingFirstChild;
   }
 
-  var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
-  var hasNewLifecycles =
-    typeof getDerivedStateFromProps === "function" ||
-    typeof instance.getSnapshotBeforeUpdate === "function";
-
-  // Note: During these life-cycles, instance.props/instance.state are what
-  // ever the previously attempted to render - not the "current". However,
-  // during componentDidUpdate we pass the "current" props.
-
-  // In order to support react-lifecycles-compat polyfilled components,
-  // Unsafe lifecycles should not be invoked for components using the new APIs.
-  if (
-    !hasNewLifecycles &&
-    (typeof instance.UNSAFE_componentWillReceiveProps === "function" ||
-      typeof instance.componentWillReceiveProps === "function")
+  function reconcileSingleTextNode(
+    returnFiber,
+    currentFirstChild,
+    textContent,
+    expirationTime
   ) {
-    if (oldProps !== newProps || oldContext !== nextContext) {
-      callComponentWillReceiveProps(
-        workInProgress,
-        instance,
-        newProps,
-        nextContext
-      );
+    // There's no need to check for keys on text nodes since we don't have a
+    // way to define them.
+    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
+      // We already have an existing node so let's just update it and delete
+      // the rest.
+      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
+      var existing = useFiber(currentFirstChild, textContent, expirationTime);
+      existing.return = returnFiber;
+      return existing;
     }
-  }
-
-  resetHasForceUpdateBeforeProcessing();
-
-  var oldState = workInProgress.memoizedState;
-  var newState = (instance.state = oldState);
-  var updateQueue = workInProgress.updateQueue;
-  if (updateQueue !== null) {
-    processUpdateQueue(
-      workInProgress,
-      updateQueue,
-      newProps,
-      instance,
-      renderExpirationTime
+    // The existing first child is not a text node so we need to create one
+    // and delete the existing ones.
+    deleteRemainingChildren(returnFiber, currentFirstChild);
+    var created = createFiberFromText(
+      textContent,
+      returnFiber.mode,
+      expirationTime
     );
-    newState = workInProgress.memoizedState;
+    created.return = returnFiber;
+    return created;
   }
 
-  if (
-    oldProps === newProps &&
-    oldState === newState &&
-    !hasContextChanged() &&
-    !checkHasForceUpdateAfterProcessing()
+  function reconcileSingleElement(
+    returnFiber,
+    currentFirstChild,
+    element,
+    expirationTime
   ) {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Update;
-      }
-    }
-    if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Snapshot;
+    var key = element.key;
+    var child = currentFirstChild;
+    while (child !== null) {
+      // TODO: If key === null and child.key === null, then this only applies to
+      // the first item in the list.
+      if (child.key === key) {
+        if (
+          child.tag === Fragment
+            ? element.type === REACT_FRAGMENT_TYPE
+            : child.elementType === element.type
+        ) {
+          deleteRemainingChildren(returnFiber, child.sibling);
+          var existing = useFiber(
+            child,
+            element.type === REACT_FRAGMENT_TYPE
+              ? element.props.children
+              : element.props,
+            expirationTime
+          );
+          existing.ref = coerceRef(returnFiber, child, element);
+          existing.return = returnFiber;
+          {
+            existing._debugSource = element._source;
+            existing._debugOwner = element._owner;
+          }
+          return existing;
+        } else {
+          deleteRemainingChildren(returnFiber, child);
+          break;
+        }
+      } else {
+        deleteChild(returnFiber, child);
       }
+      child = child.sibling;
     }
-    return false;
-  }
 
-  if (typeof getDerivedStateFromProps === "function") {
-    applyDerivedStateFromProps(
-      workInProgress,
-      ctor,
-      getDerivedStateFromProps,
-      newProps
-    );
-    newState = workInProgress.memoizedState;
+    if (element.type === REACT_FRAGMENT_TYPE) {
+      var created = createFiberFromFragment(
+        element.props.children,
+        returnFiber.mode,
+        expirationTime,
+        element.key
+      );
+      created.return = returnFiber;
+      return created;
+    } else {
+      var _created4 = createFiberFromElement(
+        element,
+        returnFiber.mode,
+        expirationTime
+      );
+      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
+      _created4.return = returnFiber;
+      return _created4;
+    }
   }
 
-  var shouldUpdate =
-    checkHasForceUpdateAfterProcessing() ||
-    checkShouldComponentUpdate(
-      workInProgress,
-      ctor,
-      oldProps,
-      newProps,
-      oldState,
-      newState,
-      nextContext
-    );
-
-  if (shouldUpdate) {
-    // In order to support react-lifecycles-compat polyfilled components,
-    // Unsafe lifecycles should not be invoked for components using the new APIs.
-    if (
-      !hasNewLifecycles &&
-      (typeof instance.UNSAFE_componentWillUpdate === "function" ||
-        typeof instance.componentWillUpdate === "function")
-    ) {
-      startPhaseTimer(workInProgress, "componentWillUpdate");
-      if (typeof instance.componentWillUpdate === "function") {
-        instance.componentWillUpdate(newProps, newState, nextContext);
-      }
-      if (typeof instance.UNSAFE_componentWillUpdate === "function") {
-        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
-      }
-      stopPhaseTimer();
-    }
-    if (typeof instance.componentDidUpdate === "function") {
-      workInProgress.effectTag |= Update;
-    }
-    if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      workInProgress.effectTag |= Snapshot;
-    }
-  } else {
-    // If an update was already in progress, we should schedule an Update
-    // effect even though we're bailing out, so that cWU/cDU are called.
-    if (typeof instance.componentDidUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Update;
-      }
-    }
-    if (typeof instance.getSnapshotBeforeUpdate === "function") {
-      if (
-        oldProps !== current.memoizedProps ||
-        oldState !== current.memoizedState
-      ) {
-        workInProgress.effectTag |= Snapshot;
+  function reconcileSinglePortal(
+    returnFiber,
+    currentFirstChild,
+    portal,
+    expirationTime
+  ) {
+    var key = portal.key;
+    var child = currentFirstChild;
+    while (child !== null) {
+      // TODO: If key === null and child.key === null, then this only applies to
+      // the first item in the list.
+      if (child.key === key) {
+        if (
+          child.tag === HostPortal &&
+          child.stateNode.containerInfo === portal.containerInfo &&
+          child.stateNode.implementation === portal.implementation
+        ) {
+          deleteRemainingChildren(returnFiber, child.sibling);
+          var existing = useFiber(child, portal.children || [], expirationTime);
+          existing.return = returnFiber;
+          return existing;
+        } else {
+          deleteRemainingChildren(returnFiber, child);
+          break;
+        }
+      } else {
+        deleteChild(returnFiber, child);
       }
+      child = child.sibling;
     }
 
-    // If shouldComponentUpdate returned false, we should still update the
-    // memoized props/state to indicate that this work can be reused.
-    workInProgress.memoizedProps = newProps;
-    workInProgress.memoizedState = newState;
+    var created = createFiberFromPortal(
+      portal,
+      returnFiber.mode,
+      expirationTime
+    );
+    created.return = returnFiber;
+    return created;
   }
 
-  // Update the existing instance's state, props, and context pointers even
-  // if shouldComponentUpdate returns false.
-  instance.props = newProps;
-  instance.state = newState;
-  instance.context = nextContext;
-
-  return shouldUpdate;
-}
-
-var didWarnAboutMaps = void 0;
-var didWarnAboutGenerators = void 0;
-var didWarnAboutStringRefInStrictMode = void 0;
-var ownerHasKeyUseWarning = void 0;
-var ownerHasFunctionTypeWarning = void 0;
-var warnForMissingKey = function(child) {};
+  // This API will tag the children with the side-effect of the reconciliation
+  // itself. They will be added to the side-effect list as we pass through the
+  // children and the parent.
+  function reconcileChildFibers(
+    returnFiber,
+    currentFirstChild,
+    newChild,
+    expirationTime
+  ) {
+    // This function is not recursive.
+    // If the top level item is an array, we treat it as a set of children,
+    // not as a fragment. Nested arrays on the other hand will be treated as
+    // fragment nodes. Recursion happens at the normal flow.
 
-{
-  didWarnAboutMaps = false;
-  didWarnAboutGenerators = false;
-  didWarnAboutStringRefInStrictMode = {};
+    // Handle top level unkeyed fragments as if they were arrays.
+    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
+    // We treat the ambiguous cases above the same.
+    var isUnkeyedTopLevelFragment =
+      typeof newChild === "object" &&
+      newChild !== null &&
+      newChild.type === REACT_FRAGMENT_TYPE &&
+      newChild.key === null;
+    if (isUnkeyedTopLevelFragment) {
+      newChild = newChild.props.children;
+    }
 
-  /**
-   * Warn if there's no key explicitly set on dynamic arrays of children or
-   * object keys are not valid. This allows us to keep track of children between
-   * updates.
-   */
-  ownerHasKeyUseWarning = {};
-  ownerHasFunctionTypeWarning = {};
+    // Handle object types
+    var isObject = typeof newChild === "object" && newChild !== null;
 
-  warnForMissingKey = function(child) {
-    if (child === null || typeof child !== "object") {
-      return;
+    if (isObject) {
+      switch (newChild.$$typeof) {
+        case REACT_ELEMENT_TYPE:
+          return placeSingleChild(
+            reconcileSingleElement(
+              returnFiber,
+              currentFirstChild,
+              newChild,
+              expirationTime
+            )
+          );
+        case REACT_PORTAL_TYPE:
+          return placeSingleChild(
+            reconcileSinglePortal(
+              returnFiber,
+              currentFirstChild,
+              newChild,
+              expirationTime
+            )
+          );
+      }
     }
-    if (!child._store || child._store.validated || child.key != null) {
-      return;
+
+    if (typeof newChild === "string" || typeof newChild === "number") {
+      return placeSingleChild(
+        reconcileSingleTextNode(
+          returnFiber,
+          currentFirstChild,
+          "" + newChild,
+          expirationTime
+        )
+      );
     }
-    invariant(
-      typeof child._store === "object",
-      "React Component in warnForMissingKey should have a _store. " +
-        "This error is likely caused by a bug in React. Please file an issue."
-    );
-    child._store.validated = true;
 
-    var currentComponentErrorInfo =
-      "Each child in an array or iterator should have a unique " +
-      '"key" prop. See https://fb.me/react-warning-keys for ' +
-      "more information." +
-      getCurrentFiberStackInDev();
-    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
-      return;
+    if (isArray(newChild)) {
+      return reconcileChildrenArray(
+        returnFiber,
+        currentFirstChild,
+        newChild,
+        expirationTime
+      );
     }
-    ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
 
-    warning$1(
-      false,
-      "Each child in an array or iterator should have a unique " +
-        '"key" prop. See https://fb.me/react-warning-keys for ' +
-        "more information."
-    );
-  };
-}
+    if (getIteratorFn(newChild)) {
+      return reconcileChildrenIterator(
+        returnFiber,
+        currentFirstChild,
+        newChild,
+        expirationTime
+      );
+    }
 
-var isArray = Array.isArray;
+    if (isObject) {
+      throwOnInvalidObjectType(returnFiber, newChild);
+    }
 
-function coerceRef(returnFiber, current$$1, element) {
-  var mixedRef = element.ref;
-  if (
-    mixedRef !== null &&
-    typeof mixedRef !== "function" &&
-    typeof mixedRef !== "object"
-  ) {
     {
-      if (returnFiber.mode & StrictMode) {
-        var componentName = getComponentName(returnFiber.type) || "Component";
-        if (!didWarnAboutStringRefInStrictMode[componentName]) {
-          warningWithoutStack$1(
+      if (typeof newChild === "function") {
+        warnOnFunctionType();
+      }
+    }
+    if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
+      // If the new child is undefined, and the return fiber is a composite
+      // component, throw an error. If Fiber return types are disabled,
+      // we already threw above.
+      switch (returnFiber.tag) {
+        case ClassComponent: {
+          {
+            var instance = returnFiber.stateNode;
+            if (instance.render._isMockFunction) {
+              // We allow auto-mocks to proceed as if they're returning null.
+              break;
+            }
+          }
+        }
+        // Intentionally fall through to the next case, which handles both
+        // functions and classes
+        // eslint-disable-next-lined no-fallthrough
+        case FunctionComponent: {
+          var Component = returnFiber.type;
+          invariant(
             false,
-            'A string ref, "%s", has been found within a strict mode tree. ' +
-              "String refs are a source of potential bugs and should be avoided. " +
-              "We recommend using createRef() instead." +
-              "\n%s" +
-              "\n\nLearn more about using refs safely here:" +
-              "\nhttps://fb.me/react-strict-mode-string-ref",
-            mixedRef,
-            getStackByFiberInDevAndProd(returnFiber)
+            "%s(...): Nothing was returned from render. This usually means a " +
+              "return statement is missing. Or, to render nothing, " +
+              "return null.",
+            Component.displayName || Component.name || "Component"
           );
-          didWarnAboutStringRefInStrictMode[componentName] = true;
         }
       }
     }
 
-    if (element._owner) {
-      var owner = element._owner;
-      var inst = void 0;
-      if (owner) {
-        var ownerFiber = owner;
-        invariant(
-          ownerFiber.tag === ClassComponent,
-          "Function components cannot have refs."
-        );
-        inst = ownerFiber.stateNode;
-      }
-      invariant(
-        inst,
-        "Missing owner for string ref %s. This error is likely caused by a " +
-          "bug in React. Please file an issue.",
-        mixedRef
-      );
-      var stringRef = "" + mixedRef;
-      // Check if previous string ref matches new string ref
-      if (
-        current$$1 !== null &&
-        current$$1.ref !== null &&
-        typeof current$$1.ref === "function" &&
-        current$$1.ref._stringRef === stringRef
-      ) {
-        return current$$1.ref;
-      }
-      var ref = function(value) {
-        var refs = inst.refs;
-        if (refs === emptyRefsObject) {
-          // This is a lazy pooled frozen object, so we need to initialize.
-          refs = inst.refs = {};
-        }
-        if (value === null) {
-          delete refs[stringRef];
-        } else {
-          refs[stringRef] = value;
-        }
-      };
-      ref._stringRef = stringRef;
-      return ref;
-    } else {
-      invariant(
-        typeof mixedRef === "string",
-        "Expected ref to be a function, a string, an object returned by React.createRef(), or null."
-      );
-      invariant(
-        element._owner,
-        "Element ref was specified as a string (%s) but no owner was set. This could happen for one of" +
-          " the following reasons:\n" +
-          "1. You may be adding a ref to a function component\n" +
-          "2. You may be adding a ref to a component that was not created inside a component's render method\n" +
-          "3. You have multiple copies of React loaded\n" +
-          "See https://fb.me/react-refs-must-have-owner for more information.",
-        mixedRef
-      );
-    }
+    // Remaining cases are all treated as empty.
+    return deleteRemainingChildren(returnFiber, currentFirstChild);
   }
-  return mixedRef;
+
+  return reconcileChildFibers;
 }
 
-function throwOnInvalidObjectType(returnFiber, newChild) {
-  if (returnFiber.type !== "textarea") {
-    var addendum = "";
-    {
-      addendum =
-        " If you meant to render a collection of children, use an array " +
-        "instead." +
-        getCurrentFiberStackInDev();
-    }
-    invariant(
-      false,
-      "Objects are not valid as a React child (found: %s).%s",
-      Object.prototype.toString.call(newChild) === "[object Object]"
-        ? "object with keys {" + Object.keys(newChild).join(", ") + "}"
-        : newChild,
-      addendum
+var reconcileChildFibers = ChildReconciler(true);
+var mountChildFibers = ChildReconciler(false);
+
+function cloneChildFibers(current$$1, workInProgress) {
+  invariant(
+    current$$1 === null || workInProgress.child === current$$1.child,
+    "Resuming work not yet implemented."
+  );
+
+  if (workInProgress.child === null) {
+    return;
+  }
+
+  var currentChild = workInProgress.child;
+  var newChild = createWorkInProgress(
+    currentChild,
+    currentChild.pendingProps,
+    currentChild.expirationTime
+  );
+  workInProgress.child = newChild;
+
+  newChild.return = workInProgress;
+  while (currentChild.sibling !== null) {
+    currentChild = currentChild.sibling;
+    newChild = newChild.sibling = createWorkInProgress(
+      currentChild,
+      currentChild.pendingProps,
+      currentChild.expirationTime
     );
+    newChild.return = workInProgress;
   }
+  newChild.sibling = null;
 }
 
-function warnOnFunctionType() {
-  var currentComponentErrorInfo =
-    "Functions are not valid as a React child. This may happen if " +
-    "you return a Component instead of <Component /> from render. " +
-    "Or maybe you meant to call this function rather than return it." +
-    getCurrentFiberStackInDev();
+var NO_CONTEXT = {};
 
-  if (ownerHasFunctionTypeWarning[currentComponentErrorInfo]) {
+var contextStackCursor$1 = createCursor(NO_CONTEXT);
+var contextFiberStackCursor = createCursor(NO_CONTEXT);
+var rootInstanceStackCursor = createCursor(NO_CONTEXT);
+
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug " +
+      "in React. Please file an issue."
+  );
+  return c;
+}
+
+function getRootHostContainer() {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  return rootInstance;
+}
+
+function pushHostContainer(fiber, nextRootInstance) {
+  // Push current root instance onto the stack;
+  // This allows us to reset root when portals are popped.
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+
+  // Finally, we need to push the host context to the stack.
+  // However, we can't just call getRootHostContext() and push it because
+  // we'd have a different number of entries on the stack depending on
+  // whether getRootHostContext() throws somewhere in renderer code or not.
+  // So we push an empty value first. This lets us safely unwind on errors.
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  var nextRootContext = getRootHostContext(nextRootInstance);
+  // Now that we know this function doesn't throw, replace it.
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, nextRootContext, fiber);
+}
+
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+
+function getHostContext() {
+  var context = requiredContext(contextStackCursor$1.current);
+  return context;
+}
+
+function pushHostContext(fiber) {
+  var rootInstance = requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = getChildHostContext(context, fiber.type, rootInstance);
+
+  // Don't push this Fiber's context unless it's unique.
+  if (context === nextContext) {
     return;
   }
-  ownerHasFunctionTypeWarning[currentComponentErrorInfo] = true;
 
-  warning$1(
-    false,
-    "Functions are not valid as a React child. This may happen if " +
-      "you return a Component instead of <Component /> from render. " +
-      "Or maybe you meant to call this function rather than return it."
-  );
+  // Track the context and the Fiber that provided it.
+  // This enables us to pop only Fibers that provide unique contexts.
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, nextContext, fiber);
 }
 
-// This wrapper function exists because I expect to clone the code in each path
-// to be able to optimize each path individually by branching early. This needs
-// a compiler or we can do it manually. Helpers that don't need this branching
-// live outside of this function.
-function ChildReconciler(shouldTrackSideEffects) {
-  function deleteChild(returnFiber, childToDelete) {
-    if (!shouldTrackSideEffects) {
-      // Noop.
-      return;
-    }
-    // Deletions are added in reversed order so we add it to the front.
-    // At this point, the return fiber's effect list is empty except for
-    // deletions, so we can just append the deletion to the list. The remaining
-    // effects aren't added until the complete phase. Once we implement
-    // resuming, this may not be true.
-    var last = returnFiber.lastEffect;
-    if (last !== null) {
-      last.nextEffect = childToDelete;
-      returnFiber.lastEffect = childToDelete;
-    } else {
-      returnFiber.firstEffect = returnFiber.lastEffect = childToDelete;
-    }
-    childToDelete.nextEffect = null;
-    childToDelete.effectTag = Deletion;
+function popHostContext(fiber) {
+  // Do not pop unless this Fiber provided the current context.
+  // pushHostContext() only pushes Fibers that provide unique contexts.
+  if (contextFiberStackCursor.current !== fiber) {
+    return;
   }
 
-  function deleteRemainingChildren(returnFiber, currentFirstChild) {
-    if (!shouldTrackSideEffects) {
-      // Noop.
-      return null;
-    }
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+}
 
-    // TODO: For the shouldClone case, this could be micro-optimized a bit by
-    // assuming that after the first child we've already added everything.
-    var childToDelete = currentFirstChild;
-    while (childToDelete !== null) {
-      deleteChild(returnFiber, childToDelete);
-      childToDelete = childToDelete.sibling;
-    }
-    return null;
-  }
+var NoEffect$1 = /*             */ 0;
+var UnmountSnapshot = /*      */ 2;
+var UnmountMutation = /*      */ 4;
+var MountMutation = /*        */ 8;
+var UnmountLayout = /*        */ 16;
+var MountLayout = /*          */ 32;
+var MountPassive = /*         */ 64;
+var UnmountPassive = /*       */ 128;
 
-  function mapRemainingChildren(returnFiber, currentFirstChild) {
-    // Add the remaining children to a temporary map so that we can find them by
-    // keys quickly. Implicit (null) keys get added to this set with their index
-    var existingChildren = new Map();
+// the first instance of a hook mismatch in a component,
+// represented by a portion of it's stacktrace
+var currentHookMismatchInDev = null;
 
-    var existingChild = currentFirstChild;
-    while (existingChild !== null) {
-      if (existingChild.key !== null) {
-        existingChildren.set(existingChild.key, existingChild);
-      } else {
-        existingChildren.set(existingChild.index, existingChild);
-      }
-      existingChild = existingChild.sibling;
-    }
-    return existingChildren;
-  }
+var didWarnAboutMismatchedHooksForComponent = void 0;
+{
+  didWarnAboutMismatchedHooksForComponent = new Set();
+}
 
-  function useFiber(fiber, pendingProps, expirationTime) {
-    // We currently set sibling to null and index to 0 here because it is easy
-    // to forget to do before returning it. E.g. for the single child case.
-    var clone = createWorkInProgress(fiber, pendingProps, expirationTime);
-    clone.index = 0;
-    clone.sibling = null;
-    return clone;
-  }
+// These are set right before calling the component.
+var renderExpirationTime = NoWork;
+// The work-in-progress fiber. I've named it differently to distinguish it from
+// the work-in-progress hook.
+var currentlyRenderingFiber$1 = null;
 
-  function placeChild(newFiber, lastPlacedIndex, newIndex) {
-    newFiber.index = newIndex;
-    if (!shouldTrackSideEffects) {
-      // Noop.
-      return lastPlacedIndex;
-    }
-    var current$$1 = newFiber.alternate;
-    if (current$$1 !== null) {
-      var oldIndex = current$$1.index;
-      if (oldIndex < lastPlacedIndex) {
-        // This is a move.
-        newFiber.effectTag = Placement;
-        return lastPlacedIndex;
-      } else {
-        // This item can stay in place.
-        return oldIndex;
-      }
-    } else {
-      // This is an insertion.
-      newFiber.effectTag = Placement;
-      return lastPlacedIndex;
-    }
-  }
+// Hooks are stored as a linked list on the fiber's memoizedState field. The
+// current hook list is the list that belongs to the current fiber. The
+// work-in-progress hook list is a new list that will be added to the
+// work-in-progress fiber.
+var firstCurrentHook = null;
+var currentHook = null;
+var firstWorkInProgressHook = null;
+var workInProgressHook = null;
 
-  function placeSingleChild(newFiber) {
-    // This is simpler for the single child case. We only need to do a
-    // placement for inserting new children.
-    if (shouldTrackSideEffects && newFiber.alternate === null) {
-      newFiber.effectTag = Placement;
-    }
-    return newFiber;
-  }
+var remainingExpirationTime = NoWork;
+var componentUpdateQueue = null;
 
-  function updateTextNode(
-    returnFiber,
-    current$$1,
-    textContent,
-    expirationTime
-  ) {
-    if (current$$1 === null || current$$1.tag !== HostText) {
-      // Insert
-      var created = createFiberFromText(
-        textContent,
-        returnFiber.mode,
-        expirationTime
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      // Update
-      var existing = useFiber(current$$1, textContent, expirationTime);
-      existing.return = returnFiber;
-      return existing;
-    }
-  }
+// Updates scheduled during render will trigger an immediate re-render at the
+// end of the current pass. We can't store these updates on the normal queue,
+// because if the work is aborted, they should be discarded. Because this is
+// a relatively rare case, we also don't want to add an additional field to
+// either the hook or queue object types. So we store them in a lazily create
+// map of queue -> render-phase updates, which are discarded once the component
+// completes without re-rendering.
 
-  function updateElement(returnFiber, current$$1, element, expirationTime) {
-    if (current$$1 !== null && current$$1.elementType === element.type) {
-      // Move based on index
-      var existing = useFiber(current$$1, element.props, expirationTime);
-      existing.ref = coerceRef(returnFiber, current$$1, element);
-      existing.return = returnFiber;
-      {
-        existing._debugSource = element._source;
-        existing._debugOwner = element._owner;
-      }
-      return existing;
-    } else {
-      // Insert
-      var created = createFiberFromElement(
-        element,
-        returnFiber.mode,
-        expirationTime
+// Whether an update was scheduled during the currently executing render pass.
+var didScheduleRenderPhaseUpdate = false;
+// Lazily created map of render-phase updates
+var renderPhaseUpdates = null;
+// Counter to prevent infinite loops.
+var numberOfReRenders = -1;
+var RE_RENDER_LIMIT = 25;
+
+// In DEV, this is the name of the currently executing primitive hook
+var currentHookNameInDev = null;
+
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    currentlyRenderingFiber$1 !== null,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (prevDeps === null) {
+    {
+      warning$1(
+        false,
+        "%s received a final argument during this render, but not during " +
+          "the previous render. Even though the final argument is optional, " +
+          "its type cannot change between renders.",
+        currentHookNameInDev
       );
-      created.ref = coerceRef(returnFiber, current$$1, element);
-      created.return = returnFiber;
-      return created;
     }
+    return false;
   }
 
-  function updatePortal(returnFiber, current$$1, portal, expirationTime) {
-    if (
-      current$$1 === null ||
-      current$$1.tag !== HostPortal ||
-      current$$1.stateNode.containerInfo !== portal.containerInfo ||
-      current$$1.stateNode.implementation !== portal.implementation
-    ) {
-      // Insert
-      var created = createFiberFromPortal(
-        portal,
-        returnFiber.mode,
-        expirationTime
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      // Update
-      var existing = useFiber(
-        current$$1,
-        portal.children || [],
-        expirationTime
+  {
+    // Don't bother comparing lengths in prod because these arrays should be
+    // passed inline.
+    if (nextDeps.length !== prevDeps.length) {
+      warning$1(
+        false,
+        "The final argument passed to %s changed size between renders. The " +
+          "order and size of this array must remain constant.\n\n" +
+          "Previous: %s\n" +
+          "Incoming: %s",
+        currentHookNameInDev,
+        "[" + nextDeps.join(", ") + "]",
+        "[" + prevDeps.join(", ") + "]"
       );
-      existing.return = returnFiber;
-      return existing;
     }
   }
-
-  function updateFragment(
-    returnFiber,
-    current$$1,
-    fragment,
-    expirationTime,
-    key
-  ) {
-    if (current$$1 === null || current$$1.tag !== Fragment) {
-      // Insert
-      var created = createFiberFromFragment(
-        fragment,
-        returnFiber.mode,
-        expirationTime,
-        key
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      // Update
-      var existing = useFiber(current$$1, fragment, expirationTime);
-      existing.return = returnFiber;
-      return existing;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++) {
+    if (is(nextDeps[i], prevDeps[i])) {
+      continue;
     }
+    return false;
   }
+  return true;
+}
 
-  function createChild(returnFiber, newChild, expirationTime) {
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      // Text nodes don't have keys. If the previous node is implicitly keyed
-      // we can continue to replace it without aborting even if it is not a text
-      // node.
-      var created = createFiberFromText(
-        "" + newChild,
-        returnFiber.mode,
-        expirationTime
-      );
-      created.return = returnFiber;
-      return created;
+// till we have String::padEnd, a small function to
+// right-pad strings with spaces till a minimum length
+function padEndSpaces(string, length) {
+  {
+    if (string.length >= length) {
+      return string;
+    } else {
+      return string + " " + new Array(length - string.length).join(" ");
     }
-
-    if (typeof newChild === "object" && newChild !== null) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE: {
-          var _created = createFiberFromElement(
-            newChild,
-            returnFiber.mode,
-            expirationTime
-          );
-          _created.ref = coerceRef(returnFiber, null, newChild);
-          _created.return = returnFiber;
-          return _created;
-        }
-        case REACT_PORTAL_TYPE: {
-          var _created2 = createFiberFromPortal(
-            newChild,
-            returnFiber.mode,
-            expirationTime
-          );
-          _created2.return = returnFiber;
-          return _created2;
+  }
+}
+
+function flushHookMismatchWarnings() {
+  // we'll show the diff of the low level hooks,
+  // and a stack trace so the dev can locate where
+  // the first mismatch is coming from
+  {
+    if (currentHookMismatchInDev !== null) {
+      var componentName = getComponentName(currentlyRenderingFiber$1.type);
+      if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
+        didWarnAboutMismatchedHooksForComponent.add(componentName);
+        var hookStackDiff = [];
+        var _current = firstCurrentHook;
+        var previousOrder = [];
+        while (_current !== null) {
+          previousOrder.push(_current._debugType);
+          _current = _current.next;
         }
-      }
+        var workInProgress = firstWorkInProgressHook;
+        var nextOrder = [];
+        while (workInProgress !== null) {
+          nextOrder.push(workInProgress._debugType);
+          workInProgress = workInProgress.next;
+        }
+        // some bookkeeping for formatting the output table
+        var columnLength = Math.max.apply(
+          null,
+          previousOrder
+            .map(function(hook) {
+              return hook.length;
+            })
+            .concat("   Previous render".length)
+        );
 
-      if (isArray(newChild) || getIteratorFn(newChild)) {
-        var _created3 = createFiberFromFragment(
-          newChild,
-          returnFiber.mode,
-          expirationTime,
-          null
+        var hookStackHeader =
+          padEndSpaces("   Previous render", columnLength) +
+          "    Next render\n";
+        var hookStackWidth = hookStackHeader.length;
+        hookStackHeader += "   " + new Array(hookStackWidth - 2).join("-");
+        var hookStackFooter = "   " + new Array(hookStackWidth - 2).join("^");
+
+        var hookStackLength = Math.max(previousOrder.length, nextOrder.length);
+        for (var i = 0; i < hookStackLength; i++) {
+          hookStackDiff.push(
+            padEndSpaces(i + 1 + ". ", 3) +
+              padEndSpaces(previousOrder[i], columnLength) +
+              " " +
+              nextOrder[i]
+          );
+          if (previousOrder[i] !== nextOrder[i]) {
+            break;
+          }
+        }
+        warning$1(
+          false,
+          "React has detected a change in the order of Hooks called by %s. " +
+            "This will lead to bugs and errors if not fixed. " +
+            "For more information, read the Rules of Hooks: https://fb.me/rules-of-hooks\n\n" +
+            "%s\n" +
+            "%s\n" +
+            "%s\n" +
+            "The first Hook type mismatch occured at:\n" +
+            "%s\n\n" +
+            "This error occurred in the following component:",
+          componentName,
+          hookStackHeader,
+          hookStackDiff.join("\n"),
+          hookStackFooter,
+          currentHookMismatchInDev
         );
-        _created3.return = returnFiber;
-        return _created3;
       }
-
-      throwOnInvalidObjectType(returnFiber, newChild);
+      currentHookMismatchInDev = null;
     }
+  }
+}
+
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  refOrContext,
+  nextRenderExpirationTime
+) {
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = current !== null ? current.memoizedState : null;
+
+  // The following should have already been reset
+  // currentHook = null;
+  // workInProgressHook = null;
+
+  // remainingExpirationTime = NoWork;
+  // componentUpdateQueue = null;
+
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = -1;
+
+  var children = void 0;
+  do {
+    didScheduleRenderPhaseUpdate = false;
+    numberOfReRenders += 1;
+
+    // Start over from the beginning of the list
+    currentHook = null;
+    workInProgressHook = null;
+    componentUpdateQueue = null;
+
+    children = Component(props, refOrContext);
 
     {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
+      if (
+        current !== null &&
+        workInProgressHook !== null &&
+        currentHook === null
+      ) {
+        warning$1(
+          false,
+          "%s: Rendered more hooks than during the previous render. This is " +
+            "not currently supported and may lead to unexpected behavior.",
+          getComponentName(Component)
+        );
       }
+      flushHookMismatchWarnings();
     }
+  } while (didScheduleRenderPhaseUpdate);
 
-    return null;
-  }
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
 
-  function updateSlot(returnFiber, oldFiber, newChild, expirationTime) {
-    // Update the fiber if the keys match, otherwise return null.
+  var renderedWork = currentlyRenderingFiber$1;
 
-    var key = oldFiber !== null ? oldFiber.key : null;
+  renderedWork.memoizedState = firstWorkInProgressHook;
+  renderedWork.expirationTime = remainingExpirationTime;
+  renderedWork.updateQueue = componentUpdateQueue;
 
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      // Text nodes don't have keys. If the previous node is implicitly keyed
-      // we can continue to replace it without aborting even if it is not a text
-      // node.
-      if (key !== null) {
-        return null;
-      }
-      return updateTextNode(
-        returnFiber,
-        oldFiber,
-        "" + newChild,
-        expirationTime
-      );
-    }
+  var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
 
-    if (typeof newChild === "object" && newChild !== null) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE: {
-          if (newChild.key === key) {
-            if (newChild.type === REACT_FRAGMENT_TYPE) {
-              return updateFragment(
-                returnFiber,
-                oldFiber,
-                newChild.props.children,
-                expirationTime,
-                key
-              );
-            }
-            return updateElement(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
-          } else {
-            return null;
-          }
-        }
-        case REACT_PORTAL_TYPE: {
-          if (newChild.key === key) {
-            return updatePortal(
-              returnFiber,
-              oldFiber,
-              newChild,
-              expirationTime
-            );
-          } else {
-            return null;
-          }
-        }
-      }
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-      if (isArray(newChild) || getIteratorFn(newChild)) {
-        if (key !== null) {
-          return null;
-        }
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-        return updateFragment(
-          returnFiber,
-          oldFiber,
-          newChild,
-          expirationTime,
-          null
-        );
-      }
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-      throwOnInvalidObjectType(returnFiber, newChild);
-    }
+  {
+    currentHookNameInDev = null;
+  }
 
-    {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
-      }
-    }
+  // These were reset above
+  // didScheduleRenderPhaseUpdate = false;
+  // renderPhaseUpdates = null;
+  // numberOfReRenders = -1;
 
-    return null;
+  invariant(
+    !didRenderTooFewHooks,
+    "Rendered fewer hooks than expected. This may be caused by an accidental " +
+      "early return statement."
+  );
+
+  return children;
+}
+
+function bailoutHooks(current, workInProgress, expirationTime) {
+  workInProgress.updateQueue = current.updateQueue;
+  workInProgress.effectTag &= ~(Passive | Update);
+  if (current.expirationTime <= expirationTime) {
+    current.expirationTime = NoWork;
   }
+}
 
-  function updateFromMap(
-    existingChildren,
-    returnFiber,
-    newIdx,
-    newChild,
-    expirationTime
-  ) {
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      // Text nodes don't have keys, so we neither have to check the old nor
-      // new node for the key. If both are text nodes, they match.
-      var matchedFiber = existingChildren.get(newIdx) || null;
-      return updateTextNode(
-        returnFiber,
-        matchedFiber,
-        "" + newChild,
-        expirationTime
-      );
-    }
+function resetHooks() {
+  {
+    flushHookMismatchWarnings();
+  }
 
-    if (typeof newChild === "object" && newChild !== null) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE: {
-          var _matchedFiber =
-            existingChildren.get(
-              newChild.key === null ? newIdx : newChild.key
-            ) || null;
-          if (newChild.type === REACT_FRAGMENT_TYPE) {
-            return updateFragment(
-              returnFiber,
-              _matchedFiber,
-              newChild.props.children,
-              expirationTime,
-              newChild.key
-            );
-          }
-          return updateElement(
-            returnFiber,
-            _matchedFiber,
-            newChild,
-            expirationTime
-          );
-        }
-        case REACT_PORTAL_TYPE: {
-          var _matchedFiber2 =
-            existingChildren.get(
-              newChild.key === null ? newIdx : newChild.key
-            ) || null;
-          return updatePortal(
-            returnFiber,
-            _matchedFiber2,
-            newChild,
-            expirationTime
-          );
-        }
-      }
+  // This is used to reset the state of this module when a component throws.
+  // It's also called inside mountIndeterminateComponent if we determine the
+  // component is a module-style component.
+  renderExpirationTime = NoWork;
+  currentlyRenderingFiber$1 = null;
 
-      if (isArray(newChild) || getIteratorFn(newChild)) {
-        var _matchedFiber3 = existingChildren.get(newIdx) || null;
-        return updateFragment(
-          returnFiber,
-          _matchedFiber3,
-          newChild,
-          expirationTime,
-          null
-        );
-      }
+  firstCurrentHook = null;
+  currentHook = null;
+  firstWorkInProgressHook = null;
+  workInProgressHook = null;
 
-      throwOnInvalidObjectType(returnFiber, newChild);
-    }
+  remainingExpirationTime = NoWork;
+  componentUpdateQueue = null;
 
-    {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
-      }
-    }
+  {
+    currentHookNameInDev = null;
+  }
+
+  didScheduleRenderPhaseUpdate = false;
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+}
+
+function createHook() {
+  var hook = {
+    _debugType: currentHookNameInDev,
+    memoizedState: null,
 
-    return null;
-  }
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
 
-  /**
-   * Warns if there is a duplicate or missing key
-   */
-  function warnOnInvalidKey(child, knownKeys) {
-    {
-      if (typeof child !== "object" || child === null) {
-        return knownKeys;
-      }
-      switch (child.$$typeof) {
-        case REACT_ELEMENT_TYPE:
-        case REACT_PORTAL_TYPE:
-          warnForMissingKey(child);
-          var key = child.key;
-          if (typeof key !== "string") {
-            break;
-          }
-          if (knownKeys === null) {
-            knownKeys = new Set();
-            knownKeys.add(key);
-            break;
-          }
-          if (!knownKeys.has(key)) {
-            knownKeys.add(key);
-            break;
-          }
-          warning$1(
-            false,
-            "Encountered two children with the same key, `%s`. " +
-              "Keys should be unique so that components maintain their identity " +
-              "across updates. Non-unique keys may cause children to be " +
-              "duplicated and/or omitted — the behavior is unsupported and " +
-              "could change in a future version.",
-            key
-          );
-          break;
-        default:
-          break;
-      }
-    }
-    return knownKeys;
-  }
+    next: null
+  };
 
-  function reconcileChildrenArray(
-    returnFiber,
-    currentFirstChild,
-    newChildren,
-    expirationTime
-  ) {
-    // This algorithm can't optimize by searching from boths ends since we
-    // don't have backpointers on fibers. I'm trying to see how far we can get
-    // with that model. If it ends up not being worth the tradeoffs, we can
-    // add it later.
+  return hook;
+}
 
-    // Even with a two ended optimization, we'd want to optimize for the case
-    // where there are few changes and brute force the comparison instead of
-    // going for the Map. It'd like to explore hitting that path first in
-    // forward-only mode and only go for the Map once we notice that we need
-    // lots of look ahead. This doesn't handle reversal as well as two ended
-    // search but that's unusual. Besides, for the two ended optimization to
-    // work on Iterables, we'd need to copy the whole set.
+function cloneHook(hook) {
+  var nextHook = {
+    _debugType: currentHookNameInDev,
+    memoizedState: hook.memoizedState,
 
-    // In this first iteration, we'll just live with hitting the bad case
-    // (adding everything to a Map) in for every insert/move.
+    baseState: hook.baseState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
 
-    // If you change this code, also update reconcileChildrenIterator() which
-    // uses the same algorithm.
+    next: null
+  };
 
-    {
-      // First, validate keys.
-      var knownKeys = null;
-      for (var i = 0; i < newChildren.length; i++) {
-        var child = newChildren[i];
-        knownKeys = warnOnInvalidKey(child, knownKeys);
+  {
+    if (currentHookMismatchInDev === null) {
+      if (currentHookNameInDev !== hook._debugType) {
+        currentHookMismatchInDev = new Error("tracer").stack
+          .split("\n")
+          .slice(4)
+          .join("\n");
       }
     }
+  }
+  return nextHook;
+}
 
-    var resultingFirstChild = null;
-    var previousNewFiber = null;
-
-    var oldFiber = currentFirstChild;
-    var lastPlacedIndex = 0;
-    var newIdx = 0;
-    var nextOldFiber = null;
-    for (; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
-      if (oldFiber.index > newIdx) {
-        nextOldFiber = oldFiber;
-        oldFiber = null;
+function createWorkInProgressHook() {
+  if (workInProgressHook === null) {
+    // This is the first hook in the list
+    if (firstWorkInProgressHook === null) {
+      currentHook = firstCurrentHook;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        workInProgressHook = createHook();
       } else {
-        nextOldFiber = oldFiber.sibling;
-      }
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        newChildren[newIdx],
-        expirationTime
-      );
-      if (newFiber === null) {
-        // TODO: This breaks on empty slots like null children. That's
-        // unfortunate because it triggers the slow path all the time. We need
-        // a better way to communicate whether this was a miss or null,
-        // boolean, undefined, etc.
-        if (oldFiber === null) {
-          oldFiber = nextOldFiber;
-        }
-        break;
-      }
-      if (shouldTrackSideEffects) {
-        if (oldFiber && newFiber.alternate === null) {
-          // We matched the slot, but we didn't reuse the existing fiber, so we
-          // need to delete the existing child.
-          deleteChild(returnFiber, oldFiber);
-        }
+        // Clone the current hook.
+        workInProgressHook = cloneHook(currentHook);
       }
-      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
-      if (previousNewFiber === null) {
-        // TODO: Move out of the loop. This only happens for the first run.
-        resultingFirstChild = newFiber;
+      firstWorkInProgressHook = workInProgressHook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      currentHook = firstCurrentHook;
+      workInProgressHook = firstWorkInProgressHook;
+    }
+  } else {
+    if (workInProgressHook.next === null) {
+      var hook = void 0;
+      if (currentHook === null) {
+        // This is a newly mounted hook
+        hook = createHook();
       } else {
-        // TODO: Defer siblings if we're not at the right index for this slot.
-        // I.e. if we had null values before, then we want to defer this
-        // for each null value. However, we also don't want to call updateSlot
-        // with the previous one.
-        previousNewFiber.sibling = newFiber;
+        currentHook = currentHook.next;
+        if (currentHook === null) {
+          // This is a newly mounted hook
+          hook = createHook();
+        } else {
+          // Clone the current hook.
+          hook = cloneHook(currentHook);
+        }
       }
-      previousNewFiber = newFiber;
-      oldFiber = nextOldFiber;
+      // Append to the end of the list
+      workInProgressHook = workInProgressHook.next = hook;
+    } else {
+      // There's already a work-in-progress. Reuse it.
+      workInProgressHook = workInProgressHook.next;
+      currentHook = currentHook !== null ? currentHook.next : null;
     }
+  }
+  return workInProgressHook;
+}
 
-    if (newIdx === newChildren.length) {
-      // We've reached the end of the new children. We can delete the rest.
-      deleteRemainingChildren(returnFiber, oldFiber);
-      return resultingFirstChild;
+function createFunctionComponentUpdateQueue() {
+  return {
+    lastEffect: null
+  };
+}
+
+function basicStateReducer(state, action) {
+  return typeof action === "function" ? action(state) : action;
+}
+
+function useContext(context, observedBits) {
+  {
+    currentHookNameInDev = "useContext";
+    createWorkInProgressHook();
+    currentHookNameInDev = null;
+  }
+  // Ensure we're in a function component (class components support only the
+  // .unstable_read() form)
+  resolveCurrentlyRenderingFiber();
+  return readContext(context, observedBits);
+}
+
+function useState(initialState) {
+  {
+    currentHookNameInDev = "useState";
+  }
+  return useReducer(
+    basicStateReducer,
+    // useReducer has a special case to support lazy useState initializers
+    initialState
+  );
+}
+
+function useReducer(reducer, initialState, initialAction) {
+  {
+    if (reducer !== basicStateReducer) {
+      currentHookNameInDev = "useReducer";
     }
+  }
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
+  {
+    currentHookNameInDev = null;
+  }
+  var queue = workInProgressHook.queue;
+  if (queue !== null) {
+    // Already have a queue, so this is an update.
+    if (numberOfReRenders > 0) {
+      // This is a re-render. Apply the new render phase updates to the previous
+      var _dispatch2 = queue.dispatch;
+      if (renderPhaseUpdates !== null) {
+        // Render phase updates are stored in a map of queue -> linked list
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (firstRenderPhaseUpdate !== undefined) {
+          renderPhaseUpdates.delete(queue);
+          var newState = workInProgressHook.memoizedState;
+          var update = firstRenderPhaseUpdate;
+          do {
+            // Process this render phase update. We don't have to check the
+            // priority because it will always be the same as the current
+            // render's.
+            var _action = update.action;
+            // Temporarily clear to forbid calling Hooks in a reducer.
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            newState = reducer(newState, _action);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+            update = update.next;
+          } while (update !== null);
 
-    if (oldFiber === null) {
-      // If we don't have any more existing children we can choose a fast path
-      // since the rest will all be insertions.
-      for (; newIdx < newChildren.length; newIdx++) {
-        var _newFiber = createChild(
-          returnFiber,
-          newChildren[newIdx],
-          expirationTime
-        );
-        if (!_newFiber) {
-          continue;
-        }
-        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          // TODO: Move out of the loop. This only happens for the first run.
-          resultingFirstChild = _newFiber;
-        } else {
-          previousNewFiber.sibling = _newFiber;
+          workInProgressHook.memoizedState = newState;
+
+          // Don't persist the state accumlated from the render phase updates to
+          // the base state unless the queue is empty.
+          // TODO: Not sure if this is the desired semantics, but it's what we
+          // do for gDSFP. I can't remember why.
+          if (workInProgressHook.baseUpdate === queue.last) {
+            workInProgressHook.baseState = newState;
+          }
+
+          return [newState, _dispatch2];
         }
-        previousNewFiber = _newFiber;
       }
-      return resultingFirstChild;
+      return [workInProgressHook.memoizedState, _dispatch2];
     }
 
-    // Add all children to a key map for quick lookups.
-    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
+    // The last update in the entire queue
+    var _last = queue.last;
+    // The last update that is part of the base state.
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    var _baseState = workInProgressHook.baseState;
 
-    // Keep scanning and use the map to restore deleted items as moves.
-    for (; newIdx < newChildren.length; newIdx++) {
-      var _newFiber2 = updateFromMap(
-        existingChildren,
-        returnFiber,
-        newIdx,
-        newChildren[newIdx],
-        expirationTime
-      );
-      if (_newFiber2) {
-        if (shouldTrackSideEffects) {
-          if (_newFiber2.alternate !== null) {
-            // The new fiber is a work in progress, but if there exists a
-            // current, that means that we reused the fiber. We need to delete
-            // it from the child list so that we don't add it to the deletion
-            // list.
-            existingChildren.delete(
-              _newFiber2.key === null ? newIdx : _newFiber2.key
-            );
+    // Find the first unprocessed update.
+    var first = void 0;
+    if (_baseUpdate !== null) {
+      if (_last !== null) {
+        // For the first update, the queue is a circular linked list where
+        // `queue.last.next = queue.first`. Once the first update commits, and
+        // the `baseUpdate` is no longer empty, we can unravel the list.
+        _last.next = null;
+      }
+      first = _baseUpdate.next;
+    } else {
+      first = _last !== null ? _last.next : null;
+    }
+    if (first !== null) {
+      var _newState = _baseState;
+      var newBaseState = null;
+      var newBaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      var _update = first;
+      var didSkip = false;
+      do {
+        var updateExpirationTime = _update.expirationTime;
+        if (updateExpirationTime < renderExpirationTime) {
+          // Priority is insufficient. Skip this update. If this is the first
+          // skipped update, the previous update/state is the new base
+          // update/state.
+          if (!didSkip) {
+            didSkip = true;
+            newBaseUpdate = prevUpdate;
+            newBaseState = _newState;
+          }
+          // Update the remaining priority in the queue.
+          if (updateExpirationTime > remainingExpirationTime) {
+            remainingExpirationTime = updateExpirationTime;
           }
-        }
-        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          resultingFirstChild = _newFiber2;
         } else {
-          previousNewFiber.sibling = _newFiber2;
+          // Process this update.
+          if (_update.eagerReducer === reducer) {
+            // If this update was processed eagerly, and its reducer matches the
+            // current reducer, we can use the eagerly computed state.
+            _newState = _update.eagerState;
+          } else {
+            var _action2 = _update.action;
+            // Temporarily clear to forbid calling Hooks in a reducer.
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            _newState = reducer(_newState, _action2);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+          }
         }
-        previousNewFiber = _newFiber2;
-      }
-    }
-
-    if (shouldTrackSideEffects) {
-      // Any existing children that weren't consumed above were deleted. We need
-      // to add them to the deletion list.
-      existingChildren.forEach(function(child) {
-        return deleteChild(returnFiber, child);
-      });
-    }
-
-    return resultingFirstChild;
-  }
-
-  function reconcileChildrenIterator(
-    returnFiber,
-    currentFirstChild,
-    newChildrenIterable,
-    expirationTime
-  ) {
-    // This is the same implementation as reconcileChildrenArray(),
-    // but using the iterator instead.
-
-    var iteratorFn = getIteratorFn(newChildrenIterable);
-    invariant(
-      typeof iteratorFn === "function",
-      "An object is not an iterable. This error is likely caused by a bug in " +
-        "React. Please file an issue."
-    );
+        prevUpdate = _update;
+        _update = _update.next;
+      } while (_update !== null && _update !== first);
 
-    {
-      // We don't support rendering Generators because it's a mutation.
-      // See https://github.com/facebook/react/issues/12995
-      if (
-        typeof Symbol === "function" &&
-        // $FlowFixMe Flow doesn't know about toStringTag
-        newChildrenIterable[Symbol.toStringTag] === "Generator"
-      ) {
-        !didWarnAboutGenerators
-          ? warning$1(
-              false,
-              "Using Generators as children is unsupported and will likely yield " +
-                "unexpected results because enumerating a generator mutates it. " +
-                "You may convert it to an array with `Array.from()` or the " +
-                "`[...spread]` operator before rendering. Keep in mind " +
-                "you might need to polyfill these features for older browsers."
-            )
-          : void 0;
-        didWarnAboutGenerators = true;
+      if (!didSkip) {
+        newBaseUpdate = prevUpdate;
+        newBaseState = _newState;
       }
 
-      // Warn about using Maps as children
-      if (newChildrenIterable.entries === iteratorFn) {
-        !didWarnAboutMaps
-          ? warning$1(
-              false,
-              "Using Maps as children is unsupported and will likely yield " +
-                "unexpected results. Convert it to a sequence/iterable of keyed " +
-                "ReactElements instead."
-            )
-          : void 0;
-        didWarnAboutMaps = true;
-      }
+      workInProgressHook.memoizedState = _newState;
+      workInProgressHook.baseUpdate = newBaseUpdate;
+      workInProgressHook.baseState = newBaseState;
 
-      // First, validate keys.
-      // We'll get a different iterator later for the main pass.
-      var _newChildren = iteratorFn.call(newChildrenIterable);
-      if (_newChildren) {
-        var knownKeys = null;
-        var _step = _newChildren.next();
-        for (; !_step.done; _step = _newChildren.next()) {
-          var child = _step.value;
-          knownKeys = warnOnInvalidKey(child, knownKeys);
-        }
+      // Mark that the fiber performed work, but only if the new state is
+      // different from the current state.
+      if (_newState !== currentHook.memoizedState) {
+        markWorkInProgressReceivedUpdate();
       }
-    }
-
-    var newChildren = iteratorFn.call(newChildrenIterable);
-    invariant(newChildren != null, "An iterable object provided no iterator.");
 
-    var resultingFirstChild = null;
-    var previousNewFiber = null;
+      queue.eagerReducer = reducer;
+      queue.eagerState = _newState;
+    }
 
-    var oldFiber = currentFirstChild;
-    var lastPlacedIndex = 0;
-    var newIdx = 0;
-    var nextOldFiber = null;
+    var _dispatch = queue.dispatch;
+    return [workInProgressHook.memoizedState, _dispatch];
+  }
+  // Temporarily clear to forbid calling Hooks in a reducer.
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  // There's no existing queue, so this is the initial render.
+  if (reducer === basicStateReducer) {
+    // Special case for `useState`.
+    if (typeof initialState === "function") {
+      initialState = initialState();
+    }
+  } else if (initialAction !== undefined && initialAction !== null) {
+    initialState = reducer(initialState, initialAction);
+  }
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null,
+    eagerReducer: reducer,
+    eagerState: initialState
+  };
+  var dispatch = (queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  ));
+  return [workInProgressHook.memoizedState, dispatch];
+}
 
-    var step = newChildren.next();
-    for (
-      ;
-      oldFiber !== null && !step.done;
-      newIdx++, step = newChildren.next()
-    ) {
-      if (oldFiber.index > newIdx) {
-        nextOldFiber = oldFiber;
-        oldFiber = null;
-      } else {
-        nextOldFiber = oldFiber.sibling;
-      }
-      var newFiber = updateSlot(
-        returnFiber,
-        oldFiber,
-        step.value,
-        expirationTime
-      );
-      if (newFiber === null) {
-        // TODO: This breaks on empty slots like null children. That's
-        // unfortunate because it triggers the slow path all the time. We need
-        // a better way to communicate whether this was a miss or null,
-        // boolean, undefined, etc.
-        if (!oldFiber) {
-          oldFiber = nextOldFiber;
-        }
-        break;
-      }
-      if (shouldTrackSideEffects) {
-        if (oldFiber && newFiber.alternate === null) {
-          // We matched the slot, but we didn't reuse the existing fiber, so we
-          // need to delete the existing child.
-          deleteChild(returnFiber, oldFiber);
-        }
-      }
-      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
-      if (previousNewFiber === null) {
-        // TODO: Move out of the loop. This only happens for the first run.
-        resultingFirstChild = newFiber;
-      } else {
-        // TODO: Defer siblings if we're not at the right index for this slot.
-        // I.e. if we had null values before, then we want to defer this
-        // for each null value. However, we also don't want to call updateSlot
-        // with the previous one.
-        previousNewFiber.sibling = newFiber;
-      }
-      previousNewFiber = newFiber;
-      oldFiber = nextOldFiber;
+function pushEffect(tag, create, destroy, deps) {
+  var effect = {
+    tag: tag,
+    create: create,
+    destroy: destroy,
+    deps: deps,
+    // Circular
+    next: null
+  };
+  if (componentUpdateQueue === null) {
+    componentUpdateQueue = createFunctionComponentUpdateQueue();
+    componentUpdateQueue.lastEffect = effect.next = effect;
+  } else {
+    var _lastEffect = componentUpdateQueue.lastEffect;
+    if (_lastEffect === null) {
+      componentUpdateQueue.lastEffect = effect.next = effect;
+    } else {
+      var firstEffect = _lastEffect.next;
+      _lastEffect.next = effect;
+      effect.next = firstEffect;
+      componentUpdateQueue.lastEffect = effect;
     }
+  }
+  return effect;
+}
 
-    if (step.done) {
-      // We've reached the end of the new children. We can delete the rest.
-      deleteRemainingChildren(returnFiber, oldFiber);
-      return resultingFirstChild;
+function useRef(initialValue) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  {
+    currentHookNameInDev = "useRef";
+  }
+  workInProgressHook = createWorkInProgressHook();
+  {
+    currentHookNameInDev = null;
+  }
+  var ref = void 0;
+
+  if (workInProgressHook.memoizedState === null) {
+    ref = { current: initialValue };
+    {
+      Object.seal(ref);
     }
+    workInProgressHook.memoizedState = ref;
+  } else {
+    ref = workInProgressHook.memoizedState;
+  }
+  return ref;
+}
 
-    if (oldFiber === null) {
-      // If we don't have any more existing children we can choose a fast path
-      // since the rest will all be insertions.
-      for (; !step.done; newIdx++, step = newChildren.next()) {
-        var _newFiber3 = createChild(returnFiber, step.value, expirationTime);
-        if (_newFiber3 === null) {
-          continue;
-        }
-        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          // TODO: Move out of the loop. This only happens for the first run.
-          resultingFirstChild = _newFiber3;
-        } else {
-          previousNewFiber.sibling = _newFiber3;
-        }
-        previousNewFiber = _newFiber3;
-      }
-      return resultingFirstChild;
+function useLayoutEffect(create, deps) {
+  {
+    if (currentHookNameInDev !== "useImperativeHandle") {
+      currentHookNameInDev = "useLayoutEffect";
     }
+  }
+  useEffectImpl(Update, UnmountMutation | MountLayout, create, deps);
+}
 
-    // Add all children to a key map for quick lookups.
-    var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
+function useEffect(create, deps) {
+  {
+    currentHookNameInDev = "useEffect";
+  }
+  useEffectImpl(Update | Passive, UnmountPassive | MountPassive, create, deps);
+}
 
-    // Keep scanning and use the map to restore deleted items as moves.
-    for (; !step.done; newIdx++, step = newChildren.next()) {
-      var _newFiber4 = updateFromMap(
-        existingChildren,
-        returnFiber,
-        newIdx,
-        step.value,
-        expirationTime
-      );
-      if (_newFiber4 !== null) {
-        if (shouldTrackSideEffects) {
-          if (_newFiber4.alternate !== null) {
-            // The new fiber is a work in progress, but if there exists a
-            // current, that means that we reused the fiber. We need to delete
-            // it from the child list so that we don't add it to the deletion
-            // list.
-            existingChildren.delete(
-              _newFiber4.key === null ? newIdx : _newFiber4.key
-            );
-          }
-        }
-        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
-        if (previousNewFiber === null) {
-          resultingFirstChild = _newFiber4;
-        } else {
-          previousNewFiber.sibling = _newFiber4;
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextDeps = deps === undefined ? null : deps;
+  var destroy = null;
+  if (currentHook !== null) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (nextDeps !== null) {
+      var prevDeps = prevEffect.deps;
+      if (areHookInputsEqual(nextDeps, prevDeps)) {
+        pushEffect(NoEffect$1, create, destroy, nextDeps);
+        {
+          currentHookNameInDev = null;
         }
-        previousNewFiber = _newFiber4;
+        return;
       }
     }
+  }
 
-    if (shouldTrackSideEffects) {
-      // Any existing children that weren't consumed above were deleted. We need
-      // to add them to the deletion list.
-      existingChildren.forEach(function(child) {
-        return deleteChild(returnFiber, child);
-      });
-    }
-
-    return resultingFirstChild;
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    nextDeps
+  );
+  {
+    currentHookNameInDev = null;
   }
+}
 
-  function reconcileSingleTextNode(
-    returnFiber,
-    currentFirstChild,
-    textContent,
-    expirationTime
-  ) {
-    // There's no need to check for keys on text nodes since we don't have a
-    // way to define them.
-    if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
-      // We already have an existing node so let's just update it and delete
-      // the rest.
-      deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
-      var existing = useFiber(currentFirstChild, textContent, expirationTime);
-      existing.return = returnFiber;
-      return existing;
-    }
-    // The existing first child is not a text node so we need to create one
-    // and delete the existing ones.
-    deleteRemainingChildren(returnFiber, currentFirstChild);
-    var created = createFiberFromText(
-      textContent,
-      returnFiber.mode,
-      expirationTime
-    );
-    created.return = returnFiber;
-    return created;
+function useImperativeHandle(ref, create, deps) {
+  {
+    currentHookNameInDev = "useImperativeHandle";
+    !(typeof create === "function")
+      ? warning$1(
+          false,
+          "Expected useImperativeHandle() second argument to be a function " +
+            "that creates a handle. Instead received: %s.",
+          create !== null ? typeof create : "null"
+        )
+      : void 0;
   }
+  // TODO: If deps are provided, should we skip comparing the ref itself?
+  var nextDeps =
+    deps !== null && deps !== undefined ? deps.concat([ref]) : [ref];
 
-  function reconcileSingleElement(
-    returnFiber,
-    currentFirstChild,
-    element,
-    expirationTime
-  ) {
-    var key = element.key;
-    var child = currentFirstChild;
-    while (child !== null) {
-      // TODO: If key === null and child.key === null, then this only applies to
-      // the first item in the list.
-      if (child.key === key) {
-        if (
-          child.tag === Fragment
-            ? element.type === REACT_FRAGMENT_TYPE
-            : child.elementType === element.type
-        ) {
-          deleteRemainingChildren(returnFiber, child.sibling);
-          var existing = useFiber(
-            child,
-            element.type === REACT_FRAGMENT_TYPE
-              ? element.props.children
-              : element.props,
-            expirationTime
-          );
-          existing.ref = coerceRef(returnFiber, child, element);
-          existing.return = returnFiber;
-          {
-            existing._debugSource = element._source;
-            existing._debugOwner = element._owner;
-          }
-          return existing;
-        } else {
-          deleteRemainingChildren(returnFiber, child);
-          break;
-        }
-      } else {
-        deleteChild(returnFiber, child);
+  // TODO: I've implemented this on top of useEffect because it's almost the
+  // same thing, and it would require an equal amount of code. It doesn't seem
+  // like a common enough use case to justify the additional size.
+  useLayoutEffect(function() {
+    if (typeof ref === "function") {
+      var refCallback = ref;
+      var _inst = create();
+      refCallback(_inst);
+      return function() {
+        return refCallback(null);
+      };
+    } else if (ref !== null && ref !== undefined) {
+      var refObject = ref;
+      {
+        !refObject.hasOwnProperty("current")
+          ? warning$1(
+              false,
+              "Expected useImperativeHandle() first argument to either be a " +
+                "ref callback or React.createRef() object. Instead received: %s.",
+              "an object with keys {" + Object.keys(refObject).join(", ") + "}"
+            )
+          : void 0;
       }
-      child = child.sibling;
+      var _inst2 = create();
+      refObject.current = _inst2;
+      return function() {
+        refObject.current = null;
+      };
     }
+  }, nextDeps);
+}
 
-    if (element.type === REACT_FRAGMENT_TYPE) {
-      var created = createFiberFromFragment(
-        element.props.children,
-        returnFiber.mode,
-        expirationTime,
-        element.key
-      );
-      created.return = returnFiber;
-      return created;
-    } else {
-      var _created4 = createFiberFromElement(
-        element,
-        returnFiber.mode,
-        expirationTime
-      );
-      _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
-      _created4.return = returnFiber;
-      return _created4;
-    }
+function useDebugValue(value, formatterFn) {
+  {
+    currentHookNameInDev = "useDebugValue";
   }
 
-  function reconcileSinglePortal(
-    returnFiber,
-    currentFirstChild,
-    portal,
-    expirationTime
-  ) {
-    var key = portal.key;
-    var child = currentFirstChild;
-    while (child !== null) {
-      // TODO: If key === null and child.key === null, then this only applies to
-      // the first item in the list.
-      if (child.key === key) {
-        if (
-          child.tag === HostPortal &&
-          child.stateNode.containerInfo === portal.containerInfo &&
-          child.stateNode.implementation === portal.implementation
-        ) {
-          deleteRemainingChildren(returnFiber, child.sibling);
-          var existing = useFiber(child, portal.children || [], expirationTime);
-          existing.return = returnFiber;
-          return existing;
-        } else {
-          deleteRemainingChildren(returnFiber, child);
-          break;
-        }
-      } else {
-        deleteChild(returnFiber, child);
+  // This will trigger a warning if the hook is used in a non-Function component.
+  resolveCurrentlyRenderingFiber();
+
+  // This hook is normally a no-op.
+  // The react-debug-hooks package injects its own implementation
+  // so that e.g. DevTools can display custom hook values.
+}
+
+function useCallback(callback, deps) {
+  {
+    currentHookNameInDev = "useCallback";
+  }
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+
+  var nextDeps = deps === undefined ? null : deps;
+
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    if (nextDeps !== null) {
+      var prevDeps = prevState[1];
+      if (areHookInputsEqual(nextDeps, prevDeps)) {
+        currentHookNameInDev = null;
+        return prevState[0];
       }
-      child = child.sibling;
     }
+  }
+  workInProgressHook.memoizedState = [callback, nextDeps];
+  {
+    currentHookNameInDev = null;
+  }
+  return callback;
+}
 
-    var created = createFiberFromPortal(
-      portal,
-      returnFiber.mode,
-      expirationTime
-    );
-    created.return = returnFiber;
-    return created;
+function useMemo(nextCreate, deps) {
+  {
+    currentHookNameInDev = "useMemo";
   }
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
 
-  // This API will tag the children with the side-effect of the reconciliation
-  // itself. They will be added to the side-effect list as we pass through the
-  // children and the parent.
-  function reconcileChildFibers(
-    returnFiber,
-    currentFirstChild,
-    newChild,
-    expirationTime
-  ) {
-    // This function is not recursive.
-    // If the top level item is an array, we treat it as a set of children,
-    // not as a fragment. Nested arrays on the other hand will be treated as
-    // fragment nodes. Recursion happens at the normal flow.
+  var nextDeps = deps === undefined ? null : deps;
 
-    // Handle top level unkeyed fragments as if they were arrays.
-    // This leads to an ambiguity between <>{[...]}</> and <>...</>.
-    // We treat the ambiguous cases above the same.
-    var isUnkeyedTopLevelFragment =
-      typeof newChild === "object" &&
-      newChild !== null &&
-      newChild.type === REACT_FRAGMENT_TYPE &&
-      newChild.key === null;
-    if (isUnkeyedTopLevelFragment) {
-      newChild = newChild.props.children;
+  var prevState = workInProgressHook.memoizedState;
+  if (prevState !== null) {
+    // Assume these are defined. If they're not, areHookInputsEqual will warn.
+    if (nextDeps !== null) {
+      var prevDeps = prevState[1];
+      if (areHookInputsEqual(nextDeps, prevDeps)) {
+        {
+          currentHookNameInDev = null;
+        }
+        return prevState[0];
+      }
     }
+  }
 
-    // Handle object types
-    var isObject = typeof newChild === "object" && newChild !== null;
+  // Temporarily clear to forbid calling Hooks.
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  var nextValue = nextCreate();
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = [nextValue, nextDeps];
+  {
+    currentHookNameInDev = null;
+  }
+  return nextValue;
+}
 
-    if (isObject) {
-      switch (newChild.$$typeof) {
-        case REACT_ELEMENT_TYPE:
-          return placeSingleChild(
-            reconcileSingleElement(
-              returnFiber,
-              currentFirstChild,
-              newChild,
-              expirationTime
-            )
-          );
-        case REACT_PORTAL_TYPE:
-          return placeSingleChild(
-            reconcileSinglePortal(
-              returnFiber,
-              currentFirstChild,
-              newChild,
-              expirationTime
-            )
-          );
-      }
-    }
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    numberOfReRenders < RE_RENDER_LIMIT,
+    "Too many re-renders. React limits the number of renders to prevent " +
+      "an infinite loop."
+  );
 
-    if (typeof newChild === "string" || typeof newChild === "number") {
-      return placeSingleChild(
-        reconcileSingleTextNode(
-          returnFiber,
-          currentFirstChild,
-          "" + newChild,
-          expirationTime
+  {
+    !(arguments.length <= 3)
+      ? warning$1(
+          false,
+          "State updates from the useState() and useReducer() Hooks don't support the " +
+            "second callback argument. To execute a side effect after " +
+            "rendering, declare it in the component body with useEffect()."
         )
-      );
-    }
+      : void 0;
+  }
 
-    if (isArray(newChild)) {
-      return reconcileChildrenArray(
-        returnFiber,
-        currentFirstChild,
-        newChild,
-        expirationTime
-      );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (alternate !== null && alternate === currentlyRenderingFiber$1)
+  ) {
+    // This is a render phase update. Stash it in a lazily-created map of
+    // queue -> linked list of updates. After this render pass, we'll restart
+    // and apply the stashed updates on top of the work-in-progress hook.
+    didScheduleRenderPhaseUpdate = true;
+    var update = {
+      expirationTime: renderExpirationTime,
+      action: action,
+      eagerReducer: null,
+      eagerState: null,
+      next: null
+    };
+    if (renderPhaseUpdates === null) {
+      renderPhaseUpdates = new Map();
     }
-
-    if (getIteratorFn(newChild)) {
-      return reconcileChildrenIterator(
-        returnFiber,
-        currentFirstChild,
-        newChild,
-        expirationTime
-      );
+    var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+    if (firstRenderPhaseUpdate === undefined) {
+      renderPhaseUpdates.set(queue, update);
+    } else {
+      // Append the update to the end of the list.
+      var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
+      while (lastRenderPhaseUpdate.next !== null) {
+        lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
+      }
+      lastRenderPhaseUpdate.next = update;
     }
+  } else {
+    flushPassiveEffects();
 
-    if (isObject) {
-      throwOnInvalidObjectType(returnFiber, newChild);
-    }
+    var currentTime = requestCurrentTime();
+    var _expirationTime = computeExpirationForFiber(currentTime, fiber);
 
-    {
-      if (typeof newChild === "function") {
-        warnOnFunctionType();
+    var _update2 = {
+      expirationTime: _expirationTime,
+      action: action,
+      eagerReducer: null,
+      eagerState: null,
+      next: null
+    };
+
+    // Append the update to the end of the list.
+    var _last2 = queue.last;
+    if (_last2 === null) {
+      // This is the first update. Create a circular list.
+      _update2.next = _update2;
+    } else {
+      var first = _last2.next;
+      if (first !== null) {
+        // Still circular.
+        _update2.next = first;
       }
+      _last2.next = _update2;
     }
-    if (typeof newChild === "undefined" && !isUnkeyedTopLevelFragment) {
-      // If the new child is undefined, and the return fiber is a composite
-      // component, throw an error. If Fiber return types are disabled,
-      // we already threw above.
-      switch (returnFiber.tag) {
-        case ClassComponent: {
-          {
-            var instance = returnFiber.stateNode;
-            if (instance.render._isMockFunction) {
-              // We allow auto-mocks to proceed as if they're returning null.
-              break;
-            }
+    queue.last = _update2;
+
+    if (
+      fiber.expirationTime === NoWork &&
+      (alternate === null || alternate.expirationTime === NoWork)
+    ) {
+      // The queue is currently empty, which means we can eagerly compute the
+      // next state before entering the render phase. If the new state is the
+      // same as the current state, we may be able to bail out entirely.
+      var _eagerReducer = queue.eagerReducer;
+      if (_eagerReducer !== null) {
+        try {
+          var currentState = queue.eagerState;
+          // Temporarily clear to forbid calling Hooks in a reducer.
+          var maybeFiber = currentlyRenderingFiber$1; // Note: likely null now unlike `fiber`
+          currentlyRenderingFiber$1 = null;
+          stashContextDependencies();
+          var _eagerState = _eagerReducer(currentState, action);
+          currentlyRenderingFiber$1 = maybeFiber;
+          unstashContextDependencies();
+          // Stash the eagerly computed state, and the reducer used to compute
+          // it, on the update object. If the reducer hasn't changed by the
+          // time we enter the render phase, then the eager state can be used
+          // without calling the reducer again.
+          _update2.eagerReducer = _eagerReducer;
+          _update2.eagerState = _eagerState;
+          if (_eagerState === currentState) {
+            // Fast path. We can bail out without scheduling React to re-render.
+            // It's still possible that we'll need to rebase this update later,
+            // if the component re-renders for a different reason and by that
+            // time the reducer has changed.
+            return;
           }
-        }
-        // Intentionally fall through to the next case, which handles both
-        // functions and classes
-        // eslint-disable-next-lined no-fallthrough
-        case FunctionComponent: {
-          var Component = returnFiber.type;
-          invariant(
-            false,
-            "%s(...): Nothing was returned from render. This usually means a " +
-              "return statement is missing. Or, to render nothing, " +
-              "return null.",
-            Component.displayName || Component.name || "Component"
-          );
+        } catch (error) {
+          // Suppress the error. It will throw again in the render phase.
         }
       }
     }
-
-    // Remaining cases are all treated as empty.
-    return deleteRemainingChildren(returnFiber, currentFirstChild);
+    scheduleWork(fiber, _expirationTime);
   }
+}
 
-  return reconcileChildFibers;
+var commitTime = 0;
+var profilerStartTime = -1;
+
+function getCommitTime() {
+  return commitTime;
 }
 
-var reconcileChildFibers = ChildReconciler(true);
-var mountChildFibers = ChildReconciler(false);
+function recordCommitTime() {
+  if (!enableProfilerTimer) {
+    return;
+  }
+  commitTime = now$$1();
+}
 
-function cloneChildFibers(current$$1, workInProgress) {
-  invariant(
-    current$$1 === null || workInProgress.child === current$$1.child,
-    "Resuming work not yet implemented."
-  );
+function startProfilerTimer(fiber) {
+  if (!enableProfilerTimer) {
+    return;
+  }
 
-  if (workInProgress.child === null) {
+  profilerStartTime = now$$1();
+
+  if (fiber.actualStartTime < 0) {
+    fiber.actualStartTime = now$$1();
+  }
+}
+
+function stopProfilerTimerIfRunning(fiber) {
+  if (!enableProfilerTimer) {
     return;
   }
+  profilerStartTime = -1;
+}
 
-  var currentChild = workInProgress.child;
-  var newChild = createWorkInProgress(
-    currentChild,
-    currentChild.pendingProps,
-    currentChild.expirationTime
-  );
-  workInProgress.child = newChild;
+function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
+  if (!enableProfilerTimer) {
+    return;
+  }
 
-  newChild.return = workInProgress;
-  while (currentChild.sibling !== null) {
-    currentChild = currentChild.sibling;
-    newChild = newChild.sibling = createWorkInProgress(
-      currentChild,
-      currentChild.pendingProps,
-      currentChild.expirationTime
-    );
-    newChild.return = workInProgress;
+  if (profilerStartTime >= 0) {
+    var elapsedTime = now$$1() - profilerStartTime;
+    fiber.actualDuration += elapsedTime;
+    if (overrideBaseTime) {
+      fiber.selfBaseDuration = elapsedTime;
+    }
+    profilerStartTime = -1;
   }
-  newChild.sibling = null;
 }
 
 // The deepest Fiber on the stack involved in a hydration context.
@@ -11067,6 +11112,8 @@ function resetHydrationState() {
 
 var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
 
+var didReceiveUpdate = false;
+
 var didWarnAboutBadClass = void 0;
 var didWarnAboutContextTypeOnFunctionComponent = void 0;
 var didWarnAboutGetDerivedStateOnFunctionComponent = void 0;
@@ -11176,14 +11223,45 @@ function updateForwardRef(
   // The rest is a fork of updateFunctionComponent
   var nextChildren = void 0;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
-    nextChildren = render(nextProps, ref);
+    nextChildren = renderWithHooks(
+      current$$1,
+      workInProgress,
+      render,
+      nextProps,
+      ref,
+      renderExpirationTime
+    );
+    if (
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
+    ) {
+      // Only double-render components with Hooks
+      if (workInProgress.memoizedState !== null) {
+        renderWithHooks(
+          current$$1,
+          workInProgress,
+          render,
+          nextProps,
+          ref,
+          renderExpirationTime
+        );
+      }
+    }
     setCurrentPhase(null);
   }
-  nextChildren = finishHooks(render, nextProps, nextChildren, ref);
+
+  if (current$$1 !== null && !didReceiveUpdate) {
+    bailoutHooks(current$$1, workInProgress, renderExpirationTime);
+    return bailoutOnAlreadyFinishedWork(
+      current$$1,
+      workInProgress,
+      renderExpirationTime
+    );
+  }
 
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -11335,17 +11413,20 @@ function updateSimpleMemoComponent(
       // Inner propTypes will be validated in the function component path.
     }
   }
-  if (current$$1 !== null && updateExpirationTime < renderExpirationTime) {
+  if (current$$1 !== null) {
     var prevProps = current$$1.memoizedProps;
     if (
       shallowEqual(prevProps, nextProps) &&
       current$$1.ref === workInProgress.ref
     ) {
-      return bailoutOnAlreadyFinishedWork(
-        current$$1,
-        workInProgress,
-        renderExpirationTime
-      );
+      didReceiveUpdate = false;
+      if (updateExpirationTime < renderExpirationTime) {
+        return bailoutOnAlreadyFinishedWork(
+          current$$1,
+          workInProgress,
+          renderExpirationTime
+        );
+      }
     }
   }
   return updateFunctionComponent(
@@ -11434,14 +11515,45 @@ function updateFunctionComponent(
 
   var nextChildren = void 0;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  prepareToUseHooks(current$$1, workInProgress, renderExpirationTime);
   {
     ReactCurrentOwner$3.current = workInProgress;
     setCurrentPhase("render");
-    nextChildren = Component(nextProps, context);
+    nextChildren = renderWithHooks(
+      current$$1,
+      workInProgress,
+      Component,
+      nextProps,
+      context,
+      renderExpirationTime
+    );
+    if (
+      debugRenderPhaseSideEffects ||
+      (debugRenderPhaseSideEffectsForStrictMode &&
+        workInProgress.mode & StrictMode)
+    ) {
+      // Only double-render components with Hooks
+      if (workInProgress.memoizedState !== null) {
+        renderWithHooks(
+          current$$1,
+          workInProgress,
+          Component,
+          nextProps,
+          context,
+          renderExpirationTime
+        );
+      }
+    }
     setCurrentPhase(null);
   }
-  nextChildren = finishHooks(Component, nextProps, nextChildren, context);
+
+  if (current$$1 !== null && !didReceiveUpdate) {
+    bailoutHooks(current$$1, workInProgress, renderExpirationTime);
+    return bailoutOnAlreadyFinishedWork(
+      current$$1,
+      workInProgress,
+      renderExpirationTime
+    );
+  }
 
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -11776,7 +11888,7 @@ function updateHostComponent(current$$1, workInProgress, renderExpirationTime) {
     shouldDeprioritizeSubtree(type, nextProps)
   ) {
     // Schedule this fiber to re-render at offscreen priority. Then bailout.
-    workInProgress.expirationTime = Never;
+    workInProgress.expirationTime = workInProgress.childExpirationTime = Never;
     return null;
   }
 
@@ -11829,6 +11941,9 @@ function mountLazyComponent(
   var child = void 0;
   switch (resolvedTag) {
     case FunctionComponent: {
+      {
+        validateFunctionComponentInDev(workInProgress, Component);
+      }
       child = updateFunctionComponent(
         null,
         workInProgress,
@@ -11989,7 +12104,6 @@ function mountIndeterminateComponent(
   var context = getMaskedContext(workInProgress, unmaskedContext);
 
   prepareToReadContext(workInProgress, renderExpirationTime);
-  prepareToUseHooks(null, workInProgress, renderExpirationTime);
 
   var value = void 0;
 
@@ -12017,7 +12131,14 @@ function mountIndeterminateComponent(
     }
 
     ReactCurrentOwner$3.current = workInProgress;
-    value = Component(props, context);
+    value = renderWithHooks(
+      null,
+      workInProgress,
+      Component,
+      props,
+      context,
+      renderExpirationTime
+    );
   }
   // React DevTools reads this flag.
   workInProgress.effectTag |= PerformedWork;
@@ -12071,7 +12192,25 @@ function mountIndeterminateComponent(
   } else {
     // Proceed under the assumption that this is a function component
     workInProgress.tag = FunctionComponent;
-    value = finishHooks(Component, props, value, context);
+    {
+      if (
+        debugRenderPhaseSideEffects ||
+        (debugRenderPhaseSideEffectsForStrictMode &&
+          workInProgress.mode & StrictMode)
+      ) {
+        // Only double-render components with Hooks
+        if (workInProgress.memoizedState !== null) {
+          renderWithHooks(
+            null,
+            workInProgress,
+            Component,
+            props,
+            context,
+            renderExpirationTime
+          );
+        }
+      }
+    }
     reconcileChildren(null, workInProgress, value, renderExpirationTime);
     {
       validateFunctionComponentInDev(workInProgress, Component);
@@ -12107,7 +12246,8 @@ function validateFunctionComponentInDev(workInProgress, Component) {
       warning$1(
         false,
         "Function components cannot be given refs. " +
-          "Attempts to access this ref will fail.%s",
+          "Attempts to access this ref will fail. " +
+          "Did you mean to use React.forwardRef()?%s",
         info
       );
     }
@@ -12396,6 +12536,7 @@ function updateSuspenseComponent(
         );
       }
     }
+    workInProgress.stateNode = current$$1.stateNode;
   }
 
   workInProgress.memoizedState = nextState;
@@ -12566,6 +12707,10 @@ function updateContextConsumer(
   return workInProgress.child;
 }
 
+function markWorkInProgressReceivedUpdate() {
+  didReceiveUpdate = true;
+}
+
 function bailoutOnAlreadyFinishedWork(
   current$$1,
   workInProgress,
@@ -12575,7 +12720,7 @@ function bailoutOnAlreadyFinishedWork(
 
   if (current$$1 !== null) {
     // Reuse previous context list
-    workInProgress.firstContextDependency = current$$1.firstContextDependency;
+    workInProgress.contextDependencies = current$$1.contextDependencies;
   }
 
   if (enableProfilerTimer) {
@@ -12604,11 +12749,13 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
   if (current$$1 !== null) {
     var oldProps = current$$1.memoizedProps;
     var newProps = workInProgress.pendingProps;
-    if (
-      oldProps === newProps &&
-      !hasContextChanged() &&
-      updateExpirationTime < renderExpirationTime
-    ) {
+
+    if (oldProps !== newProps || hasContextChanged()) {
+      // If props or context changed, mark the fiber as having performed work.
+      // This may be unset if the props are determined to be equal later (memo).
+      didReceiveUpdate = true;
+    } else if (updateExpirationTime < renderExpirationTime) {
+      didReceiveUpdate = false;
       // This fiber does not have any pending work. Bailout without entering
       // the begin phase. There's still some bookkeeping we that needs to be done
       // in this optimized path, mostly pushing stuff onto the stack.
@@ -12690,6 +12837,8 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         renderExpirationTime
       );
     }
+  } else {
+    didReceiveUpdate = false;
   }
 
   // Before entering the begin phase, clear the expiration time.
@@ -12819,48 +12968,358 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
           }
         }
       }
-      _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
-      return updateMemoComponent(
-        current$$1,
-        workInProgress,
-        _type2,
-        _resolvedProps3,
-        updateExpirationTime,
-        renderExpirationTime
-      );
+      _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
+      return updateMemoComponent(
+        current$$1,
+        workInProgress,
+        _type2,
+        _resolvedProps3,
+        updateExpirationTime,
+        renderExpirationTime
+      );
+    }
+    case SimpleMemoComponent: {
+      return updateSimpleMemoComponent(
+        current$$1,
+        workInProgress,
+        workInProgress.type,
+        workInProgress.pendingProps,
+        updateExpirationTime,
+        renderExpirationTime
+      );
+    }
+    case IncompleteClassComponent: {
+      var _Component3 = workInProgress.type;
+      var _unresolvedProps4 = workInProgress.pendingProps;
+      var _resolvedProps4 =
+        workInProgress.elementType === _Component3
+          ? _unresolvedProps4
+          : resolveDefaultProps(_Component3, _unresolvedProps4);
+      return mountIncompleteClassComponent(
+        current$$1,
+        workInProgress,
+        _Component3,
+        _resolvedProps4,
+        renderExpirationTime
+      );
+    }
+    default:
+      invariant(
+        false,
+        "Unknown unit of work tag. This error is likely caused by a bug in " +
+          "React. Please file an issue."
+      );
+  }
+}
+
+var valueCursor = createCursor(null);
+
+var rendererSigil = void 0;
+{
+  // Use this to detect multiple renderers using the same context
+  rendererSigil = {};
+}
+
+var currentlyRenderingFiber = null;
+var lastContextDependency = null;
+var lastContextWithAllBitsObserved = null;
+
+// We stash the variables above before entering user code in Hooks.
+var stashedCurrentlyRenderingFiber = null;
+var stashedLastContextDependency = null;
+var stashedLastContextWithAllBitsObserved = null;
+
+function resetContextDependences() {
+  // This is called right before React yields execution, to ensure `readContext`
+  // cannot be called outside the render phase.
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+
+  stashedCurrentlyRenderingFiber = null;
+  stashedLastContextDependency = null;
+  stashedLastContextWithAllBitsObserved = null;
+}
+
+function stashContextDependencies() {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+
+  currentlyRenderingFiber = null;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+}
+
+function unstashContextDependencies() {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+}
+
+function pushProvider(providerFiber, nextValue) {
+  var context = providerFiber.type._context;
+
+  if (isPrimaryRenderer) {
+    push(valueCursor, context._currentValue, providerFiber);
+
+    context._currentValue = nextValue;
+    {
+      !(
+        context._currentRenderer === undefined ||
+        context._currentRenderer === null ||
+        context._currentRenderer === rendererSigil
+      )
+        ? warningWithoutStack$1(
+            false,
+            "Detected multiple renderers concurrently rendering the " +
+              "same context provider. This is currently unsupported."
+          )
+        : void 0;
+      context._currentRenderer = rendererSigil;
+    }
+  } else {
+    push(valueCursor, context._currentValue2, providerFiber);
+
+    context._currentValue2 = nextValue;
+    {
+      !(
+        context._currentRenderer2 === undefined ||
+        context._currentRenderer2 === null ||
+        context._currentRenderer2 === rendererSigil
+      )
+        ? warningWithoutStack$1(
+            false,
+            "Detected multiple renderers concurrently rendering the " +
+              "same context provider. This is currently unsupported."
+          )
+        : void 0;
+      context._currentRenderer2 = rendererSigil;
+    }
+  }
+}
+
+function popProvider(providerFiber) {
+  var currentValue = valueCursor.current;
+
+  pop(valueCursor, providerFiber);
+
+  var context = providerFiber.type._context;
+  if (isPrimaryRenderer) {
+    context._currentValue = currentValue;
+  } else {
+    context._currentValue2 = currentValue;
+  }
+}
+
+function calculateChangedBits(context, newValue, oldValue) {
+  if (is(oldValue, newValue)) {
+    // No change
+    return 0;
+  } else {
+    var changedBits =
+      typeof context._calculateChangedBits === "function"
+        ? context._calculateChangedBits(oldValue, newValue)
+        : maxSigned31BitInt;
+
+    {
+      !((changedBits & maxSigned31BitInt) === changedBits)
+        ? warning$1(
+            false,
+            "calculateChangedBits: Expected the return value to be a " +
+              "31-bit integer. Instead received: %s",
+            changedBits
+          )
+        : void 0;
+    }
+    return changedBits | 0;
+  }
+}
+
+function propagateContextChange(
+  workInProgress,
+  context,
+  changedBits,
+  renderExpirationTime
+) {
+  var fiber = workInProgress.child;
+  if (fiber !== null) {
+    // Set the return pointer of the child to the work-in-progress fiber.
+    fiber.return = workInProgress;
+  }
+  while (fiber !== null) {
+    var nextFiber = void 0;
+
+    // Visit this fiber.
+    var list = fiber.contextDependencies;
+    if (list !== null) {
+      nextFiber = fiber.child;
+
+      var dependency = list.first;
+      while (dependency !== null) {
+        // Check if the context matches.
+        if (
+          dependency.context === context &&
+          (dependency.observedBits & changedBits) !== 0
+        ) {
+          // Match! Schedule an update on this fiber.
+
+          if (fiber.tag === ClassComponent) {
+            // Schedule a force update on the work-in-progress.
+            var update = createUpdate(renderExpirationTime);
+            update.tag = ForceUpdate;
+            // TODO: Because we don't have a work-in-progress, this will add the
+            // update to the current fiber, too, which means it will persist even if
+            // this render is thrown away. Since it's a race condition, not sure it's
+            // worth fixing.
+            enqueueUpdate(fiber, update);
+          }
+
+          if (fiber.expirationTime < renderExpirationTime) {
+            fiber.expirationTime = renderExpirationTime;
+          }
+          var alternate = fiber.alternate;
+          if (
+            alternate !== null &&
+            alternate.expirationTime < renderExpirationTime
+          ) {
+            alternate.expirationTime = renderExpirationTime;
+          }
+          // Update the child expiration time of all the ancestors, including
+          // the alternates.
+          var node = fiber.return;
+          while (node !== null) {
+            alternate = node.alternate;
+            if (node.childExpirationTime < renderExpirationTime) {
+              node.childExpirationTime = renderExpirationTime;
+              if (
+                alternate !== null &&
+                alternate.childExpirationTime < renderExpirationTime
+              ) {
+                alternate.childExpirationTime = renderExpirationTime;
+              }
+            } else if (
+              alternate !== null &&
+              alternate.childExpirationTime < renderExpirationTime
+            ) {
+              alternate.childExpirationTime = renderExpirationTime;
+            } else {
+              // Neither alternate was updated, which means the rest of the
+              // ancestor path already has sufficient priority.
+              break;
+            }
+            node = node.return;
+          }
+
+          // Mark the expiration time on the list, too.
+          if (list.expirationTime < renderExpirationTime) {
+            list.expirationTime = renderExpirationTime;
+          }
+
+          // Since we already found a match, we can stop traversing the
+          // dependency list.
+          break;
+        }
+        dependency = dependency.next;
+      }
+    } else if (fiber.tag === ContextProvider) {
+      // Don't scan deeper if this is a matching provider
+      nextFiber = fiber.type === workInProgress.type ? null : fiber.child;
+    } else {
+      // Traverse down.
+      nextFiber = fiber.child;
     }
-    case SimpleMemoComponent: {
-      return updateSimpleMemoComponent(
-        current$$1,
-        workInProgress,
-        workInProgress.type,
-        workInProgress.pendingProps,
-        updateExpirationTime,
-        renderExpirationTime
-      );
+
+    if (nextFiber !== null) {
+      // Set the return pointer of the child to the work-in-progress fiber.
+      nextFiber.return = fiber;
+    } else {
+      // No child. Traverse to next sibling.
+      nextFiber = fiber;
+      while (nextFiber !== null) {
+        if (nextFiber === workInProgress) {
+          // We're back to the root of this subtree. Exit.
+          nextFiber = null;
+          break;
+        }
+        var sibling = nextFiber.sibling;
+        if (sibling !== null) {
+          // Set the return pointer of the sibling to the work-in-progress fiber.
+          sibling.return = nextFiber.return;
+          nextFiber = sibling;
+          break;
+        }
+        // No more siblings. Traverse up.
+        nextFiber = nextFiber.return;
+      }
     }
-    case IncompleteClassComponent: {
-      var _Component3 = workInProgress.type;
-      var _unresolvedProps4 = workInProgress.pendingProps;
-      var _resolvedProps4 =
-        workInProgress.elementType === _Component3
-          ? _unresolvedProps4
-          : resolveDefaultProps(_Component3, _unresolvedProps4);
-      return mountIncompleteClassComponent(
-        current$$1,
-        workInProgress,
-        _Component3,
-        _resolvedProps4,
-        renderExpirationTime
-      );
+    fiber = nextFiber;
+  }
+}
+
+function prepareToReadContext(workInProgress, renderExpirationTime) {
+  currentlyRenderingFiber = workInProgress;
+  lastContextDependency = null;
+  lastContextWithAllBitsObserved = null;
+
+  var currentDependencies = workInProgress.contextDependencies;
+  if (
+    currentDependencies !== null &&
+    currentDependencies.expirationTime >= renderExpirationTime
+  ) {
+    // Context list has a pending update. Mark that this fiber performed work.
+    markWorkInProgressReceivedUpdate();
+  }
+
+  // Reset the work-in-progress list
+  workInProgress.contextDependencies = null;
+}
+
+function readContext(context, observedBits) {
+  if (lastContextWithAllBitsObserved === context) {
+    // Nothing to do. We already observe everything in this context.
+  } else if (observedBits === false || observedBits === 0) {
+    // Do not observe any updates.
+  } else {
+    var resolvedObservedBits = void 0; // Avoid deopting on observable arguments or heterogeneous types.
+    if (
+      typeof observedBits !== "number" ||
+      observedBits === maxSigned31BitInt
+    ) {
+      // Observe all updates.
+      lastContextWithAllBitsObserved = context;
+      resolvedObservedBits = maxSigned31BitInt;
+    } else {
+      resolvedObservedBits = observedBits;
     }
-    default:
+
+    var contextItem = {
+      context: context,
+      observedBits: resolvedObservedBits,
+      next: null
+    };
+
+    if (lastContextDependency === null) {
       invariant(
-        false,
-        "Unknown unit of work tag. This error is likely caused by a bug in " +
-          "React. Please file an issue."
+        currentlyRenderingFiber !== null,
+        "Context can only be read while React is rendering. " +
+          "In classes, you can read it in the render method or getDerivedStateFromProps. " +
+          "In function components, you can read it directly in the function body, but not " +
+          "inside Hooks like useReducer() or useMemo()."
       );
+
+      // This is the first dependency for this component. Create a new list.
+      lastContextDependency = contextItem;
+      currentlyRenderingFiber.contextDependencies = {
+        first: contextItem,
+        expirationTime: NoWork
+      };
+    } else {
+      // Append a new context item.
+      lastContextDependency = lastContextDependency.next = contextItem;
+    }
   }
+  return isPrimaryRenderer ? context._currentValue : context._currentValue2;
 }
 
 function markUpdate(workInProgress) {
@@ -13483,18 +13942,10 @@ function completeWork(current, workInProgress, renderExpirationTime) {
         }
       }
 
-      // The children either timed out after previously being visible, or
-      // were restored after previously being hidden. Schedule an effect
-      // to update their visiblity.
-      if (
-        //
-        nextDidTimeout !== prevDidTimeout ||
-        // Outside concurrent mode, the primary children commit in an
-        // inconsistent state, even if they are hidden. So if they are hidden,
-        // we need to schedule an effect to re-hide them, just in case.
-        ((workInProgress.effectTag & ConcurrentMode) === NoContext &&
-          nextDidTimeout)
-      ) {
+      if (nextDidTimeout || prevDidTimeout) {
+        // If the children are hidden, or if they were previous hidden, schedule
+        // an effect to toggle their visibility. This is also used to attach a
+        // retry listener to the promise.
         workInProgress.effectTag |= Update;
       }
       break;
@@ -13537,7 +13988,7 @@ function completeWork(current, workInProgress, renderExpirationTime) {
   return null;
 }
 
-function shouldCaptureSuspense(current, workInProgress) {
+function shouldCaptureSuspense(workInProgress) {
   // In order to capture, the Suspense component must have a fallback prop.
   if (workInProgress.memoizedProps.fallback === undefined) {
     return false;
@@ -13669,6 +14120,8 @@ var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
   didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();
 }
 
+var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
+
 function logError(boundary, errorInfo) {
   var source = errorInfo.source;
   var stack = errorInfo.stack;
@@ -13847,9 +14300,6 @@ function commitBeforeMutationLifeCycles(current$$1, finishedWork) {
 }
 
 function commitHookEffectList(unmountTag, mountTag, finishedWork) {
-  if (!enableHooks) {
-    return;
-  }
   var updateQueue = finishedWork.updateQueue;
   var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
   if (lastEffect !== null) {
@@ -14725,6 +15175,30 @@ function commitWork(current$$1, finishedWork) {
       if (primaryChildParent !== null) {
         hideOrUnhideAllChildren(primaryChildParent, newDidTimeout);
       }
+
+      // If this boundary just timed out, then it will have a set of thenables.
+      // For each thenable, attach a listener so that when it resolves, React
+      // attempts to re-render the boundary in the primary (pre-timeout) state.
+      var thenables = finishedWork.updateQueue;
+      if (thenables !== null) {
+        finishedWork.updateQueue = null;
+        var retryCache = finishedWork.stateNode;
+        if (retryCache === null) {
+          retryCache = finishedWork.stateNode = new PossiblyWeakSet();
+        }
+        thenables.forEach(function(thenable) {
+          // Memoize using the boundary fiber to prevent redundant listeners.
+          var retry = retryTimedOutBoundary.bind(null, finishedWork, thenable);
+          if (enableSchedulerTracing) {
+            retry = tracing.unstable_wrap(retry);
+          }
+          if (!retryCache.has(thenable)) {
+            retryCache.add(thenable);
+            thenable.then(retry, retry);
+          }
+        });
+      }
+
       return;
     }
     case IncompleteClassComponent: {
@@ -14747,6 +15221,8 @@ function commitResetTextContent(current$$1) {
   resetTextContent(current$$1.stateNode);
 }
 
+var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
+
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
   var update = createUpdate(expirationTime);
   // Unmount the root by rendering null.
@@ -14872,29 +15348,19 @@ function throwException(
     do {
       if (
         _workInProgress.tag === SuspenseComponent &&
-        shouldCaptureSuspense(_workInProgress.alternate, _workInProgress)
+        shouldCaptureSuspense(_workInProgress)
       ) {
         // Found the nearest boundary.
 
-        // If the boundary is not in concurrent mode, we should not suspend, and
-        // likewise, when the promise resolves, we should ping synchronously.
-        var pingTime =
-          (_workInProgress.mode & ConcurrentMode) === NoEffect
-            ? Sync
-            : renderExpirationTime;
-
-        // Attach a listener to the promise to "ping" the root and retry.
-        var onResolveOrReject = retrySuspendedRoot.bind(
-          null,
-          root,
-          _workInProgress,
-          sourceFiber,
-          pingTime
-        );
-        if (enableSchedulerTracing) {
-          onResolveOrReject = tracing.unstable_wrap(onResolveOrReject);
+        // Stash the promise on the boundary fiber. If the boundary times out, we'll
+        var thenables = _workInProgress.updateQueue;
+        if (thenables === null) {
+          var updateQueue = new Set();
+          updateQueue.add(thenable);
+          _workInProgress.updateQueue = updateQueue;
+        } else {
+          thenables.add(thenable);
         }
-        thenable.then(onResolveOrReject, onResolveOrReject);
 
         // If the boundary is outside of concurrent mode, we should *not*
         // suspend the commit. Pretend as if the suspended component rendered
@@ -14913,18 +15379,25 @@ function throwException(
           sourceFiber.effectTag &= ~(LifecycleEffectMask | Incomplete);
 
           if (sourceFiber.tag === ClassComponent) {
-            var _current = sourceFiber.alternate;
-            if (_current === null) {
+            var currentSourceFiber = sourceFiber.alternate;
+            if (currentSourceFiber === null) {
               // This is a new mount. Change the tag so it's not mistaken for a
               // completed class component. For example, we should not call
               // componentWillUnmount if it is deleted.
               sourceFiber.tag = IncompleteClassComponent;
+            } else {
+              // When we try rendering again, we should not reuse the current fiber,
+              // since it's known to be in an inconsistent state. Use a force updte to
+              // prevent a bail out.
+              var update = createUpdate(Sync);
+              update.tag = ForceUpdate;
+              enqueueUpdate(sourceFiber, update);
             }
           }
 
-          // The source fiber did not complete. Mark it with the current
-          // render priority to indicate that it still has pending work.
-          sourceFiber.expirationTime = renderExpirationTime;
+          // The source fiber did not complete. Mark it with Sync priority to
+          // indicate that it still has pending work.
+          sourceFiber.expirationTime = Sync;
 
           // Exit without suspending.
           return;
@@ -14933,6 +15406,37 @@ function throwException(
         // Confirmed that the boundary is in a concurrent mode tree. Continue
         // with the normal suspend path.
 
+        // Attach a listener to the promise to "ping" the root and retry. But
+        // only if one does not already exist for the current render expiration
+        // time (which acts like a "thread ID" here).
+        var pingCache = root.pingCache;
+        var threadIDs = void 0;
+        if (pingCache === null) {
+          pingCache = root.pingCache = new PossiblyWeakMap();
+          threadIDs = new Set();
+          pingCache.set(thenable, threadIDs);
+        } else {
+          threadIDs = pingCache.get(thenable);
+          if (threadIDs === undefined) {
+            threadIDs = new Set();
+            pingCache.set(thenable, threadIDs);
+          }
+        }
+        if (!threadIDs.has(renderExpirationTime)) {
+          // Memoize using the thread ID to prevent redundant listeners.
+          threadIDs.add(renderExpirationTime);
+          var ping = pingSuspendedRoot.bind(
+            null,
+            root,
+            thenable,
+            renderExpirationTime
+          );
+          if (enableSchedulerTracing) {
+            ping = tracing.unstable_wrap(ping);
+          }
+          thenable.then(ping, ping);
+        }
+
         var absoluteTimeoutMs = void 0;
         if (earliestTimeoutMs === -1) {
           // If no explicit threshold is given, default to an abitrarily large
@@ -15000,12 +15504,12 @@ function throwException(
         var _errorInfo = value;
         workInProgress.effectTag |= ShouldCapture;
         workInProgress.expirationTime = renderExpirationTime;
-        var update = createRootErrorUpdate(
+        var _update = createRootErrorUpdate(
           workInProgress,
           _errorInfo,
           renderExpirationTime
         );
-        enqueueCapturedUpdate(workInProgress, update);
+        enqueueCapturedUpdate(workInProgress, _update);
         return;
       }
       case ClassComponent:
@@ -15023,12 +15527,12 @@ function throwException(
           workInProgress.effectTag |= ShouldCapture;
           workInProgress.expirationTime = renderExpirationTime;
           // Schedule the error boundary to re-render using updated state
-          var _update = createClassErrorUpdate(
+          var _update2 = createClassErrorUpdate(
             workInProgress,
             errorInfo,
             renderExpirationTime
           );
-          enqueueCapturedUpdate(workInProgress, _update);
+          enqueueCapturedUpdate(workInProgress, _update2);
           return;
         }
         break;
@@ -15123,17 +15627,16 @@ var Dispatcher = {
   useCallback: useCallback,
   useContext: useContext,
   useEffect: useEffect,
-  useImperativeMethods: useImperativeMethods,
+  useImperativeHandle: useImperativeHandle,
+  useDebugValue: useDebugValue,
   useLayoutEffect: useLayoutEffect,
   useMemo: useMemo,
   useReducer: useReducer,
   useRef: useRef,
   useState: useState
 };
-var DispatcherWithoutHooks = {
-  readContext: readContext
-};
 
+var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
 var ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
 
 var didWarnAboutStateTransition = void 0;
@@ -15443,6 +15946,9 @@ function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
     }
   }
   while (nextEffect !== null) {
+    {
+      setCurrentFiber(nextEffect);
+    }
     var effectTag = nextEffect.effectTag;
 
     if (effectTag & (Update | Callback)) {
@@ -15461,12 +15967,15 @@ function commitAllLifeCycles(finishedRoot, committedExpirationTime) {
       commitAttachRef(nextEffect);
     }
 
-    if (enableHooks && effectTag & Passive) {
+    if (effectTag & Passive) {
       rootWithPendingPassiveEffects = finishedRoot;
     }
 
     nextEffect = nextEffect.nextEffect;
   }
+  {
+    resetCurrentFiber();
+  }
 }
 
 function commitPassiveEffects(root, firstEffect) {
@@ -15480,6 +15989,10 @@ function commitPassiveEffects(root, firstEffect) {
 
   var effect = firstEffect;
   do {
+    {
+      setCurrentFiber(effect);
+    }
+
     if (effect.effectTag & Passive) {
       var didError = false;
       var error = void 0;
@@ -15496,6 +16009,9 @@ function commitPassiveEffects(root, firstEffect) {
     }
     effect = effect.nextEffect;
   } while (effect !== null);
+  {
+    resetCurrentFiber();
+  }
 
   isRendering = previousIsRendering;
 
@@ -15697,11 +16213,7 @@ function commitRoot(root, finishedWork) {
     }
   }
 
-  if (
-    enableHooks &&
-    firstEffect !== null &&
-    rootWithPendingPassiveEffects !== null
-  ) {
+  if (firstEffect !== null && rootWithPendingPassiveEffects !== null) {
     // This commit included a passive effect. These do not need to fire until
     // after the next paint. Schedule an callback to fire them in an async
     // event. To ensure serial execution, the callback will be flushed early if
@@ -16132,11 +16644,7 @@ function renderRoot(root, isYieldy) {
   flushPassiveEffects();
 
   isWorking = true;
-  if (enableHooks) {
-    ReactCurrentOwner$2.currentDispatcher = Dispatcher;
-  } else {
-    ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
-  }
+  ReactCurrentDispatcher.current = Dispatcher;
 
   var expirationTime = root.nextExpirationTimeToWorkOn;
 
@@ -16190,7 +16698,7 @@ function renderRoot(root, isYieldy) {
             subscriber.onWorkStarted(interactions, threadID);
           } catch (error) {
             // Work thrown by an interaction tracing subscriber should be rethrown,
-            // But only once it's safe (to avoid leaveing the scheduler in an invalid state).
+            // But only once it's safe (to avoid leaving the scheduler in an invalid state).
             // Store the error for now and we'll re-throw in finishRendering().
             if (!hasUnhandledError) {
               hasUnhandledError = true;
@@ -16297,7 +16805,7 @@ function renderRoot(root, isYieldy) {
 
   // We're done performing work. Time to clean up.
   isWorking = false;
-  ReactCurrentOwner$2.currentDispatcher = null;
+  ReactCurrentDispatcher.current = null;
   resetContextDependences();
   resetHooks();
 
@@ -16544,56 +17052,54 @@ function renderDidError() {
   nextRenderDidError = true;
 }
 
-function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
-  var retryTime = void 0;
-
-  if (isPriorityLevelSuspended(root, suspendedTime)) {
-    // Ping at the original level
-    retryTime = suspendedTime;
+function pingSuspendedRoot(root, thenable, pingTime) {
+  // A promise that previously suspended React from committing has resolved.
+  // If React is still suspended, try again at the previous level (pingTime).
 
-    markPingedPriorityLevel(root, retryTime);
-  } else {
-    // Suspense already timed out. Compute a new expiration time
-    var currentTime = requestCurrentTime();
-    retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
-    markPendingPriorityLevel(root, retryTime);
+  var pingCache = root.pingCache;
+  if (pingCache !== null) {
+    // The thenable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    pingCache.delete(thenable);
   }
 
-  // TODO: If the suspense fiber has already rendered the primary children
-  // without suspending (that is, all of the promises have already resolved),
-  // we should not trigger another update here. One case this happens is when
-  // we are in sync mode and a single promise is thrown both on initial render
-  // and on update; we attach two .then(retrySuspendedRoot) callbacks and each
-  // one performs Sync work, rerendering the Suspense.
-
-  if ((boundaryFiber.mode & ConcurrentMode) !== NoContext) {
-    if (root === nextRoot && nextRenderExpirationTime === suspendedTime) {
-      // Received a ping at the same priority level at which we're currently
-      // rendering. Restart from the root.
-      nextRoot = null;
+  if (nextRoot !== null && nextRenderExpirationTime === pingTime) {
+    // Received a ping at the same priority level at which we're currently
+    // rendering. Restart from the root.
+    nextRoot = null;
+  } else {
+    // Confirm that the root is still suspended at this level. Otherwise exit.
+    if (isPriorityLevelSuspended(root, pingTime)) {
+      // Ping at the original level
+      markPingedPriorityLevel(root, pingTime);
+      var rootExpirationTime = root.expirationTime;
+      if (rootExpirationTime !== NoWork) {
+        requestWork(root, rootExpirationTime);
+      }
     }
   }
+}
 
-  scheduleWorkToRoot(boundaryFiber, retryTime);
-  if ((boundaryFiber.mode & ConcurrentMode) === NoContext) {
-    // Outside of concurrent mode, we must schedule an update on the source
-    // fiber, too, since it already committed in an inconsistent state and
-    // therefore does not have any pending work.
-    scheduleWorkToRoot(sourceFiber, retryTime);
-    var sourceTag = sourceFiber.tag;
-    if (sourceTag === ClassComponent && sourceFiber.stateNode !== null) {
-      // When we try rendering again, we should not reuse the current fiber,
-      // since it's known to be in an inconsistent state. Use a force updte to
-      // prevent a bail out.
-      var update = createUpdate(retryTime);
-      update.tag = ForceUpdate;
-      enqueueUpdate(sourceFiber, update);
-    }
+function retryTimedOutBoundary(boundaryFiber, thenable) {
+  // The boundary fiber (a Suspense component) previously timed out and was
+  // rendered in its fallback state. One of the promises that suspended it has
+  // resolved, which means at least part of the tree was likely unblocked. Try
+  var retryCache = boundaryFiber.stateNode;
+  if (retryCache !== null) {
+    // The thenable resolved, so we no longer need to memoize, because it will
+    // never be thrown again.
+    retryCache.delete(thenable);
   }
 
-  var rootExpirationTime = root.expirationTime;
-  if (rootExpirationTime !== NoWork) {
-    requestWork(root, rootExpirationTime);
+  var currentTime = requestCurrentTime();
+  var retryTime = computeExpirationForFiber(currentTime, boundaryFiber);
+  var root = scheduleWorkToRoot(boundaryFiber, retryTime);
+  if (root !== null) {
+    markPendingPriorityLevel(root, retryTime);
+    var rootExpirationTime = root.expirationTime;
+    if (rootExpirationTime !== NoWork) {
+      requestWork(root, rootExpirationTime);
+    }
   }
 }
 
@@ -17555,11 +18061,43 @@ function getPublicRootInstance(container) {
   }
 }
 
+var overrideProps = null;
+
+{
+  var copyWithSetImpl = function(obj, path, idx, value) {
+    if (idx >= path.length) {
+      return value;
+    }
+    var key = path[idx];
+    var updated = Array.isArray(obj) ? obj.slice() : Object.assign({}, obj);
+    // $FlowFixMe number or string is fine here
+    updated[key] = copyWithSetImpl(obj[key], path, idx + 1, value);
+    return updated;
+  };
+
+  var copyWithSet = function(obj, path, value) {
+    return copyWithSetImpl(obj, path, 0, value);
+  };
+
+  // Support DevTools props for function components, forwardRef, memo, host components, etc.
+  overrideProps = function(fiber, path, value) {
+    flushPassiveEffects();
+    fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
+    if (fiber.alternate) {
+      fiber.alternate.pendingProps = fiber.pendingProps;
+    }
+    scheduleWork(fiber, Sync);
+  };
+}
+
 function injectIntoDevTools(devToolsConfig) {
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
+  var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
 
   return injectInternals(
     Object.assign({}, devToolsConfig, {
+      overrideProps: overrideProps,
+      currentDispatcherRef: ReactCurrentDispatcher,
       findHostInstanceByFiber: function(fiber) {
         var hostFiber = findCurrentHostFiber(fiber);
         if (hostFiber === null) {
@@ -17602,7 +18140,7 @@ function createPortal(
 
 // TODO: this is special because it gets imported during build.
 
-var ReactVersion = "16.6.1";
+var ReactVersion = "16.7.0";
 
 // Modules provided by RN:
 var NativeMethodsMixin = function(findNodeHandle, findHostInstance) {
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-prod.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-prod.js
@@ -1631,8 +1631,24 @@ function finalizeInitialChildren(parentInstance) {
   return !1;
 }
 var scheduleTimeout = setTimeout,
-  cancelTimeout = clearTimeout,
-  BEFORE_SLASH_RE = /^(.*)[\\\/]/;
+  cancelTimeout = clearTimeout;
+function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps) {
+  updatePayloadTODO = instance.viewConfig;
+  instanceProps[instance._nativeTag] = newProps;
+  oldProps = diffProperties(
+    null,
+    oldProps,
+    newProps,
+    updatePayloadTODO.validAttributes
+  );
+  null != oldProps &&
+    UIManager.updateView(
+      instance._nativeTag,
+      updatePayloadTODO.uiViewClassName,
+      oldProps
+    );
+}
+var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 function getStackByFiberInDevAndProd(workInProgress) {
   var info = "";
   do {
@@ -1797,7 +1813,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
-  this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
+  this.contextDependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
   this.mode = mode;
   this.effectTag = 0;
   this.lastEffect = this.firstEffect = this.nextEffect = null;
@@ -1846,7 +1862,7 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.firstContextDependency = current.firstContextDependency;
+  workInProgress.contextDependencies = current.contextDependencies;
   workInProgress.sibling = current.sibling;
   workInProgress.index = current.index;
   workInProgress.ref = current.ref;
@@ -1972,24 +1988,21 @@ function markPendingPriorityLevel(root, expirationTime) {
 }
 function markSuspendedPriorityLevel(root, suspendedTime) {
   root.didError = !1;
-  var latestPingedTime = root.latestPingedTime;
-  0 !== latestPingedTime &&
-    latestPingedTime >= suspendedTime &&
-    (root.latestPingedTime = 0);
-  latestPingedTime = root.earliestPendingTime;
-  var latestPendingTime = root.latestPendingTime;
-  latestPingedTime === suspendedTime
+  root.latestPingedTime >= suspendedTime && (root.latestPingedTime = 0);
+  var earliestPendingTime = root.earliestPendingTime,
+    latestPendingTime = root.latestPendingTime;
+  earliestPendingTime === suspendedTime
     ? (root.earliestPendingTime =
         latestPendingTime === suspendedTime
           ? (root.latestPendingTime = 0)
           : latestPendingTime)
     : latestPendingTime === suspendedTime &&
-      (root.latestPendingTime = latestPingedTime);
-  latestPingedTime = root.earliestSuspendedTime;
+      (root.latestPendingTime = earliestPendingTime);
+  earliestPendingTime = root.earliestSuspendedTime;
   latestPendingTime = root.latestSuspendedTime;
-  0 === latestPingedTime
+  0 === earliestPendingTime
     ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
-    : latestPingedTime < suspendedTime
+    : earliestPendingTime < suspendedTime
       ? (root.earliestSuspendedTime = suspendedTime)
       : latestPendingTime > suspendedTime &&
         (root.latestSuspendedTime = suspendedTime);
@@ -2256,93 +2269,10 @@ function createCapturedValue(value, source) {
     stack: getStackByFiberInDevAndProd(source)
   };
 }
-var valueCursor = { current: null },
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastContextWithAllBitsObserved = null;
-function pushProvider(providerFiber, nextValue) {
-  var context = providerFiber.type._context;
-  push(valueCursor, context._currentValue, providerFiber);
-  context._currentValue = nextValue;
-}
-function popProvider(providerFiber) {
-  var currentValue = valueCursor.current;
-  pop(valueCursor, providerFiber);
-  providerFiber.type._context._currentValue = currentValue;
-}
-function prepareToReadContext(workInProgress) {
-  currentlyRenderingFiber = workInProgress;
-  lastContextWithAllBitsObserved = lastContextDependency = null;
-  workInProgress.firstContextDependency = null;
-}
-function readContext(context, observedBits) {
-  if (
-    lastContextWithAllBitsObserved !== context &&
-    !1 !== observedBits &&
-    0 !== observedBits
-  ) {
-    if ("number" !== typeof observedBits || 1073741823 === observedBits)
-      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
-    observedBits = { context: context, observedBits: observedBits, next: null };
-    null === lastContextDependency
-      ? (invariant(
-          null !== currentlyRenderingFiber,
-          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
-        ),
-        (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
-      : (lastContextDependency = lastContextDependency.next = observedBits);
-  }
-  return context._currentValue;
-}
-var NO_CONTEXT = {},
-  contextStackCursor$1 = { current: NO_CONTEXT },
-  contextFiberStackCursor = { current: NO_CONTEXT },
-  rootInstanceStackCursor = { current: NO_CONTEXT };
-function requiredContext(c) {
-  invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
-  );
-  return c;
-}
-function pushHostContainer(fiber, nextRootInstance) {
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
-}
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
-}
-function pushHostContext(fiber) {
-  requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = fiber.type;
-  nextContext =
-    "AndroidTextInput" === nextContext ||
-    "RCTMultilineTextInputView" === nextContext ||
-    "RCTSinglelineTextInputView" === nextContext ||
-    "RCTText" === nextContext ||
-    "RCTVirtualText" === nextContext;
-  nextContext =
-    context.isInAParentText !== nextContext
-      ? { isInAParentText: nextContext }
-      : context;
-  context !== nextContext &&
-    (push(contextFiberStackCursor, fiber, fiber),
-    push(contextStackCursor$1, nextContext, fiber));
-}
-function popHostContext(fiber) {
-  contextFiberStackCursor.current === fiber &&
-    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty;
 function is(x, y) {
-  return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
+  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (is(objA, objB)) return !0;
   if (
@@ -2383,9 +2313,9 @@ function readLazyComponentType(lazyComponent) {
     case 0:
       throw result;
     default:
-      throw ((lazyComponent._status = 0),
-      (result = lazyComponent._ctor),
-      (result = result()),
+      lazyComponent._status = 0;
+      result = lazyComponent._ctor;
+      result = result();
       result.then(
         function(moduleObject) {
           0 === lazyComponent._status &&
@@ -2397,13 +2327,18 @@ function readLazyComponentType(lazyComponent) {
           0 === lazyComponent._status &&
             ((lazyComponent._status = 2), (lazyComponent._result = error));
         }
-      ),
-      (lazyComponent._result = result),
-      result);
+      );
+      switch (lazyComponent._status) {
+        case 1:
+          return lazyComponent._result;
+        case 2:
+          throw lazyComponent._result;
+      }
+      lazyComponent._result = result;
+      throw result;
   }
 }
-var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
-  emptyRefsObject = new React.Component().refs;
+var emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2484,7 +2419,7 @@ function constructClassInstance(workInProgress, ctor, props) {
     unmaskedContext = emptyContextObject;
   var context = ctor.contextType;
   "object" === typeof context && null !== context
-    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    ? (context = readContext(context))
     : ((unmaskedContext = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2531,9 +2466,7 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
-        contextType
-      ))
+    ? (instance.context = readContext(contextType))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2588,7 +2521,10 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(1 === element.tag, "Function components cannot have refs."),
+        (invariant(
+          1 === element.tag,
+          "Function components cannot have refs. Did you mean to use React.forwardRef()?"
+        ),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -3288,7 +3224,367 @@ function ChildReconciler(shouldTrackSideEffects) {
 }
 var reconcileChildFibers = ChildReconciler(!0),
   mountChildFibers = ChildReconciler(!1),
-  hydrationParentFiber = null,
+  NO_CONTEXT = {},
+  contextStackCursor$1 = { current: NO_CONTEXT },
+  contextFiberStackCursor = { current: NO_CONTEXT },
+  rootInstanceStackCursor = { current: NO_CONTEXT };
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
+  );
+  return c;
+}
+function pushHostContainer(fiber, nextRootInstance) {
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
+}
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+function pushHostContext(fiber) {
+  requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = fiber.type;
+  nextContext =
+    "AndroidTextInput" === nextContext ||
+    "RCTMultilineTextInputView" === nextContext ||
+    "RCTSinglelineTextInputView" === nextContext ||
+    "RCTText" === nextContext ||
+    "RCTVirtualText" === nextContext;
+  nextContext =
+    context.isInAParentText !== nextContext
+      ? { isInAParentText: nextContext }
+      : context;
+  context !== nextContext &&
+    (push(contextFiberStackCursor, fiber, fiber),
+    push(contextStackCursor$1, nextContext, fiber));
+}
+function popHostContext(fiber) {
+  contextFiberStackCursor.current === fiber &&
+    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
+}
+var NoEffect$1 = 0,
+  UnmountSnapshot = 2,
+  UnmountMutation = 4,
+  MountMutation = 8,
+  UnmountLayout = 16,
+  MountLayout = 32,
+  MountPassive = 64,
+  UnmountPassive = 128,
+  renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = -1;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (null === prevDeps) return !1;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+    if (!is(nextDeps[i], prevDeps[i])) return !1;
+  return !0;
+}
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  refOrContext,
+  nextRenderExpirationTime
+) {
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current ? current.memoizedState : null;
+  do
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (current = Component(props, refOrContext));
+  while (didScheduleRenderPhaseUpdate);
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return current;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.baseState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (0 < numberOfReRenders) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do {
+            var _action = firstRenderPhaseUpdate.action;
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            initialAction = reducer(initialAction, _action);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+            firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
+          } while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    initialAction = workInProgressHook.baseState;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      _action = firstRenderPhaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      _baseUpdate = initialState;
+      var didSkip = !1;
+      do {
+        var updateExpirationTime = _baseUpdate.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (_action = prevUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : _baseUpdate.eagerReducer === reducer
+            ? (initialAction = _baseUpdate.eagerState)
+            : ((prevUpdate = _baseUpdate.action),
+              (currentlyRenderingFiber$1 = null),
+              stashContextDependencies(),
+              (initialAction = reducer(initialAction, prevUpdate)),
+              (currentlyRenderingFiber$1 = fiber),
+              unstashContextDependencies());
+        prevUpdate = _baseUpdate;
+        _baseUpdate = _baseUpdate.next;
+      } while (null !== _baseUpdate && _baseUpdate !== initialState);
+      didSkip ||
+        ((_action = prevUpdate), (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = _action;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+      initialAction !== currentHook.memoizedState && (didReceiveUpdate = !0);
+      queue.eagerReducer = reducer;
+      queue.eagerState = initialAction;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null,
+    eagerReducer: reducer,
+    eagerState: initialState
+  };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, deps) {
+  tag = { tag: tag, create: create, destroy: destroy, deps: deps, next: null };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useLayoutEffect(create, deps) {
+  useEffectImpl(4, UnmountMutation | MountLayout, create, deps);
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
+      pushEffect(NoEffect$1, create, destroy, deps);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    deps
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (action = renderPhaseUpdates.get(queue)),
+      void 0 === action)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = action; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    flushPassiveEffects();
+    var currentTime = requestCurrentTime();
+    currentTime = computeExpirationForFiber(currentTime, fiber);
+    var _update2 = {
+        expirationTime: currentTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      },
+      _last2 = queue.last;
+    if (null === _last2) _update2.next = _update2;
+    else {
+      var first = _last2.next;
+      null !== first && (_update2.next = first);
+      _last2.next = _update2;
+    }
+    queue.last = _update2;
+    if (
+      0 === fiber.expirationTime &&
+      (null === alternate || 0 === alternate.expirationTime) &&
+      ((alternate = queue.eagerReducer), null !== alternate)
+    )
+      try {
+        var currentState = queue.eagerState;
+        queue = currentlyRenderingFiber$1;
+        currentlyRenderingFiber$1 = null;
+        stashContextDependencies();
+        var _eagerState = alternate(currentState, action);
+        currentlyRenderingFiber$1 = queue;
+        unstashContextDependencies();
+        _update2.eagerReducer = alternate;
+        _update2.eagerState = _eagerState;
+        if (_eagerState === currentState) return;
+      } catch (error) {}
+    scheduleWork(fiber, currentTime);
+  }
+}
+var hydrationParentFiber = null,
   nextHydratableInstance = null,
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
@@ -3340,7 +3636,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
+var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner,
+  didReceiveUpdate = !1;
 function reconcileChildren(
   current$$1,
   workInProgress,
@@ -3372,7 +3669,26 @@ function updateForwardRef(
   Component = Component.render;
   var ref = workInProgress.ref;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  nextProps = Component(nextProps, ref);
+  nextProps = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    ref,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3452,9 +3768,9 @@ function updateSimpleMemoComponent(
   renderExpirationTime
 ) {
   return null !== current$$1 &&
-    updateExpirationTime < renderExpirationTime &&
     shallowEqual(current$$1.memoizedProps, nextProps) &&
-    current$$1.ref === workInProgress.ref
+    current$$1.ref === workInProgress.ref &&
+    ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
     ? bailoutOnAlreadyFinishedWork(
         current$$1,
         workInProgress,
@@ -3488,7 +3804,26 @@ function updateFunctionComponent(
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
   prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  Component = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    unmaskedContext,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3535,9 +3870,7 @@ function updateClassComponent(
     var oldContext = instance.context,
       contextType = Component.contextType;
     "object" === typeof contextType && null !== contextType
-      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-          contextType
-        ))
+      ? (contextType = readContext(contextType))
       : ((contextType = isContextProvider(Component)
           ? previousContext
           : contextStackCursor.current),
@@ -3622,9 +3955,7 @@ function updateClassComponent(
       (oldContext = instance.context),
       (contextType = Component.contextType),
       "object" === typeof contextType && null !== contextType
-        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-            contextType
-          ))
+        ? (contextType = readContext(contextType))
         : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
@@ -3805,33 +4136,35 @@ function updateSuspenseComponent(
     (nextState = { timedOutAt: null !== nextState ? nextState.timedOutAt : 0 }),
       (nextDidTimeout = !0),
       (workInProgress.effectTag &= -65);
-  null === current$$1
-    ? nextDidTimeout
-      ? ((nextDidTimeout = nextProps.fallback),
-        (nextProps = createFiberFromFragment(null, mode, 0, null)),
-        0 === (workInProgress.mode & 1) &&
-          (nextProps.child =
-            null !== workInProgress.memoizedState
-              ? workInProgress.child.child
-              : workInProgress.child),
-        (mode = createFiberFromFragment(
-          nextDidTimeout,
-          mode,
-          renderExpirationTime,
-          null
-        )),
-        (nextProps.sibling = mode),
-        (renderExpirationTime = nextProps),
-        (renderExpirationTime.return = mode.return = workInProgress))
-      : (renderExpirationTime = mode = mountChildFibers(
-          workInProgress,
-          null,
-          nextProps.children,
-          renderExpirationTime
-        ))
-    : null !== current$$1.memoizedState
+  if (null === current$$1)
+    if (nextDidTimeout) {
+      var nextFallbackChildren = nextProps.fallback;
+      current$$1 = createFiberFromFragment(null, mode, 0, null);
+      0 === (workInProgress.mode & 1) &&
+        (current$$1.child =
+          null !== workInProgress.memoizedState
+            ? workInProgress.child.child
+            : workInProgress.child);
+      mode = createFiberFromFragment(
+        nextFallbackChildren,
+        mode,
+        renderExpirationTime,
+        null
+      );
+      current$$1.sibling = mode;
+      renderExpirationTime = current$$1;
+      renderExpirationTime.return = mode.return = workInProgress;
+    } else
+      renderExpirationTime = mode = mountChildFibers(
+        workInProgress,
+        null,
+        nextProps.children,
+        renderExpirationTime
+      );
+  else
+    null !== current$$1.memoizedState
       ? ((mode = current$$1.child),
-        (current$$1 = mode.sibling),
+        (nextFallbackChildren = mode.sibling),
         nextDidTimeout
           ? ((renderExpirationTime = nextProps.fallback),
             (nextProps = createWorkInProgress(mode, mode.pendingProps, 0)),
@@ -3843,9 +4176,9 @@ function updateSuspenseComponent(
               nextDidTimeout !== mode.child &&
                 (nextProps.child = nextDidTimeout)),
             (mode = nextProps.sibling = createWorkInProgress(
-              current$$1,
+              nextFallbackChildren,
               renderExpirationTime,
-              current$$1.expirationTime
+              nextFallbackChildren.expirationTime
             )),
             (renderExpirationTime = nextProps),
             (nextProps.childExpirationTime = 0),
@@ -3856,11 +4189,11 @@ function updateSuspenseComponent(
               nextProps.children,
               renderExpirationTime
             )))
-      : ((current$$1 = current$$1.child),
+      : ((nextFallbackChildren = current$$1.child),
         nextDidTimeout
           ? ((nextDidTimeout = nextProps.fallback),
             (nextProps = createFiberFromFragment(null, mode, 0, null)),
-            (nextProps.child = current$$1),
+            (nextProps.child = nextFallbackChildren),
             0 === (workInProgress.mode & 1) &&
               (nextProps.child =
                 null !== workInProgress.memoizedState
@@ -3878,10 +4211,11 @@ function updateSuspenseComponent(
             (renderExpirationTime.return = mode.return = workInProgress))
           : (mode = renderExpirationTime = reconcileChildFibers(
               workInProgress,
-              current$$1,
+              nextFallbackChildren,
               nextProps.children,
               renderExpirationTime
-            )));
+            ))),
+      (workInProgress.stateNode = current$$1.stateNode);
   workInProgress.memoizedState = nextState;
   workInProgress.child = renderExpirationTime;
   return mode;
@@ -3892,7 +4226,7 @@ function bailoutOnAlreadyFinishedWork(
   renderExpirationTime
 ) {
   null !== current$$1 &&
-    (workInProgress.firstContextDependency = current$$1.firstContextDependency);
+    (workInProgress.contextDependencies = current$$1.contextDependencies);
   if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
     null === current$$1 || workInProgress.child === current$$1.child,
@@ -3924,58 +4258,63 @@ function bailoutOnAlreadyFinishedWork(
 }
 function beginWork(current$$1, workInProgress, renderExpirationTime) {
   var updateExpirationTime = workInProgress.expirationTime;
-  if (
-    null !== current$$1 &&
-    current$$1.memoizedProps === workInProgress.pendingProps &&
-    !didPerformWorkStackCursor.current &&
-    updateExpirationTime < renderExpirationTime
-  ) {
-    switch (workInProgress.tag) {
-      case 3:
-        pushHostRootContext(workInProgress);
-        break;
-      case 5:
-        pushHostContext(workInProgress);
-        break;
-      case 1:
-        isContextProvider(workInProgress.type) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 4:
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        );
-        break;
-      case 10:
-        pushProvider(workInProgress, workInProgress.memoizedProps.value);
-        break;
-      case 13:
-        if (null !== workInProgress.memoizedState) {
-          updateExpirationTime = workInProgress.child.childExpirationTime;
-          if (
-            0 !== updateExpirationTime &&
-            updateExpirationTime >= renderExpirationTime
-          )
-            return updateSuspenseComponent(
-              current$$1,
+  if (null !== current$$1)
+    if (
+      current$$1.memoizedProps !== workInProgress.pendingProps ||
+      didPerformWorkStackCursor.current
+    )
+      didReceiveUpdate = !0;
+    else {
+      if (updateExpirationTime < renderExpirationTime) {
+        didReceiveUpdate = !1;
+        switch (workInProgress.tag) {
+          case 3:
+            pushHostRootContext(workInProgress);
+            break;
+          case 5:
+            pushHostContext(workInProgress);
+            break;
+          case 1:
+            isContextProvider(workInProgress.type) &&
+              pushContextProvider(workInProgress);
+            break;
+          case 4:
+            pushHostContainer(
               workInProgress,
-              renderExpirationTime
+              workInProgress.stateNode.containerInfo
             );
-          workInProgress = bailoutOnAlreadyFinishedWork(
-            current$$1,
-            workInProgress,
-            renderExpirationTime
-          );
-          return null !== workInProgress ? workInProgress.sibling : null;
+            break;
+          case 10:
+            pushProvider(workInProgress, workInProgress.memoizedProps.value);
+            break;
+          case 13:
+            if (null !== workInProgress.memoizedState) {
+              updateExpirationTime = workInProgress.child.childExpirationTime;
+              if (
+                0 !== updateExpirationTime &&
+                updateExpirationTime >= renderExpirationTime
+              )
+                return updateSuspenseComponent(
+                  current$$1,
+                  workInProgress,
+                  renderExpirationTime
+                );
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+              return null !== workInProgress ? workInProgress.sibling : null;
+            }
         }
+        return bailoutOnAlreadyFinishedWork(
+          current$$1,
+          workInProgress,
+          renderExpirationTime
+        );
+      }
     }
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  }
+  else didReceiveUpdate = !1;
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
     case 2:
@@ -3990,7 +4329,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         contextStackCursor.current
       );
       prepareToReadContext(workInProgress, renderExpirationTime);
-      context = updateExpirationTime(current$$1, context);
+      context = renderWithHooks(
+        null,
+        workInProgress,
+        updateExpirationTime,
+        current$$1,
+        context,
+        renderExpirationTime
+      );
       workInProgress.effectTag |= 1;
       if (
         "object" === typeof context &&
@@ -3999,6 +4345,7 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         void 0 === context.$$typeof
       ) {
         workInProgress.tag = 1;
+        resetHooks();
         if (isContextProvider(updateExpirationTime)) {
           var hasContext = !0;
           pushContextProvider(workInProgress);
@@ -4270,18 +4617,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         pushProvider(workInProgress, hasContext);
         if (null !== getDerivedStateFromProps) {
           var oldValue = getDerivedStateFromProps.value;
-          hasContext =
-            (oldValue === hasContext &&
-              (0 !== oldValue || 1 / oldValue === 1 / hasContext)) ||
-            (oldValue !== oldValue && hasContext !== hasContext)
-              ? 0
-              : ("function" ===
-                typeof updateExpirationTime._calculateChangedBits
-                  ? updateExpirationTime._calculateChangedBits(
-                      oldValue,
-                      hasContext
-                    )
-                  : 1073741823) | 0;
+          hasContext = is(oldValue, hasContext)
+            ? 0
+            : ("function" === typeof updateExpirationTime._calculateChangedBits
+                ? updateExpirationTime._calculateChangedBits(
+                    oldValue,
+                    hasContext
+                  )
+                : 1073741823) | 0;
           if (0 === hasContext) {
             if (
               getDerivedStateFromProps.children === context.children &&
@@ -4296,83 +4639,79 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
             }
           } else
             for (
-              getDerivedStateFromProps = workInProgress.child,
-                null !== getDerivedStateFromProps &&
-                  (getDerivedStateFromProps.return = workInProgress);
-              null !== getDerivedStateFromProps;
+              oldValue = workInProgress.child,
+                null !== oldValue && (oldValue.return = workInProgress);
+              null !== oldValue;
 
             ) {
-              oldValue = getDerivedStateFromProps.firstContextDependency;
-              if (null !== oldValue) {
-                do {
+              var list = oldValue.contextDependencies;
+              if (null !== list) {
+                getDerivedStateFromProps = oldValue.child;
+                for (var dependency = list.first; null !== dependency; ) {
                   if (
-                    oldValue.context === updateExpirationTime &&
-                    0 !== (oldValue.observedBits & hasContext)
+                    dependency.context === updateExpirationTime &&
+                    0 !== (dependency.observedBits & hasContext)
                   ) {
-                    if (1 === getDerivedStateFromProps.tag) {
-                      var nextFiber = createUpdate(renderExpirationTime);
-                      nextFiber.tag = 2;
-                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
-                    }
-                    getDerivedStateFromProps.expirationTime <
-                      renderExpirationTime &&
-                      (getDerivedStateFromProps.expirationTime = renderExpirationTime);
-                    nextFiber = getDerivedStateFromProps.alternate;
-                    null !== nextFiber &&
-                      nextFiber.expirationTime < renderExpirationTime &&
-                      (nextFiber.expirationTime = renderExpirationTime);
-                    for (
-                      var node = getDerivedStateFromProps.return;
-                      null !== node;
-
-                    ) {
-                      nextFiber = node.alternate;
+                    1 === oldValue.tag &&
+                      ((dependency = createUpdate(renderExpirationTime)),
+                      (dependency.tag = 2),
+                      enqueueUpdate(oldValue, dependency));
+                    oldValue.expirationTime < renderExpirationTime &&
+                      (oldValue.expirationTime = renderExpirationTime);
+                    dependency = oldValue.alternate;
+                    null !== dependency &&
+                      dependency.expirationTime < renderExpirationTime &&
+                      (dependency.expirationTime = renderExpirationTime);
+                    for (var node = oldValue.return; null !== node; ) {
+                      dependency = node.alternate;
                       if (node.childExpirationTime < renderExpirationTime)
                         (node.childExpirationTime = renderExpirationTime),
-                          null !== nextFiber &&
-                            nextFiber.childExpirationTime <
+                          null !== dependency &&
+                            dependency.childExpirationTime <
                               renderExpirationTime &&
-                            (nextFiber.childExpirationTime = renderExpirationTime);
+                            (dependency.childExpirationTime = renderExpirationTime);
                       else if (
-                        null !== nextFiber &&
-                        nextFiber.childExpirationTime < renderExpirationTime
+                        null !== dependency &&
+                        dependency.childExpirationTime < renderExpirationTime
                       )
-                        nextFiber.childExpirationTime = renderExpirationTime;
+                        dependency.childExpirationTime = renderExpirationTime;
                       else break;
                       node = node.return;
                     }
+                    list.expirationTime < renderExpirationTime &&
+                      (list.expirationTime = renderExpirationTime);
+                    break;
                   }
-                  nextFiber = getDerivedStateFromProps.child;
-                  oldValue = oldValue.next;
-                } while (null !== oldValue);
+                  dependency = dependency.next;
+                }
               } else
-                nextFiber =
-                  10 === getDerivedStateFromProps.tag
-                    ? getDerivedStateFromProps.type === workInProgress.type
+                getDerivedStateFromProps =
+                  10 === oldValue.tag
+                    ? oldValue.type === workInProgress.type
                       ? null
-                      : getDerivedStateFromProps.child
-                    : getDerivedStateFromProps.child;
-              if (null !== nextFiber)
-                nextFiber.return = getDerivedStateFromProps;
+                      : oldValue.child
+                    : oldValue.child;
+              if (null !== getDerivedStateFromProps)
+                getDerivedStateFromProps.return = oldValue;
               else
                 for (
-                  nextFiber = getDerivedStateFromProps;
-                  null !== nextFiber;
+                  getDerivedStateFromProps = oldValue;
+                  null !== getDerivedStateFromProps;
 
                 ) {
-                  if (nextFiber === workInProgress) {
-                    nextFiber = null;
+                  if (getDerivedStateFromProps === workInProgress) {
+                    getDerivedStateFromProps = null;
                     break;
                   }
-                  getDerivedStateFromProps = nextFiber.sibling;
-                  if (null !== getDerivedStateFromProps) {
-                    getDerivedStateFromProps.return = nextFiber.return;
-                    nextFiber = getDerivedStateFromProps;
+                  oldValue = getDerivedStateFromProps.sibling;
+                  if (null !== oldValue) {
+                    oldValue.return = getDerivedStateFromProps.return;
+                    getDerivedStateFromProps = oldValue;
                     break;
                   }
-                  nextFiber = nextFiber.return;
+                  getDerivedStateFromProps = getDerivedStateFromProps.return;
                 }
-              getDerivedStateFromProps = nextFiber;
+              oldValue = getDerivedStateFromProps;
             }
         }
         reconcileChildren(
@@ -4472,6 +4811,69 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
+var valueCursor = { current: null },
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastContextWithAllBitsObserved = null,
+  stashedCurrentlyRenderingFiber = null,
+  stashedLastContextDependency = null,
+  stashedLastContextWithAllBitsObserved = null;
+function resetContextDependences() {
+  stashedLastContextWithAllBitsObserved = stashedLastContextDependency = stashedCurrentlyRenderingFiber = lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function stashContextDependencies() {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function unstashContextDependencies() {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+}
+function pushProvider(providerFiber, nextValue) {
+  var context = providerFiber.type._context;
+  push(valueCursor, context._currentValue, providerFiber);
+  context._currentValue = nextValue;
+}
+function popProvider(providerFiber) {
+  var currentValue = valueCursor.current;
+  pop(valueCursor, providerFiber);
+  providerFiber.type._context._currentValue = currentValue;
+}
+function prepareToReadContext(workInProgress, renderExpirationTime) {
+  currentlyRenderingFiber = workInProgress;
+  lastContextWithAllBitsObserved = lastContextDependency = null;
+  var currentDependencies = workInProgress.contextDependencies;
+  null !== currentDependencies &&
+    currentDependencies.expirationTime >= renderExpirationTime &&
+    (didReceiveUpdate = !0);
+  workInProgress.contextDependencies = null;
+}
+function readContext(context, observedBits) {
+  if (
+    lastContextWithAllBitsObserved !== context &&
+    !1 !== observedBits &&
+    0 !== observedBits
+  ) {
+    if ("number" !== typeof observedBits || 1073741823 === observedBits)
+      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
+    observedBits = { context: context, observedBits: observedBits, next: null };
+    null === lastContextDependency
+      ? (invariant(
+          null !== currentlyRenderingFiber,
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        ),
+        (lastContextDependency = observedBits),
+        (currentlyRenderingFiber.contextDependencies = {
+          first: observedBits,
+          expirationTime: 0
+        }))
+      : (lastContextDependency = lastContextDependency.next = observedBits);
+  }
+  return context._currentValue;
+}
 var appendAllChildren = void 0,
   updateHostContainer = void 0,
   updateHostComponent$1 = void 0,
@@ -4522,6 +4924,7 @@ function logCapturedError(capturedError) {
         : Error("Unspecified error at:" + componentStack);
   ExceptionsManager.handleException(error, !1);
 }
+var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
 function logError(boundary, errorInfo) {
   var source = errorInfo.source,
     stack = errorInfo.stack;
@@ -4562,6 +4965,84 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & unmountTag) !== NoEffect$1) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      (effect.tag & mountTag) !== NoEffect$1 &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function hideOrUnhideAllChildren(finishedWork, isHidden) {
+  for (var node = finishedWork; ; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (isHidden) {
+        var viewConfig = instance.viewConfig;
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          { style: { display: "none" } },
+          viewConfig.validAttributes
+        );
+        UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      } else {
+        instance = node.stateNode;
+        updatePayload = node.memoizedProps;
+        viewConfig = instance.viewConfig;
+        var prevProps = Object.assign({}, updatePayload, {
+          style: [updatePayload.style, { display: "none" }]
+        });
+        updatePayload = diffProperties(
+          null,
+          prevProps,
+          updatePayload,
+          viewConfig.validAttributes
+        );
+        UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      }
+    } else {
+      if (6 === node.tag) throw Error("Not yet implemented.");
+      if (13 === node.tag && null !== node.memoizedState) {
+        instance = node.child.sibling;
+        instance.return = node;
+        node = instance;
+        continue;
+      } else if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    }
+    if (node === finishedWork) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === finishedWork) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+}
 function commitUnmount(current$$1$jscomp$0) {
   "function" === typeof onCommitFiberUnmount &&
     onCommitFiberUnmount(current$$1$jscomp$0);
@@ -4849,6 +5330,7 @@ function commitWork(current$$1, finishedWork) {
     case 11:
     case 14:
     case 15:
+      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
       break;
     case 1:
       break;
@@ -4857,23 +5339,18 @@ function commitWork(current$$1, finishedWork) {
       if (null != instance) {
         var newProps = finishedWork.memoizedProps;
         current$$1 = null !== current$$1 ? current$$1.memoizedProps : newProps;
-        var updatePayload = finishedWork.updateQueue;
+        var type = finishedWork.type,
+          updatePayload = finishedWork.updateQueue;
         finishedWork.updateQueue = null;
         null !== updatePayload &&
-          ((finishedWork = instance.viewConfig),
-          (instanceProps[instance._nativeTag] = newProps),
-          (newProps = diffProperties(
-            null,
+          commitUpdate(
+            instance,
+            updatePayload,
+            type,
             current$$1,
             newProps,
-            finishedWork.validAttributes
-          )),
-          null != newProps &&
-            UIManager.updateView(
-              instance._nativeTag,
-              finishedWork.uiViewClassName,
-              newProps
-            ));
+            finishedWork
+          );
       }
       break;
     case 6:
@@ -4890,71 +5367,28 @@ function commitWork(current$$1, finishedWork) {
     case 12:
       break;
     case 13:
-      newProps = finishedWork.memoizedState;
+      instance = finishedWork.memoizedState;
+      newProps = void 0;
       current$$1 = finishedWork;
-      null === newProps
-        ? (instance = !1)
-        : ((instance = !0),
+      null === instance
+        ? (newProps = !1)
+        : ((newProps = !0),
           (current$$1 = finishedWork.child),
-          0 === newProps.timedOutAt &&
-            (newProps.timedOutAt = requestCurrentTime()));
-      if (null !== current$$1)
-        a: for (newProps = finishedWork = current$$1; ; ) {
-          if (5 === newProps.tag)
-            if (((current$$1 = newProps.stateNode), instance)) {
-              updatePayload = current$$1.viewConfig;
-              var updatePayload$jscomp$0 = diffProperties(
-                null,
-                emptyObject,
-                { style: { display: "none" } },
-                updatePayload.validAttributes
-              );
-              UIManager.updateView(
-                current$$1._nativeTag,
-                updatePayload.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            } else {
-              current$$1 = newProps.stateNode;
-              updatePayload$jscomp$0 = newProps.memoizedProps;
-              updatePayload = current$$1.viewConfig;
-              var prevProps = Object.assign({}, updatePayload$jscomp$0, {
-                style: [updatePayload$jscomp$0.style, { display: "none" }]
-              });
-              updatePayload$jscomp$0 = diffProperties(
-                null,
-                prevProps,
-                updatePayload$jscomp$0,
-                updatePayload.validAttributes
-              );
-              UIManager.updateView(
-                current$$1._nativeTag,
-                updatePayload.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            }
-          else {
-            if (6 === newProps.tag) throw Error("Not yet implemented.");
-            if (13 === newProps.tag && null !== newProps.memoizedState) {
-              current$$1 = newProps.child.sibling;
-              current$$1.return = newProps;
-              newProps = current$$1;
-              continue;
-            } else if (null !== newProps.child) {
-              newProps.child.return = newProps;
-              newProps = newProps.child;
-              continue;
-            }
-          }
-          if (newProps === finishedWork) break a;
-          for (; null === newProps.sibling; ) {
-            if (null === newProps.return || newProps.return === finishedWork)
-              break a;
-            newProps = newProps.return;
-          }
-          newProps.sibling.return = newProps.return;
-          newProps = newProps.sibling;
-        }
+          0 === instance.timedOutAt &&
+            (instance.timedOutAt = requestCurrentTime()));
+      null !== current$$1 && hideOrUnhideAllChildren(current$$1, newProps);
+      instance = finishedWork.updateQueue;
+      if (null !== instance) {
+        finishedWork.updateQueue = null;
+        var retryCache = finishedWork.stateNode;
+        null === retryCache &&
+          (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+        instance.forEach(function(thenable) {
+          var retry = retryTimedOutBoundary.bind(null, finishedWork, thenable);
+          retryCache.has(thenable) ||
+            (retryCache.add(thenable), thenable.then(retry, retry));
+        });
+      }
       break;
     case 17:
       break;
@@ -4965,6 +5399,7 @@ function commitWork(current$$1, finishedWork) {
       );
   }
 }
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
   expirationTime = createUpdate(expirationTime);
   expirationTime.tag = 3;
@@ -5042,7 +5477,87 @@ function unwindWork(workInProgress) {
       return null;
   }
 }
-var DispatcherWithoutHooks = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, deps) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, deps];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, deps) {
+      useEffectImpl(516, UnmountPassive | MountPassive, create, deps);
+    },
+    useImperativeHandle: function(ref, create, deps) {
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : [ref];
+      useLayoutEffect(function() {
+        if ("function" === typeof ref) {
+          var _inst = create();
+          ref(_inst);
+          return function() {
+            return ref(null);
+          };
+        }
+        if (null !== ref && void 0 !== ref)
+          return (
+            (_inst = create()),
+            (ref.current = _inst),
+            function() {
+              ref.current = null;
+            }
+          );
+      }, deps);
+    },
+    useDebugValue: function() {
+      resolveCurrentlyRenderingFiber();
+    },
+    useLayoutEffect: useLayoutEffect,
+    useMemo: function(nextCreate, deps) {
+      var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      currentlyRenderingFiber$1 = null;
+      stashContextDependencies();
+      nextCreate = nextCreate();
+      currentlyRenderingFiber$1 = fiber;
+      unstashContextDependencies();
+      workInProgressHook.memoizedState = [nextCreate, deps];
+      return nextCreate;
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner,
   isWorking = !1,
   nextUnitOfWork = null,
@@ -5052,6 +5567,7 @@ var DispatcherWithoutHooks = { readContext: readContext },
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
   passiveEffectCallbackHandle = null,
   passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
@@ -5092,6 +5608,29 @@ function resetStack() {
   nextRenderDidError = !1;
   nextUnitOfWork = null;
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
+        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
 function flushPassiveEffects() {
   null !== passiveEffectCallback &&
     (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
@@ -5237,11 +5776,7 @@ function completeUnitOfWork(workInProgress) {
                   : ((current$$1.firstEffect = current$$1.lastEffect = type),
                     (type.nextEffect = null)),
                 (type.effectTag = 8)));
-            if (
-              newProps !== renderExpirationTime ||
-              (0 === (current$$1.effectTag & 1) && newProps)
-            )
-              current$$1.effectTag |= 4;
+            if (newProps || renderExpirationTime) current$$1.effectTag |= 4;
             break;
           case 7:
             break;
@@ -5335,7 +5870,7 @@ function renderRoot(root$jscomp$0, isYieldy) {
   );
   flushPassiveEffects();
   isWorking = !0;
-  ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
+  ReactCurrentDispatcher.current = Dispatcher;
   var expirationTime = root$jscomp$0.nextExpirationTimeToWorkOn;
   if (
     expirationTime !== nextRenderExpirationTime ||
@@ -5361,10 +5896,7 @@ function renderRoot(root$jscomp$0, isYieldy) {
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (
-        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
-        null === nextUnitOfWork)
-      )
+      if ((resetContextDependences(), resetHooks(), null === nextUnitOfWork))
         (didFatal = !0), onUncaughtError(thrownValue);
       else {
         invariant(
@@ -5422,23 +5954,47 @@ function renderRoot(root$jscomp$0, isYieldy) {
                       ? !1
                       : null === value.memoizedState;
                 if (current$$1) {
-                  returnFiber$jscomp$0 = retrySuspendedRoot.bind(
-                    null,
-                    root,
-                    value,
-                    sourceFiber$jscomp$0,
-                    0 === (value.mode & 1) ? 1073741823 : returnFiber
-                  );
-                  thenable.then(returnFiber$jscomp$0, returnFiber$jscomp$0);
+                  returnFiber$jscomp$0 = value.updateQueue;
+                  null === returnFiber$jscomp$0
+                    ? ((returnFiber$jscomp$0 = new Set()),
+                      returnFiber$jscomp$0.add(thenable),
+                      (value.updateQueue = returnFiber$jscomp$0))
+                    : returnFiber$jscomp$0.add(thenable);
                   if (0 === (value.mode & 1)) {
                     value.effectTag |= 64;
                     sourceFiber$jscomp$0.effectTag &= -1957;
                     1 === sourceFiber$jscomp$0.tag &&
-                      null === sourceFiber$jscomp$0.alternate &&
-                      (sourceFiber$jscomp$0.tag = 17);
-                    sourceFiber$jscomp$0.expirationTime = returnFiber;
+                      (null === sourceFiber$jscomp$0.alternate
+                        ? (sourceFiber$jscomp$0.tag = 17)
+                        : ((returnFiber = createUpdate(1073741823)),
+                          (returnFiber.tag = 2),
+                          enqueueUpdate(sourceFiber$jscomp$0, returnFiber)));
+                    sourceFiber$jscomp$0.expirationTime = 1073741823;
                     break a;
                   }
+                  sourceFiber$jscomp$0 = root.pingCache;
+                  null === sourceFiber$jscomp$0
+                    ? ((sourceFiber$jscomp$0 = root.pingCache = new PossiblyWeakMap()),
+                      (returnFiber$jscomp$0 = new Set()),
+                      sourceFiber$jscomp$0.set(thenable, returnFiber$jscomp$0))
+                    : ((returnFiber$jscomp$0 = sourceFiber$jscomp$0.get(
+                        thenable
+                      )),
+                      void 0 === returnFiber$jscomp$0 &&
+                        ((returnFiber$jscomp$0 = new Set()),
+                        sourceFiber$jscomp$0.set(
+                          thenable,
+                          returnFiber$jscomp$0
+                        )));
+                  returnFiber$jscomp$0.has(returnFiber) ||
+                    (returnFiber$jscomp$0.add(returnFiber),
+                    (sourceFiber$jscomp$0 = pingSuspendedRoot.bind(
+                      null,
+                      root,
+                      thenable,
+                      returnFiber
+                    )),
+                    thenable.then(sourceFiber$jscomp$0, sourceFiber$jscomp$0));
                   -1 === earliestTimeoutMs
                     ? (root = 1073741823)
                     : (-1 === startTimeMs &&
@@ -5473,36 +6029,31 @@ function renderRoot(root$jscomp$0, isYieldy) {
             do {
               switch (root.tag) {
                 case 3:
-                  sourceFiber$jscomp$0 = value;
                   root.effectTag |= 2048;
                   root.expirationTime = returnFiber;
-                  returnFiber = createRootErrorUpdate(
-                    root,
-                    sourceFiber$jscomp$0,
-                    returnFiber
-                  );
+                  returnFiber = createRootErrorUpdate(root, value, returnFiber);
                   enqueueCapturedUpdate(root, returnFiber);
                   break a;
                 case 1:
                   if (
-                    ((sourceFiber$jscomp$0 = value),
-                    (returnFiber$jscomp$0 = root.type),
-                    (thenable = root.stateNode),
+                    ((thenable = value),
+                    (earliestTimeoutMs = root.type),
+                    (startTimeMs = root.stateNode),
                     0 === (root.effectTag & 64) &&
                       ("function" ===
-                        typeof returnFiber$jscomp$0.getDerivedStateFromError ||
-                        (null !== thenable &&
-                          "function" === typeof thenable.componentDidCatch &&
+                        typeof earliestTimeoutMs.getDerivedStateFromError ||
+                        (null !== startTimeMs &&
+                          "function" === typeof startTimeMs.componentDidCatch &&
                           (null === legacyErrorBoundariesThatAlreadyFailed ||
                             !legacyErrorBoundariesThatAlreadyFailed.has(
-                              thenable
+                              startTimeMs
                             )))))
                   ) {
                     root.effectTag |= 2048;
                     root.expirationTime = returnFiber;
                     returnFiber = createClassErrorUpdate(
                       root,
-                      sourceFiber$jscomp$0,
+                      thenable,
                       returnFiber
                     );
                     enqueueCapturedUpdate(root, returnFiber);
@@ -5520,7 +6071,9 @@ function renderRoot(root$jscomp$0, isYieldy) {
     break;
   } while (1);
   isWorking = !1;
-  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
+  ReactCurrentDispatcher.current = null;
+  resetContextDependences();
+  resetHooks();
   if (didFatal) (nextRoot = null), (root$jscomp$0.finishedWork = null);
   else if (null !== nextUnitOfWork) root$jscomp$0.finishedWork = null;
   else {
@@ -5632,38 +6185,34 @@ function computeExpirationForFiber(currentTime, fiber) {
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
-function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
-  var retryTime = root.earliestSuspendedTime;
-  var latestSuspendedTime = root.latestSuspendedTime;
-  if (
-    0 !== retryTime &&
-    suspendedTime <= retryTime &&
-    suspendedTime >= latestSuspendedTime
+function pingSuspendedRoot(root, thenable, pingTime) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(thenable);
+  if (null !== nextRoot && nextRenderExpirationTime === pingTime)
+    nextRoot = null;
+  else if (
+    ((thenable = root.earliestSuspendedTime),
+    (pingCache = root.latestSuspendedTime),
+    0 !== thenable && pingTime <= thenable && pingTime >= pingCache)
   ) {
-    latestSuspendedTime = retryTime = suspendedTime;
     root.didError = !1;
-    var latestPingedTime = root.latestPingedTime;
-    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
-      root.latestPingedTime = latestSuspendedTime;
-    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
-  } else
-    (retryTime = requestCurrentTime()),
-      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
-      markPendingPriorityLevel(root, retryTime);
-  0 !== (boundaryFiber.mode & 1) &&
-    root === nextRoot &&
-    nextRenderExpirationTime === suspendedTime &&
-    (nextRoot = null);
-  scheduleWorkToRoot(boundaryFiber, retryTime);
-  0 === (boundaryFiber.mode & 1) &&
-    (scheduleWorkToRoot(sourceFiber, retryTime),
-    1 === sourceFiber.tag &&
-      null !== sourceFiber.stateNode &&
-      ((boundaryFiber = createUpdate(retryTime)),
-      (boundaryFiber.tag = 2),
-      enqueueUpdate(sourceFiber, boundaryFiber)));
-  sourceFiber = root.expirationTime;
-  0 !== sourceFiber && requestWork(root, sourceFiber);
+    thenable = root.latestPingedTime;
+    if (0 === thenable || thenable > pingTime) root.latestPingedTime = pingTime;
+    findNextExpirationTimeToWorkOn(pingTime, root);
+    pingTime = root.expirationTime;
+    0 !== pingTime && requestWork(root, pingTime);
+  }
+}
+function retryTimedOutBoundary(boundaryFiber, thenable) {
+  var retryCache = boundaryFiber.stateNode;
+  null !== retryCache && retryCache.delete(thenable);
+  thenable = requestCurrentTime();
+  thenable = computeExpirationForFiber(thenable, boundaryFiber);
+  boundaryFiber = scheduleWorkToRoot(boundaryFiber, thenable);
+  null !== boundaryFiber &&
+    (markPendingPriorityLevel(boundaryFiber, thenable),
+    (thenable = boundaryFiber.expirationTime),
+    0 !== thenable && requestWork(boundaryFiber, thenable));
 }
 function scheduleWorkToRoot(fiber, expirationTime) {
   fiber.expirationTime < expirationTime &&
@@ -6006,7 +6555,8 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
       (root.earliestSuspendedTime = 0),
       (root.latestSuspendedTime = 0),
       (root.latestPingedTime = 0))
-    : ((childExpirationTimeBeforeCommit = root.latestPendingTime),
+    : (firstBatch < root.latestPingedTime && (root.latestPingedTime = 0),
+      (childExpirationTimeBeforeCommit = root.latestPendingTime),
       0 !== childExpirationTimeBeforeCommit &&
         (childExpirationTimeBeforeCommit > firstBatch
           ? (root.earliestPendingTime = root.latestPendingTime = 0)
@@ -6043,6 +6593,7 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
               case 0:
               case 11:
               case 15:
+                commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
                 break a;
               case 1:
                 if (finishedWork.effectTag & 256 && null !== current$$1) {
@@ -6145,28 +6696,33 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
     effectTag = !1;
     current$$1$jscomp$0 = void 0;
     try {
-      for (currentRef = expirationTime; null !== nextEffect; ) {
+      for (
+        currentRef = root, alternate = expirationTime;
+        null !== nextEffect;
+
+      ) {
         var effectTag$jscomp$0 = nextEffect.effectTag;
         if (effectTag$jscomp$0 & 36) {
           var current$$1$jscomp$1 = nextEffect.alternate;
-          alternate = nextEffect;
-          current$$1 = currentRef;
-          switch (alternate.tag) {
+          current$$1 = nextEffect;
+          prevProps = alternate;
+          switch (current$$1.tag) {
             case 0:
             case 11:
             case 15:
+              commitHookEffectList(UnmountLayout, MountLayout, current$$1);
               break;
             case 1:
-              var instance$jscomp$0 = alternate.stateNode;
-              if (alternate.effectTag & 4)
+              var instance$jscomp$0 = current$$1.stateNode;
+              if (current$$1.effectTag & 4)
                 if (null === current$$1$jscomp$1)
                   instance$jscomp$0.componentDidMount();
                 else {
                   var prevProps$jscomp$0 =
-                    alternate.elementType === alternate.type
+                    current$$1.elementType === current$$1.type
                       ? current$$1$jscomp$1.memoizedProps
                       : resolveDefaultProps(
-                          alternate.type,
+                          current$$1.type,
                           current$$1$jscomp$1.memoizedProps
                         );
                   instance$jscomp$0.componentDidUpdate(
@@ -6175,32 +6731,32 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
                     instance$jscomp$0.__reactInternalSnapshotBeforeUpdate
                   );
                 }
-              var updateQueue = alternate.updateQueue;
+              var updateQueue = current$$1.updateQueue;
               null !== updateQueue &&
                 commitUpdateQueue(
-                  alternate,
+                  current$$1,
                   updateQueue,
                   instance$jscomp$0,
-                  current$$1
+                  prevProps
                 );
               break;
             case 3:
-              var _updateQueue = alternate.updateQueue;
+              var _updateQueue = current$$1.updateQueue;
               if (null !== _updateQueue) {
-                prevProps = null;
-                if (null !== alternate.child)
-                  switch (alternate.child.tag) {
+                prevState = null;
+                if (null !== current$$1.child)
+                  switch (current$$1.child.tag) {
                     case 5:
-                      prevProps = alternate.child.stateNode;
+                      prevState = current$$1.child.stateNode;
                       break;
                     case 1:
-                      prevProps = alternate.child.stateNode;
+                      prevState = current$$1.child.stateNode;
                   }
                 commitUpdateQueue(
-                  alternate,
+                  current$$1,
                   _updateQueue,
-                  prevProps,
-                  current$$1
+                  prevState,
+                  prevProps
                 );
               }
               break;
@@ -6239,6 +6795,8 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
               : (ref.current = instanceToUse);
           }
         }
+        effectTag$jscomp$0 & 512 &&
+          (rootWithPendingPassiveEffects = currentRef);
         nextEffect = nextEffect.nextEffect;
       }
     } catch (e) {
@@ -6252,6 +6810,13 @@ function completeRoot(root, finishedWork$jscomp$0, expirationTime) {
       captureCommitPhaseError(nextEffect, current$$1$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== firstBatch &&
+    null !== rootWithPendingPassiveEffects &&
+    ((effectTag$jscomp$0 = commitPassiveEffects.bind(null, root, firstBatch)),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      effectTag$jscomp$0
+    )),
+    (passiveEffectCallback = effectTag$jscomp$0));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork$jscomp$0.stateNode);
@@ -6493,6 +7058,7 @@ var roots = new Map(),
           current: root,
           containerInfo: containerTag,
           pendingChildren: null,
+          pingCache: null,
           earliestPendingTime: 0,
           latestPendingTime: 0,
           earliestSuspendedTime: 0,
@@ -6608,6 +7174,8 @@ var roots = new Map(),
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
   return injectInternals(
     Object.assign({}, devToolsConfig, {
+      overrideProps: null,
+      currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
       findHostInstanceByFiber: function(fiber) {
         fiber = findCurrentHostFiber(fiber);
         return null === fiber ? null : fiber.stateNode;
@@ -6623,7 +7191,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromTag,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.6.1",
+  version: "16.7.0",
   rendererPackageName: "react-native-renderer"
 });
 var ReactNativeRenderer$2 = { default: ReactNativeRenderer },
--- a/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-profiling.js
+++ b/node_modules/react-native/Libraries/Renderer/oss/ReactNativeRenderer-profiling.js
@@ -1632,8 +1632,24 @@ function finalizeInitialChildren(parentInstance) {
   return !1;
 }
 var scheduleTimeout = setTimeout,
-  cancelTimeout = clearTimeout,
-  BEFORE_SLASH_RE = /^(.*)[\\\/]/;
+  cancelTimeout = clearTimeout;
+function commitUpdate(instance, updatePayloadTODO, type, oldProps, newProps) {
+  updatePayloadTODO = instance.viewConfig;
+  instanceProps[instance._nativeTag] = newProps;
+  oldProps = diffProperties(
+    null,
+    oldProps,
+    newProps,
+    updatePayloadTODO.validAttributes
+  );
+  null != oldProps &&
+    UIManager.updateView(
+      instance._nativeTag,
+      updatePayloadTODO.uiViewClassName,
+      oldProps
+    );
+}
+var BEFORE_SLASH_RE = /^(.*)[\\\/]/;
 function getStackByFiberInDevAndProd(workInProgress) {
   var info = "";
   do {
@@ -1799,7 +1815,7 @@ function FiberNode(tag, pendingProps, key, mode) {
   this.index = 0;
   this.ref = null;
   this.pendingProps = pendingProps;
-  this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null;
+  this.contextDependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
   this.mode = mode;
   this.effectTag = 0;
   this.lastEffect = this.firstEffect = this.nextEffect = null;
@@ -1853,7 +1869,7 @@ function createWorkInProgress(current, pendingProps) {
   workInProgress.memoizedProps = current.memoizedProps;
   workInProgress.memoizedState = current.memoizedState;
   workInProgress.updateQueue = current.updateQueue;
-  workInProgress.firstContextDependency = current.firstContextDependency;
+  workInProgress.contextDependencies = current.contextDependencies;
   workInProgress.sibling = current.sibling;
   workInProgress.index = current.index;
   workInProgress.ref = current.ref;
@@ -1988,6 +2004,8 @@ function markCommittedPriorityLevels(root, earliestRemainingTime) {
       (root.latestSuspendedTime = 0),
       (root.latestPingedTime = 0);
   else {
+    earliestRemainingTime < root.latestPingedTime &&
+      (root.latestPingedTime = 0);
     var latestPendingTime = root.latestPendingTime;
     0 !== latestPendingTime &&
       (latestPendingTime > earliestRemainingTime
@@ -2020,24 +2038,21 @@ function hasLowerPriorityWork(root, erroredExpirationTime) {
 }
 function markSuspendedPriorityLevel(root, suspendedTime) {
   root.didError = !1;
-  var latestPingedTime = root.latestPingedTime;
-  0 !== latestPingedTime &&
-    latestPingedTime >= suspendedTime &&
-    (root.latestPingedTime = 0);
-  latestPingedTime = root.earliestPendingTime;
-  var latestPendingTime = root.latestPendingTime;
-  latestPingedTime === suspendedTime
+  root.latestPingedTime >= suspendedTime && (root.latestPingedTime = 0);
+  var earliestPendingTime = root.earliestPendingTime,
+    latestPendingTime = root.latestPendingTime;
+  earliestPendingTime === suspendedTime
     ? (root.earliestPendingTime =
         latestPendingTime === suspendedTime
           ? (root.latestPendingTime = 0)
           : latestPendingTime)
     : latestPendingTime === suspendedTime &&
-      (root.latestPendingTime = latestPingedTime);
-  latestPingedTime = root.earliestSuspendedTime;
+      (root.latestPendingTime = earliestPendingTime);
+  earliestPendingTime = root.earliestSuspendedTime;
   latestPendingTime = root.latestSuspendedTime;
-  0 === latestPingedTime
+  0 === earliestPendingTime
     ? (root.earliestSuspendedTime = root.latestSuspendedTime = suspendedTime)
-    : latestPingedTime < suspendedTime
+    : earliestPendingTime < suspendedTime
       ? (root.earliestSuspendedTime = suspendedTime)
       : latestPendingTime > suspendedTime &&
         (root.latestSuspendedTime = suspendedTime);
@@ -2304,103 +2319,10 @@ function createCapturedValue(value, source) {
     stack: getStackByFiberInDevAndProd(source)
   };
 }
-var valueCursor = { current: null },
-  currentlyRenderingFiber = null,
-  lastContextDependency = null,
-  lastContextWithAllBitsObserved = null;
-function pushProvider(providerFiber, nextValue) {
-  var context = providerFiber.type._context;
-  push(valueCursor, context._currentValue, providerFiber);
-  context._currentValue = nextValue;
-}
-function popProvider(providerFiber) {
-  var currentValue = valueCursor.current;
-  pop(valueCursor, providerFiber);
-  providerFiber.type._context._currentValue = currentValue;
-}
-function prepareToReadContext(workInProgress) {
-  currentlyRenderingFiber = workInProgress;
-  lastContextWithAllBitsObserved = lastContextDependency = null;
-  workInProgress.firstContextDependency = null;
-}
-function readContext(context, observedBits) {
-  if (
-    lastContextWithAllBitsObserved !== context &&
-    !1 !== observedBits &&
-    0 !== observedBits
-  ) {
-    if ("number" !== typeof observedBits || 1073741823 === observedBits)
-      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
-    observedBits = { context: context, observedBits: observedBits, next: null };
-    null === lastContextDependency
-      ? (invariant(
-          null !== currentlyRenderingFiber,
-          "Context can only be read while React is rendering, e.g. inside the render method or getDerivedStateFromProps."
-        ),
-        (currentlyRenderingFiber.firstContextDependency = lastContextDependency = observedBits))
-      : (lastContextDependency = lastContextDependency.next = observedBits);
-  }
-  return context._currentValue;
-}
-var NO_CONTEXT = {},
-  contextStackCursor$1 = { current: NO_CONTEXT },
-  contextFiberStackCursor = { current: NO_CONTEXT },
-  rootInstanceStackCursor = { current: NO_CONTEXT };
-function requiredContext(c) {
-  invariant(
-    c !== NO_CONTEXT,
-    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
-  );
-  return c;
-}
-function pushHostContainer(fiber, nextRootInstance) {
-  push(rootInstanceStackCursor, nextRootInstance, fiber);
-  push(contextFiberStackCursor, fiber, fiber);
-  push(contextStackCursor$1, NO_CONTEXT, fiber);
-  pop(contextStackCursor$1, fiber);
-  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
-}
-function popHostContainer(fiber) {
-  pop(contextStackCursor$1, fiber);
-  pop(contextFiberStackCursor, fiber);
-  pop(rootInstanceStackCursor, fiber);
-}
-function pushHostContext(fiber) {
-  requiredContext(rootInstanceStackCursor.current);
-  var context = requiredContext(contextStackCursor$1.current);
-  var nextContext = fiber.type;
-  nextContext =
-    "AndroidTextInput" === nextContext ||
-    "RCTMultilineTextInputView" === nextContext ||
-    "RCTSinglelineTextInputView" === nextContext ||
-    "RCTText" === nextContext ||
-    "RCTVirtualText" === nextContext;
-  nextContext =
-    context.isInAParentText !== nextContext
-      ? { isInAParentText: nextContext }
-      : context;
-  context !== nextContext &&
-    (push(contextFiberStackCursor, fiber, fiber),
-    push(contextStackCursor$1, nextContext, fiber));
-}
-function popHostContext(fiber) {
-  contextFiberStackCursor.current === fiber &&
-    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
-}
-var commitTime = 0,
-  profilerStartTime = -1;
-function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
-  if (0 <= profilerStartTime) {
-    var elapsedTime = now$1() - profilerStartTime;
-    fiber.actualDuration += elapsedTime;
-    overrideBaseTime && (fiber.selfBaseDuration = elapsedTime);
-    profilerStartTime = -1;
-  }
-}
-var hasOwnProperty = Object.prototype.hasOwnProperty;
 function is(x, y) {
-  return x === y ? 0 !== x || 0 !== y || 1 / x === 1 / y : x !== x && y !== y;
+  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);
 }
+var hasOwnProperty = Object.prototype.hasOwnProperty;
 function shallowEqual(objA, objB) {
   if (is(objA, objB)) return !0;
   if (
@@ -2441,9 +2363,9 @@ function readLazyComponentType(lazyComponent) {
     case 0:
       throw result;
     default:
-      throw ((lazyComponent._status = 0),
-      (result = lazyComponent._ctor),
-      (result = result()),
+      lazyComponent._status = 0;
+      result = lazyComponent._ctor;
+      result = result();
       result.then(
         function(moduleObject) {
           0 === lazyComponent._status &&
@@ -2455,13 +2377,18 @@ function readLazyComponentType(lazyComponent) {
           0 === lazyComponent._status &&
             ((lazyComponent._status = 2), (lazyComponent._result = error));
         }
-      ),
-      (lazyComponent._result = result),
-      result);
+      );
+      switch (lazyComponent._status) {
+        case 1:
+          return lazyComponent._result;
+        case 2:
+          throw lazyComponent._result;
+      }
+      lazyComponent._result = result;
+      throw result;
   }
 }
-var ReactCurrentOwner$4 = ReactSharedInternals.ReactCurrentOwner,
-  emptyRefsObject = new React.Component().refs;
+var emptyRefsObject = new React.Component().refs;
 function applyDerivedStateFromProps(
   workInProgress,
   ctor,
@@ -2542,7 +2469,7 @@ function constructClassInstance(workInProgress, ctor, props) {
     unmaskedContext = emptyContextObject;
   var context = ctor.contextType;
   "object" === typeof context && null !== context
-    ? (context = ReactCurrentOwner$4.currentDispatcher.readContext(context))
+    ? (context = readContext(context))
     : ((unmaskedContext = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2589,9 +2516,7 @@ function mountClassInstance(
   instance.refs = emptyRefsObject;
   var contextType = ctor.contextType;
   "object" === typeof contextType && null !== contextType
-    ? (instance.context = ReactCurrentOwner$4.currentDispatcher.readContext(
-        contextType
-      ))
+    ? (instance.context = readContext(contextType))
     : ((contextType = isContextProvider(ctor)
         ? previousContext
         : contextStackCursor.current),
@@ -2646,7 +2571,10 @@ function coerceRef(returnFiber, current$$1, element) {
       element = element._owner;
       var inst = void 0;
       element &&
-        (invariant(1 === element.tag, "Function components cannot have refs."),
+        (invariant(
+          1 === element.tag,
+          "Function components cannot have refs. Did you mean to use React.forwardRef()?"
+        ),
         (inst = element.stateNode));
       invariant(
         inst,
@@ -3346,7 +3274,377 @@ function ChildReconciler(shouldTrackSideEffects) {
 }
 var reconcileChildFibers = ChildReconciler(!0),
   mountChildFibers = ChildReconciler(!1),
-  hydrationParentFiber = null,
+  NO_CONTEXT = {},
+  contextStackCursor$1 = { current: NO_CONTEXT },
+  contextFiberStackCursor = { current: NO_CONTEXT },
+  rootInstanceStackCursor = { current: NO_CONTEXT };
+function requiredContext(c) {
+  invariant(
+    c !== NO_CONTEXT,
+    "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
+  );
+  return c;
+}
+function pushHostContainer(fiber, nextRootInstance) {
+  push(rootInstanceStackCursor, nextRootInstance, fiber);
+  push(contextFiberStackCursor, fiber, fiber);
+  push(contextStackCursor$1, NO_CONTEXT, fiber);
+  pop(contextStackCursor$1, fiber);
+  push(contextStackCursor$1, { isInAParentText: !1 }, fiber);
+}
+function popHostContainer(fiber) {
+  pop(contextStackCursor$1, fiber);
+  pop(contextFiberStackCursor, fiber);
+  pop(rootInstanceStackCursor, fiber);
+}
+function pushHostContext(fiber) {
+  requiredContext(rootInstanceStackCursor.current);
+  var context = requiredContext(contextStackCursor$1.current);
+  var nextContext = fiber.type;
+  nextContext =
+    "AndroidTextInput" === nextContext ||
+    "RCTMultilineTextInputView" === nextContext ||
+    "RCTSinglelineTextInputView" === nextContext ||
+    "RCTText" === nextContext ||
+    "RCTVirtualText" === nextContext;
+  nextContext =
+    context.isInAParentText !== nextContext
+      ? { isInAParentText: nextContext }
+      : context;
+  context !== nextContext &&
+    (push(contextFiberStackCursor, fiber, fiber),
+    push(contextStackCursor$1, nextContext, fiber));
+}
+function popHostContext(fiber) {
+  contextFiberStackCursor.current === fiber &&
+    (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
+}
+var NoEffect$1 = 0,
+  UnmountSnapshot = 2,
+  UnmountMutation = 4,
+  MountMutation = 8,
+  UnmountLayout = 16,
+  MountLayout = 32,
+  MountPassive = 64,
+  UnmountPassive = 128,
+  renderExpirationTime = 0,
+  currentlyRenderingFiber$1 = null,
+  firstCurrentHook = null,
+  currentHook = null,
+  firstWorkInProgressHook = null,
+  workInProgressHook = null,
+  remainingExpirationTime = 0,
+  componentUpdateQueue = null,
+  didScheduleRenderPhaseUpdate = !1,
+  renderPhaseUpdates = null,
+  numberOfReRenders = -1;
+function resolveCurrentlyRenderingFiber() {
+  invariant(
+    null !== currentlyRenderingFiber$1,
+    "Hooks can only be called inside the body of a function component."
+  );
+  return currentlyRenderingFiber$1;
+}
+function areHookInputsEqual(nextDeps, prevDeps) {
+  if (null === prevDeps) return !1;
+  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
+    if (!is(nextDeps[i], prevDeps[i])) return !1;
+  return !0;
+}
+function renderWithHooks(
+  current,
+  workInProgress,
+  Component,
+  props,
+  refOrContext,
+  nextRenderExpirationTime
+) {
+  renderExpirationTime = nextRenderExpirationTime;
+  currentlyRenderingFiber$1 = workInProgress;
+  firstCurrentHook = null !== current ? current.memoizedState : null;
+  do
+    (didScheduleRenderPhaseUpdate = !1),
+      (numberOfReRenders += 1),
+      (componentUpdateQueue = workInProgressHook = currentHook = null),
+      (current = Component(props, refOrContext));
+  while (didScheduleRenderPhaseUpdate);
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+  Component = currentlyRenderingFiber$1;
+  Component.memoizedState = firstWorkInProgressHook;
+  Component.expirationTime = remainingExpirationTime;
+  Component.updateQueue = componentUpdateQueue;
+  Component = null !== currentHook && null !== currentHook.next;
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  invariant(
+    !Component,
+    "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
+  );
+  return current;
+}
+function resetHooks() {
+  renderExpirationTime = 0;
+  workInProgressHook = firstWorkInProgressHook = currentHook = firstCurrentHook = currentlyRenderingFiber$1 = null;
+  remainingExpirationTime = 0;
+  componentUpdateQueue = null;
+  didScheduleRenderPhaseUpdate = !1;
+  renderPhaseUpdates = null;
+  numberOfReRenders = -1;
+}
+function createHook() {
+  return {
+    memoizedState: null,
+    baseState: null,
+    queue: null,
+    baseUpdate: null,
+    next: null
+  };
+}
+function cloneHook(hook) {
+  return {
+    memoizedState: hook.memoizedState,
+    baseState: hook.baseState,
+    queue: hook.queue,
+    baseUpdate: hook.baseUpdate,
+    next: null
+  };
+}
+function createWorkInProgressHook() {
+  if (null === workInProgressHook)
+    null === firstWorkInProgressHook
+      ? ((currentHook = firstCurrentHook),
+        (firstWorkInProgressHook = workInProgressHook =
+          null === currentHook ? createHook() : cloneHook(currentHook)))
+      : ((currentHook = firstCurrentHook),
+        (workInProgressHook = firstWorkInProgressHook));
+  else if (null === workInProgressHook.next) {
+    if (null === currentHook) var hook = createHook();
+    else
+      (currentHook = currentHook.next),
+        (hook = null === currentHook ? createHook() : cloneHook(currentHook));
+    workInProgressHook = workInProgressHook.next = hook;
+  } else
+    (workInProgressHook = workInProgressHook.next),
+      (currentHook = null !== currentHook ? currentHook.next : null);
+  return workInProgressHook;
+}
+function basicStateReducer(state, action) {
+  return "function" === typeof action ? action(state) : action;
+}
+function useReducer(reducer, initialState, initialAction) {
+  var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+  workInProgressHook = createWorkInProgressHook();
+  var queue = workInProgressHook.queue;
+  if (null !== queue) {
+    if (0 < numberOfReRenders) {
+      initialState = queue.dispatch;
+      if (null !== renderPhaseUpdates) {
+        var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
+        if (void 0 !== firstRenderPhaseUpdate) {
+          renderPhaseUpdates.delete(queue);
+          initialAction = workInProgressHook.memoizedState;
+          do {
+            var _action = firstRenderPhaseUpdate.action;
+            currentlyRenderingFiber$1 = null;
+            stashContextDependencies();
+            initialAction = reducer(initialAction, _action);
+            currentlyRenderingFiber$1 = fiber;
+            unstashContextDependencies();
+            firstRenderPhaseUpdate = firstRenderPhaseUpdate.next;
+          } while (null !== firstRenderPhaseUpdate);
+          workInProgressHook.memoizedState = initialAction;
+          workInProgressHook.baseUpdate === queue.last &&
+            (workInProgressHook.baseState = initialAction);
+          return [initialAction, initialState];
+        }
+      }
+      return [workInProgressHook.memoizedState, initialState];
+    }
+    initialState = queue.last;
+    var _baseUpdate = workInProgressHook.baseUpdate;
+    initialAction = workInProgressHook.baseState;
+    null !== _baseUpdate
+      ? (null !== initialState && (initialState.next = null),
+        (initialState = _baseUpdate.next))
+      : (initialState = null !== initialState ? initialState.next : null);
+    if (null !== initialState) {
+      _action = firstRenderPhaseUpdate = null;
+      var prevUpdate = _baseUpdate;
+      _baseUpdate = initialState;
+      var didSkip = !1;
+      do {
+        var updateExpirationTime = _baseUpdate.expirationTime;
+        updateExpirationTime < renderExpirationTime
+          ? (didSkip ||
+              ((didSkip = !0),
+              (_action = prevUpdate),
+              (firstRenderPhaseUpdate = initialAction)),
+            updateExpirationTime > remainingExpirationTime &&
+              (remainingExpirationTime = updateExpirationTime))
+          : _baseUpdate.eagerReducer === reducer
+            ? (initialAction = _baseUpdate.eagerState)
+            : ((prevUpdate = _baseUpdate.action),
+              (currentlyRenderingFiber$1 = null),
+              stashContextDependencies(),
+              (initialAction = reducer(initialAction, prevUpdate)),
+              (currentlyRenderingFiber$1 = fiber),
+              unstashContextDependencies());
+        prevUpdate = _baseUpdate;
+        _baseUpdate = _baseUpdate.next;
+      } while (null !== _baseUpdate && _baseUpdate !== initialState);
+      didSkip ||
+        ((_action = prevUpdate), (firstRenderPhaseUpdate = initialAction));
+      workInProgressHook.memoizedState = initialAction;
+      workInProgressHook.baseUpdate = _action;
+      workInProgressHook.baseState = firstRenderPhaseUpdate;
+      initialAction !== currentHook.memoizedState && (didReceiveUpdate = !0);
+      queue.eagerReducer = reducer;
+      queue.eagerState = initialAction;
+    }
+    return [workInProgressHook.memoizedState, queue.dispatch];
+  }
+  currentlyRenderingFiber$1 = null;
+  stashContextDependencies();
+  reducer === basicStateReducer
+    ? "function" === typeof initialState && (initialState = initialState())
+    : void 0 !== initialAction &&
+      null !== initialAction &&
+      (initialState = reducer(initialState, initialAction));
+  currentlyRenderingFiber$1 = fiber;
+  unstashContextDependencies();
+  workInProgressHook.memoizedState = workInProgressHook.baseState = initialState;
+  queue = workInProgressHook.queue = {
+    last: null,
+    dispatch: null,
+    eagerReducer: reducer,
+    eagerState: initialState
+  };
+  reducer = queue.dispatch = dispatchAction.bind(
+    null,
+    currentlyRenderingFiber$1,
+    queue
+  );
+  return [workInProgressHook.memoizedState, reducer];
+}
+function pushEffect(tag, create, destroy, deps) {
+  tag = { tag: tag, create: create, destroy: destroy, deps: deps, next: null };
+  null === componentUpdateQueue
+    ? ((componentUpdateQueue = { lastEffect: null }),
+      (componentUpdateQueue.lastEffect = tag.next = tag))
+    : ((create = componentUpdateQueue.lastEffect),
+      null === create
+        ? (componentUpdateQueue.lastEffect = tag.next = tag)
+        : ((destroy = create.next),
+          (create.next = tag),
+          (tag.next = destroy),
+          (componentUpdateQueue.lastEffect = tag)));
+  return tag;
+}
+function useLayoutEffect(create, deps) {
+  useEffectImpl(4, UnmountMutation | MountLayout, create, deps);
+}
+function useEffectImpl(fiberEffectTag, hookEffectTag, create, deps) {
+  currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+  workInProgressHook = createWorkInProgressHook();
+  deps = void 0 === deps ? null : deps;
+  var destroy = null;
+  if (null !== currentHook) {
+    var prevEffect = currentHook.memoizedState;
+    destroy = prevEffect.destroy;
+    if (null !== deps && areHookInputsEqual(deps, prevEffect.deps)) {
+      pushEffect(NoEffect$1, create, destroy, deps);
+      return;
+    }
+  }
+  currentlyRenderingFiber$1.effectTag |= fiberEffectTag;
+  workInProgressHook.memoizedState = pushEffect(
+    hookEffectTag,
+    create,
+    destroy,
+    deps
+  );
+}
+function dispatchAction(fiber, queue, action) {
+  invariant(
+    25 > numberOfReRenders,
+    "Too many re-renders. React limits the number of renders to prevent an infinite loop."
+  );
+  var alternate = fiber.alternate;
+  if (
+    fiber === currentlyRenderingFiber$1 ||
+    (null !== alternate && alternate === currentlyRenderingFiber$1)
+  )
+    if (
+      ((didScheduleRenderPhaseUpdate = !0),
+      (fiber = {
+        expirationTime: renderExpirationTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      }),
+      null === renderPhaseUpdates && (renderPhaseUpdates = new Map()),
+      (action = renderPhaseUpdates.get(queue)),
+      void 0 === action)
+    )
+      renderPhaseUpdates.set(queue, fiber);
+    else {
+      for (queue = action; null !== queue.next; ) queue = queue.next;
+      queue.next = fiber;
+    }
+  else {
+    flushPassiveEffects();
+    var currentTime = requestCurrentTime();
+    currentTime = computeExpirationForFiber(currentTime, fiber);
+    var _update2 = {
+        expirationTime: currentTime,
+        action: action,
+        eagerReducer: null,
+        eagerState: null,
+        next: null
+      },
+      _last2 = queue.last;
+    if (null === _last2) _update2.next = _update2;
+    else {
+      var first = _last2.next;
+      null !== first && (_update2.next = first);
+      _last2.next = _update2;
+    }
+    queue.last = _update2;
+    if (
+      0 === fiber.expirationTime &&
+      (null === alternate || 0 === alternate.expirationTime) &&
+      ((alternate = queue.eagerReducer), null !== alternate)
+    )
+      try {
+        var currentState = queue.eagerState;
+        queue = currentlyRenderingFiber$1;
+        currentlyRenderingFiber$1 = null;
+        stashContextDependencies();
+        var _eagerState = alternate(currentState, action);
+        currentlyRenderingFiber$1 = queue;
+        unstashContextDependencies();
+        _update2.eagerReducer = alternate;
+        _update2.eagerState = _eagerState;
+        if (_eagerState === currentState) return;
+      } catch (error) {}
+    scheduleWork(fiber, currentTime);
+  }
+}
+var commitTime = 0,
+  profilerStartTime = -1;
+function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
+  if (0 <= profilerStartTime) {
+    var elapsedTime = now$1() - profilerStartTime;
+    fiber.actualDuration += elapsedTime;
+    overrideBaseTime && (fiber.selfBaseDuration = elapsedTime);
+    profilerStartTime = -1;
+  }
+}
+var hydrationParentFiber = null,
   nextHydratableInstance = null,
   isHydrating = !1;
 function tryHydrate(fiber, nextInstance) {
@@ -3398,7 +3696,8 @@ function tryToClaimNextHydratableInstance(fiber$jscomp$0) {
         (hydrationParentFiber = fiber$jscomp$0);
   }
 }
-var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
+var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner,
+  didReceiveUpdate = !1;
 function reconcileChildren(
   current$$1,
   workInProgress,
@@ -3430,7 +3729,26 @@ function updateForwardRef(
   Component = Component.render;
   var ref = workInProgress.ref;
   prepareToReadContext(workInProgress, renderExpirationTime);
-  nextProps = Component(nextProps, ref);
+  nextProps = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    ref,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3510,9 +3828,9 @@ function updateSimpleMemoComponent(
   renderExpirationTime
 ) {
   return null !== current$$1 &&
-    updateExpirationTime < renderExpirationTime &&
     shallowEqual(current$$1.memoizedProps, nextProps) &&
-    current$$1.ref === workInProgress.ref
+    current$$1.ref === workInProgress.ref &&
+    ((didReceiveUpdate = !1), updateExpirationTime < renderExpirationTime)
     ? bailoutOnAlreadyFinishedWork(
         current$$1,
         workInProgress,
@@ -3546,7 +3864,26 @@ function updateFunctionComponent(
     : contextStackCursor.current;
   unmaskedContext = getMaskedContext(workInProgress, unmaskedContext);
   prepareToReadContext(workInProgress, renderExpirationTime);
-  Component = Component(nextProps, unmaskedContext);
+  Component = renderWithHooks(
+    current$$1,
+    workInProgress,
+    Component,
+    nextProps,
+    unmaskedContext,
+    renderExpirationTime
+  );
+  if (null !== current$$1 && !didReceiveUpdate)
+    return (
+      (workInProgress.updateQueue = current$$1.updateQueue),
+      (workInProgress.effectTag &= -517),
+      current$$1.expirationTime <= renderExpirationTime &&
+        (current$$1.expirationTime = 0),
+      bailoutOnAlreadyFinishedWork(
+        current$$1,
+        workInProgress,
+        renderExpirationTime
+      )
+    );
   workInProgress.effectTag |= 1;
   reconcileChildren(
     current$$1,
@@ -3593,9 +3930,7 @@ function updateClassComponent(
     var oldContext = instance.context,
       contextType = Component.contextType;
     "object" === typeof contextType && null !== contextType
-      ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-          contextType
-        ))
+      ? (contextType = readContext(contextType))
       : ((contextType = isContextProvider(Component)
           ? previousContext
           : contextStackCursor.current),
@@ -3680,9 +4015,7 @@ function updateClassComponent(
       (oldContext = instance.context),
       (contextType = Component.contextType),
       "object" === typeof contextType && null !== contextType
-        ? (contextType = ReactCurrentOwner$4.currentDispatcher.readContext(
-            contextType
-          ))
+        ? (contextType = readContext(contextType))
         : ((contextType = isContextProvider(Component)
             ? previousContext
             : contextStackCursor.current),
@@ -3868,104 +4201,119 @@ function updateSuspenseComponent(
       (nextDidTimeout = !0),
       (workInProgress.effectTag &= -65);
   if (null === current$$1)
-    nextDidTimeout
-      ? ((nextDidTimeout = nextProps.fallback),
-        (nextProps = createFiberFromFragment(null, mode, 0, null)),
-        0 === (workInProgress.mode & 1) &&
-          (nextProps.child =
-            null !== workInProgress.memoizedState
-              ? workInProgress.child.child
-              : workInProgress.child),
-        (renderExpirationTime = createFiberFromFragment(
-          nextDidTimeout,
-          mode,
-          renderExpirationTime,
-          null
-        )),
-        (nextProps.sibling = renderExpirationTime),
-        (mode = nextProps),
-        (mode.return = renderExpirationTime.return = workInProgress))
-      : (mode = renderExpirationTime = mountChildFibers(
-          workInProgress,
-          null,
-          nextProps.children,
-          renderExpirationTime
-        ));
-  else if (null !== current$$1.memoizedState)
-    if (
-      ((current$$1 = current$$1.child),
-      (mode = current$$1.sibling),
-      nextDidTimeout)
-    ) {
-      nextProps = nextProps.fallback;
-      renderExpirationTime = createWorkInProgress(
-        current$$1,
-        current$$1.pendingProps,
-        0
-      );
+    if (nextDidTimeout) {
+      var nextFallbackChildren = nextProps.fallback;
+      current$$1 = createFiberFromFragment(null, mode, 0, null);
       0 === (workInProgress.mode & 1) &&
-        ((nextDidTimeout =
+        (current$$1.child =
           null !== workInProgress.memoizedState
             ? workInProgress.child.child
-            : workInProgress.child),
-        nextDidTimeout !== current$$1.child &&
-          (renderExpirationTime.child = nextDidTimeout));
-      if (workInProgress.mode & 4) {
-        nextDidTimeout = 0;
-        for (current$$1 = renderExpirationTime.child; null !== current$$1; )
-          (nextDidTimeout += current$$1.treeBaseDuration),
-            (current$$1 = current$$1.sibling);
-        renderExpirationTime.treeBaseDuration = nextDidTimeout;
-      }
-      nextProps = renderExpirationTime.sibling = createWorkInProgress(
+            : workInProgress.child);
+      renderExpirationTime = createFiberFromFragment(
+        nextFallbackChildren,
         mode,
-        nextProps,
-        mode.expirationTime
+        renderExpirationTime,
+        null
       );
-      mode = renderExpirationTime;
-      renderExpirationTime.childExpirationTime = 0;
-      renderExpirationTime = nextProps;
+      current$$1.sibling = renderExpirationTime;
+      mode = current$$1;
       mode.return = renderExpirationTime.return = workInProgress;
     } else
-      mode = renderExpirationTime = reconcileChildFibers(
+      mode = renderExpirationTime = mountChildFibers(
         workInProgress,
-        current$$1.child,
+        null,
         nextProps.children,
         renderExpirationTime
       );
-  else if (((current$$1 = current$$1.child), nextDidTimeout)) {
-    nextDidTimeout = nextProps.fallback;
-    nextProps = createFiberFromFragment(null, mode, 0, null);
-    nextProps.child = current$$1;
-    0 === (workInProgress.mode & 1) &&
-      (nextProps.child =
-        null !== workInProgress.memoizedState
-          ? workInProgress.child.child
-          : workInProgress.child);
-    if (workInProgress.mode & 4) {
-      current$$1 = 0;
-      for (var _hiddenChild = nextProps.child; null !== _hiddenChild; )
-        (current$$1 += _hiddenChild.treeBaseDuration),
-          (_hiddenChild = _hiddenChild.sibling);
-      nextProps.treeBaseDuration = current$$1;
+  else {
+    if (null !== current$$1.memoizedState)
+      if (
+        ((nextFallbackChildren = current$$1.child),
+        (mode = nextFallbackChildren.sibling),
+        nextDidTimeout)
+      ) {
+        nextProps = nextProps.fallback;
+        renderExpirationTime = createWorkInProgress(
+          nextFallbackChildren,
+          nextFallbackChildren.pendingProps,
+          0
+        );
+        0 === (workInProgress.mode & 1) &&
+          ((nextDidTimeout =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child),
+          nextDidTimeout !== nextFallbackChildren.child &&
+            (renderExpirationTime.child = nextDidTimeout));
+        if (workInProgress.mode & 4) {
+          nextFallbackChildren = 0;
+          for (
+            nextDidTimeout = renderExpirationTime.child;
+            null !== nextDidTimeout;
+
+          )
+            (nextFallbackChildren += nextDidTimeout.treeBaseDuration),
+              (nextDidTimeout = nextDidTimeout.sibling);
+          renderExpirationTime.treeBaseDuration = nextFallbackChildren;
+        }
+        nextFallbackChildren = renderExpirationTime.sibling = createWorkInProgress(
+          mode,
+          nextProps,
+          mode.expirationTime
+        );
+        mode = renderExpirationTime;
+        renderExpirationTime.childExpirationTime = 0;
+        renderExpirationTime = nextFallbackChildren;
+        mode.return = renderExpirationTime.return = workInProgress;
+      } else
+        mode = renderExpirationTime = reconcileChildFibers(
+          workInProgress,
+          nextFallbackChildren.child,
+          nextProps.children,
+          renderExpirationTime
+        );
+    else {
+      var _currentPrimaryChild = current$$1.child;
+      if (nextDidTimeout) {
+        nextProps = nextProps.fallback;
+        nextFallbackChildren = createFiberFromFragment(null, mode, 0, null);
+        nextFallbackChildren.child = _currentPrimaryChild;
+        0 === (workInProgress.mode & 1) &&
+          (nextFallbackChildren.child =
+            null !== workInProgress.memoizedState
+              ? workInProgress.child.child
+              : workInProgress.child);
+        if (workInProgress.mode & 4) {
+          nextDidTimeout = 0;
+          for (
+            _currentPrimaryChild = nextFallbackChildren.child;
+            null !== _currentPrimaryChild;
+
+          )
+            (nextDidTimeout += _currentPrimaryChild.treeBaseDuration),
+              (_currentPrimaryChild = _currentPrimaryChild.sibling);
+          nextFallbackChildren.treeBaseDuration = nextDidTimeout;
+        }
+        renderExpirationTime = nextFallbackChildren.sibling = createFiberFromFragment(
+          nextProps,
+          mode,
+          renderExpirationTime,
+          null
+        );
+        renderExpirationTime.effectTag |= 2;
+        mode = nextFallbackChildren;
+        nextFallbackChildren.childExpirationTime = 0;
+        mode.return = renderExpirationTime.return = workInProgress;
+      } else
+        renderExpirationTime = mode = reconcileChildFibers(
+          workInProgress,
+          _currentPrimaryChild,
+          nextProps.children,
+          renderExpirationTime
+        );
     }
-    renderExpirationTime = nextProps.sibling = createFiberFromFragment(
-      nextDidTimeout,
-      mode,
-      renderExpirationTime,
-      null
-    );
-    renderExpirationTime.effectTag |= 2;
-    mode = nextProps;
-    nextProps.childExpirationTime = 0;
-    mode.return = renderExpirationTime.return = workInProgress;
-  } else
-    renderExpirationTime = mode = reconcileChildFibers(
-      workInProgress,
-      current$$1,
-      nextProps.children,
-      renderExpirationTime
-    );
+    workInProgress.stateNode = current$$1.stateNode;
+  }
   workInProgress.memoizedState = nextState;
   workInProgress.child = mode;
   return renderExpirationTime;
@@ -3976,7 +4324,7 @@ function bailoutOnAlreadyFinishedWork(
   renderExpirationTime
 ) {
   null !== current$$1 &&
-    (workInProgress.firstContextDependency = current$$1.firstContextDependency);
+    (workInProgress.contextDependencies = current$$1.contextDependencies);
   profilerStartTime = -1;
   if (workInProgress.childExpirationTime < renderExpirationTime) return null;
   invariant(
@@ -4009,61 +4357,66 @@ function bailoutOnAlreadyFinishedWork(
 }
 function beginWork(current$$1, workInProgress, renderExpirationTime) {
   var updateExpirationTime = workInProgress.expirationTime;
-  if (
-    null !== current$$1 &&
-    current$$1.memoizedProps === workInProgress.pendingProps &&
-    !didPerformWorkStackCursor.current &&
-    updateExpirationTime < renderExpirationTime
-  ) {
-    switch (workInProgress.tag) {
-      case 3:
-        pushHostRootContext(workInProgress);
-        break;
-      case 5:
-        pushHostContext(workInProgress);
-        break;
-      case 1:
-        isContextProvider(workInProgress.type) &&
-          pushContextProvider(workInProgress);
-        break;
-      case 4:
-        pushHostContainer(
-          workInProgress,
-          workInProgress.stateNode.containerInfo
-        );
-        break;
-      case 10:
-        pushProvider(workInProgress, workInProgress.memoizedProps.value);
-        break;
-      case 12:
-        workInProgress.effectTag |= 4;
-        break;
-      case 13:
-        if (null !== workInProgress.memoizedState) {
-          updateExpirationTime = workInProgress.child.childExpirationTime;
-          if (
-            0 !== updateExpirationTime &&
-            updateExpirationTime >= renderExpirationTime
-          )
-            return updateSuspenseComponent(
-              current$$1,
+  if (null !== current$$1)
+    if (
+      current$$1.memoizedProps !== workInProgress.pendingProps ||
+      didPerformWorkStackCursor.current
+    )
+      didReceiveUpdate = !0;
+    else {
+      if (updateExpirationTime < renderExpirationTime) {
+        didReceiveUpdate = !1;
+        switch (workInProgress.tag) {
+          case 3:
+            pushHostRootContext(workInProgress);
+            break;
+          case 5:
+            pushHostContext(workInProgress);
+            break;
+          case 1:
+            isContextProvider(workInProgress.type) &&
+              pushContextProvider(workInProgress);
+            break;
+          case 4:
+            pushHostContainer(
               workInProgress,
-              renderExpirationTime
+              workInProgress.stateNode.containerInfo
             );
-          workInProgress = bailoutOnAlreadyFinishedWork(
-            current$$1,
-            workInProgress,
-            renderExpirationTime
-          );
-          return null !== workInProgress ? workInProgress.sibling : null;
+            break;
+          case 10:
+            pushProvider(workInProgress, workInProgress.memoizedProps.value);
+            break;
+          case 12:
+            workInProgress.effectTag |= 4;
+            break;
+          case 13:
+            if (null !== workInProgress.memoizedState) {
+              updateExpirationTime = workInProgress.child.childExpirationTime;
+              if (
+                0 !== updateExpirationTime &&
+                updateExpirationTime >= renderExpirationTime
+              )
+                return updateSuspenseComponent(
+                  current$$1,
+                  workInProgress,
+                  renderExpirationTime
+                );
+              workInProgress = bailoutOnAlreadyFinishedWork(
+                current$$1,
+                workInProgress,
+                renderExpirationTime
+              );
+              return null !== workInProgress ? workInProgress.sibling : null;
+            }
         }
+        return bailoutOnAlreadyFinishedWork(
+          current$$1,
+          workInProgress,
+          renderExpirationTime
+        );
+      }
     }
-    return bailoutOnAlreadyFinishedWork(
-      current$$1,
-      workInProgress,
-      renderExpirationTime
-    );
-  }
+  else didReceiveUpdate = !1;
   workInProgress.expirationTime = 0;
   switch (workInProgress.tag) {
     case 2:
@@ -4078,7 +4431,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         contextStackCursor.current
       );
       prepareToReadContext(workInProgress, renderExpirationTime);
-      context = updateExpirationTime(current$$1, context);
+      context = renderWithHooks(
+        null,
+        workInProgress,
+        updateExpirationTime,
+        current$$1,
+        context,
+        renderExpirationTime
+      );
       workInProgress.effectTag |= 1;
       if (
         "object" === typeof context &&
@@ -4087,6 +4447,7 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         void 0 === context.$$typeof
       ) {
         workInProgress.tag = 1;
+        resetHooks();
         if (isContextProvider(updateExpirationTime)) {
           var hasContext = !0;
           pushContextProvider(workInProgress);
@@ -4359,18 +4720,14 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
         pushProvider(workInProgress, hasContext);
         if (null !== getDerivedStateFromProps) {
           var oldValue = getDerivedStateFromProps.value;
-          hasContext =
-            (oldValue === hasContext &&
-              (0 !== oldValue || 1 / oldValue === 1 / hasContext)) ||
-            (oldValue !== oldValue && hasContext !== hasContext)
-              ? 0
-              : ("function" ===
-                typeof updateExpirationTime._calculateChangedBits
-                  ? updateExpirationTime._calculateChangedBits(
-                      oldValue,
-                      hasContext
-                    )
-                  : 1073741823) | 0;
+          hasContext = is(oldValue, hasContext)
+            ? 0
+            : ("function" === typeof updateExpirationTime._calculateChangedBits
+                ? updateExpirationTime._calculateChangedBits(
+                    oldValue,
+                    hasContext
+                  )
+                : 1073741823) | 0;
           if (0 === hasContext) {
             if (
               getDerivedStateFromProps.children === context.children &&
@@ -4385,83 +4742,79 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
             }
           } else
             for (
-              getDerivedStateFromProps = workInProgress.child,
-                null !== getDerivedStateFromProps &&
-                  (getDerivedStateFromProps.return = workInProgress);
-              null !== getDerivedStateFromProps;
+              oldValue = workInProgress.child,
+                null !== oldValue && (oldValue.return = workInProgress);
+              null !== oldValue;
 
             ) {
-              oldValue = getDerivedStateFromProps.firstContextDependency;
-              if (null !== oldValue) {
-                do {
+              var list = oldValue.contextDependencies;
+              if (null !== list) {
+                getDerivedStateFromProps = oldValue.child;
+                for (var dependency = list.first; null !== dependency; ) {
                   if (
-                    oldValue.context === updateExpirationTime &&
-                    0 !== (oldValue.observedBits & hasContext)
+                    dependency.context === updateExpirationTime &&
+                    0 !== (dependency.observedBits & hasContext)
                   ) {
-                    if (1 === getDerivedStateFromProps.tag) {
-                      var nextFiber = createUpdate(renderExpirationTime);
-                      nextFiber.tag = 2;
-                      enqueueUpdate(getDerivedStateFromProps, nextFiber);
-                    }
-                    getDerivedStateFromProps.expirationTime <
-                      renderExpirationTime &&
-                      (getDerivedStateFromProps.expirationTime = renderExpirationTime);
-                    nextFiber = getDerivedStateFromProps.alternate;
-                    null !== nextFiber &&
-                      nextFiber.expirationTime < renderExpirationTime &&
-                      (nextFiber.expirationTime = renderExpirationTime);
-                    for (
-                      var node = getDerivedStateFromProps.return;
-                      null !== node;
-
-                    ) {
-                      nextFiber = node.alternate;
+                    1 === oldValue.tag &&
+                      ((dependency = createUpdate(renderExpirationTime)),
+                      (dependency.tag = 2),
+                      enqueueUpdate(oldValue, dependency));
+                    oldValue.expirationTime < renderExpirationTime &&
+                      (oldValue.expirationTime = renderExpirationTime);
+                    dependency = oldValue.alternate;
+                    null !== dependency &&
+                      dependency.expirationTime < renderExpirationTime &&
+                      (dependency.expirationTime = renderExpirationTime);
+                    for (var node = oldValue.return; null !== node; ) {
+                      dependency = node.alternate;
                       if (node.childExpirationTime < renderExpirationTime)
                         (node.childExpirationTime = renderExpirationTime),
-                          null !== nextFiber &&
-                            nextFiber.childExpirationTime <
+                          null !== dependency &&
+                            dependency.childExpirationTime <
                               renderExpirationTime &&
-                            (nextFiber.childExpirationTime = renderExpirationTime);
+                            (dependency.childExpirationTime = renderExpirationTime);
                       else if (
-                        null !== nextFiber &&
-                        nextFiber.childExpirationTime < renderExpirationTime
+                        null !== dependency &&
+                        dependency.childExpirationTime < renderExpirationTime
                       )
-                        nextFiber.childExpirationTime = renderExpirationTime;
+                        dependency.childExpirationTime = renderExpirationTime;
                       else break;
                       node = node.return;
                     }
+                    list.expirationTime < renderExpirationTime &&
+                      (list.expirationTime = renderExpirationTime);
+                    break;
                   }
-                  nextFiber = getDerivedStateFromProps.child;
-                  oldValue = oldValue.next;
-                } while (null !== oldValue);
+                  dependency = dependency.next;
+                }
               } else
-                nextFiber =
-                  10 === getDerivedStateFromProps.tag
-                    ? getDerivedStateFromProps.type === workInProgress.type
+                getDerivedStateFromProps =
+                  10 === oldValue.tag
+                    ? oldValue.type === workInProgress.type
                       ? null
-                      : getDerivedStateFromProps.child
-                    : getDerivedStateFromProps.child;
-              if (null !== nextFiber)
-                nextFiber.return = getDerivedStateFromProps;
+                      : oldValue.child
+                    : oldValue.child;
+              if (null !== getDerivedStateFromProps)
+                getDerivedStateFromProps.return = oldValue;
               else
                 for (
-                  nextFiber = getDerivedStateFromProps;
-                  null !== nextFiber;
+                  getDerivedStateFromProps = oldValue;
+                  null !== getDerivedStateFromProps;
 
                 ) {
-                  if (nextFiber === workInProgress) {
-                    nextFiber = null;
+                  if (getDerivedStateFromProps === workInProgress) {
+                    getDerivedStateFromProps = null;
                     break;
                   }
-                  getDerivedStateFromProps = nextFiber.sibling;
-                  if (null !== getDerivedStateFromProps) {
-                    getDerivedStateFromProps.return = nextFiber.return;
-                    nextFiber = getDerivedStateFromProps;
+                  oldValue = getDerivedStateFromProps.sibling;
+                  if (null !== oldValue) {
+                    oldValue.return = getDerivedStateFromProps.return;
+                    getDerivedStateFromProps = oldValue;
                     break;
                   }
-                  nextFiber = nextFiber.return;
+                  getDerivedStateFromProps = getDerivedStateFromProps.return;
                 }
-              getDerivedStateFromProps = nextFiber;
+              oldValue = getDerivedStateFromProps;
             }
         }
         reconcileChildren(
@@ -4561,6 +4914,69 @@ function beginWork(current$$1, workInProgress, renderExpirationTime) {
       );
   }
 }
+var valueCursor = { current: null },
+  currentlyRenderingFiber = null,
+  lastContextDependency = null,
+  lastContextWithAllBitsObserved = null,
+  stashedCurrentlyRenderingFiber = null,
+  stashedLastContextDependency = null,
+  stashedLastContextWithAllBitsObserved = null;
+function resetContextDependences() {
+  stashedLastContextWithAllBitsObserved = stashedLastContextDependency = stashedCurrentlyRenderingFiber = lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function stashContextDependencies() {
+  stashedCurrentlyRenderingFiber = currentlyRenderingFiber;
+  stashedLastContextDependency = lastContextDependency;
+  stashedLastContextWithAllBitsObserved = lastContextWithAllBitsObserved;
+  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null;
+}
+function unstashContextDependencies() {
+  currentlyRenderingFiber = stashedCurrentlyRenderingFiber;
+  lastContextDependency = stashedLastContextDependency;
+  lastContextWithAllBitsObserved = stashedLastContextWithAllBitsObserved;
+}
+function pushProvider(providerFiber, nextValue) {
+  var context = providerFiber.type._context;
+  push(valueCursor, context._currentValue, providerFiber);
+  context._currentValue = nextValue;
+}
+function popProvider(providerFiber) {
+  var currentValue = valueCursor.current;
+  pop(valueCursor, providerFiber);
+  providerFiber.type._context._currentValue = currentValue;
+}
+function prepareToReadContext(workInProgress, renderExpirationTime) {
+  currentlyRenderingFiber = workInProgress;
+  lastContextWithAllBitsObserved = lastContextDependency = null;
+  var currentDependencies = workInProgress.contextDependencies;
+  null !== currentDependencies &&
+    currentDependencies.expirationTime >= renderExpirationTime &&
+    (didReceiveUpdate = !0);
+  workInProgress.contextDependencies = null;
+}
+function readContext(context, observedBits) {
+  if (
+    lastContextWithAllBitsObserved !== context &&
+    !1 !== observedBits &&
+    0 !== observedBits
+  ) {
+    if ("number" !== typeof observedBits || 1073741823 === observedBits)
+      (lastContextWithAllBitsObserved = context), (observedBits = 1073741823);
+    observedBits = { context: context, observedBits: observedBits, next: null };
+    null === lastContextDependency
+      ? (invariant(
+          null !== currentlyRenderingFiber,
+          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
+        ),
+        (lastContextDependency = observedBits),
+        (currentlyRenderingFiber.contextDependencies = {
+          first: observedBits,
+          expirationTime: 0
+        }))
+      : (lastContextDependency = lastContextDependency.next = observedBits);
+  }
+  return context._currentValue;
+}
 var appendAllChildren = void 0,
   updateHostContainer = void 0,
   updateHostComponent$1 = void 0,
@@ -4611,6 +5027,7 @@ function logCapturedError(capturedError) {
         : Error("Unspecified error at:" + componentStack);
   ExceptionsManager.handleException(error, !1);
 }
+var PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set;
 function logError(boundary, errorInfo) {
   var source = errorInfo.source,
     stack = errorInfo.stack;
@@ -4651,6 +5068,84 @@ function safelyDetachRef(current$$1) {
       }
     else ref.current = null;
 }
+function commitHookEffectList(unmountTag, mountTag, finishedWork) {
+  finishedWork = finishedWork.updateQueue;
+  finishedWork = null !== finishedWork ? finishedWork.lastEffect : null;
+  if (null !== finishedWork) {
+    var effect = (finishedWork = finishedWork.next);
+    do {
+      if ((effect.tag & unmountTag) !== NoEffect$1) {
+        var destroy = effect.destroy;
+        effect.destroy = null;
+        null !== destroy && destroy();
+      }
+      (effect.tag & mountTag) !== NoEffect$1 &&
+        ((destroy = effect.create),
+        (destroy = destroy()),
+        "function" !== typeof destroy && (destroy = null),
+        (effect.destroy = destroy));
+      effect = effect.next;
+    } while (effect !== finishedWork);
+  }
+}
+function hideOrUnhideAllChildren(finishedWork, isHidden) {
+  for (var node = finishedWork; ; ) {
+    if (5 === node.tag) {
+      var instance = node.stateNode;
+      if (isHidden) {
+        var viewConfig = instance.viewConfig;
+        var updatePayload = diffProperties(
+          null,
+          emptyObject,
+          { style: { display: "none" } },
+          viewConfig.validAttributes
+        );
+        UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      } else {
+        instance = node.stateNode;
+        updatePayload = node.memoizedProps;
+        viewConfig = instance.viewConfig;
+        var prevProps = Object.assign({}, updatePayload, {
+          style: [updatePayload.style, { display: "none" }]
+        });
+        updatePayload = diffProperties(
+          null,
+          prevProps,
+          updatePayload,
+          viewConfig.validAttributes
+        );
+        UIManager.updateView(
+          instance._nativeTag,
+          viewConfig.uiViewClassName,
+          updatePayload
+        );
+      }
+    } else {
+      if (6 === node.tag) throw Error("Not yet implemented.");
+      if (13 === node.tag && null !== node.memoizedState) {
+        instance = node.child.sibling;
+        instance.return = node;
+        node = instance;
+        continue;
+      } else if (null !== node.child) {
+        node.child.return = node;
+        node = node.child;
+        continue;
+      }
+    }
+    if (node === finishedWork) break;
+    for (; null === node.sibling; ) {
+      if (null === node.return || node.return === finishedWork) return;
+      node = node.return;
+    }
+    node.sibling.return = node.return;
+    node = node.sibling;
+  }
+}
 function commitUnmount(current$$1$jscomp$0) {
   "function" === typeof onCommitFiberUnmount &&
     onCommitFiberUnmount(current$$1$jscomp$0);
@@ -4938,6 +5433,7 @@ function commitWork(current$$1, finishedWork) {
     case 11:
     case 14:
     case 15:
+      commitHookEffectList(UnmountMutation, MountMutation, finishedWork);
       break;
     case 1:
       break;
@@ -4946,23 +5442,18 @@ function commitWork(current$$1, finishedWork) {
       if (null != instance) {
         var newProps = finishedWork.memoizedProps;
         current$$1 = null !== current$$1 ? current$$1.memoizedProps : newProps;
-        var updatePayload = finishedWork.updateQueue;
+        var type = finishedWork.type,
+          updatePayload = finishedWork.updateQueue;
         finishedWork.updateQueue = null;
         null !== updatePayload &&
-          ((finishedWork = instance.viewConfig),
-          (instanceProps[instance._nativeTag] = newProps),
-          (newProps = diffProperties(
-            null,
+          commitUpdate(
+            instance,
+            updatePayload,
+            type,
             current$$1,
             newProps,
-            finishedWork.validAttributes
-          )),
-          null != newProps &&
-            UIManager.updateView(
-              instance._nativeTag,
-              finishedWork.uiViewClassName,
-              newProps
-            ));
+            finishedWork
+          );
       }
       break;
     case 6:
@@ -4979,71 +5470,29 @@ function commitWork(current$$1, finishedWork) {
     case 12:
       break;
     case 13:
-      newProps = finishedWork.memoizedState;
+      instance = finishedWork.memoizedState;
+      newProps = void 0;
       current$$1 = finishedWork;
-      null === newProps
-        ? (instance = !1)
-        : ((instance = !0),
+      null === instance
+        ? (newProps = !1)
+        : ((newProps = !0),
           (current$$1 = finishedWork.child),
-          0 === newProps.timedOutAt &&
-            (newProps.timedOutAt = requestCurrentTime()));
-      if (null !== current$$1)
-        a: for (newProps = finishedWork = current$$1; ; ) {
-          if (5 === newProps.tag)
-            if (((current$$1 = newProps.stateNode), instance)) {
-              updatePayload = current$$1.viewConfig;
-              var updatePayload$jscomp$0 = diffProperties(
-                null,
-                emptyObject,
-                { style: { display: "none" } },
-                updatePayload.validAttributes
-              );
-              UIManager.updateView(
-                current$$1._nativeTag,
-                updatePayload.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            } else {
-              current$$1 = newProps.stateNode;
-              updatePayload$jscomp$0 = newProps.memoizedProps;
-              updatePayload = current$$1.viewConfig;
-              var prevProps = Object.assign({}, updatePayload$jscomp$0, {
-                style: [updatePayload$jscomp$0.style, { display: "none" }]
-              });
-              updatePayload$jscomp$0 = diffProperties(
-                null,
-                prevProps,
-                updatePayload$jscomp$0,
-                updatePayload.validAttributes
-              );
-              UIManager.updateView(
-                current$$1._nativeTag,
-                updatePayload.uiViewClassName,
-                updatePayload$jscomp$0
-              );
-            }
-          else {
-            if (6 === newProps.tag) throw Error("Not yet implemented.");
-            if (13 === newProps.tag && null !== newProps.memoizedState) {
-              current$$1 = newProps.child.sibling;
-              current$$1.return = newProps;
-              newProps = current$$1;
-              continue;
-            } else if (null !== newProps.child) {
-              newProps.child.return = newProps;
-              newProps = newProps.child;
-              continue;
-            }
-          }
-          if (newProps === finishedWork) break a;
-          for (; null === newProps.sibling; ) {
-            if (null === newProps.return || newProps.return === finishedWork)
-              break a;
-            newProps = newProps.return;
-          }
-          newProps.sibling.return = newProps.return;
-          newProps = newProps.sibling;
-        }
+          0 === instance.timedOutAt &&
+            (instance.timedOutAt = requestCurrentTime()));
+      null !== current$$1 && hideOrUnhideAllChildren(current$$1, newProps);
+      instance = finishedWork.updateQueue;
+      if (null !== instance) {
+        finishedWork.updateQueue = null;
+        var retryCache = finishedWork.stateNode;
+        null === retryCache &&
+          (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
+        instance.forEach(function(thenable) {
+          var retry = retryTimedOutBoundary.bind(null, finishedWork, thenable);
+          retry = tracing.unstable_wrap(retry);
+          retryCache.has(thenable) ||
+            (retryCache.add(thenable), thenable.then(retry, retry));
+        });
+      }
       break;
     case 17:
       break;
@@ -5054,6 +5503,7 @@ function commitWork(current$$1, finishedWork) {
       );
   }
 }
+var PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map;
 function createRootErrorUpdate(fiber, errorInfo, expirationTime) {
   expirationTime = createUpdate(expirationTime);
   expirationTime.tag = 3;
@@ -5136,24 +5586,43 @@ function throwException(
             ? !1
             : null === value.memoizedState;
       if (current$$1) {
-        returnFiber = retrySuspendedRoot.bind(
-          null,
-          root,
-          value,
-          sourceFiber,
-          0 === (value.mode & 1) ? 1073741823 : renderExpirationTime
-        );
-        returnFiber = tracing.unstable_wrap(returnFiber);
-        thenable.then(returnFiber, returnFiber);
+        returnFiber = value.updateQueue;
+        null === returnFiber
+          ? ((returnFiber = new Set()),
+            returnFiber.add(thenable),
+            (value.updateQueue = returnFiber))
+          : returnFiber.add(thenable);
         if (0 === (value.mode & 1)) {
           value.effectTag |= 64;
           sourceFiber.effectTag &= -1957;
           1 === sourceFiber.tag &&
-            null === sourceFiber.alternate &&
-            (sourceFiber.tag = 17);
-          sourceFiber.expirationTime = renderExpirationTime;
+            (null === sourceFiber.alternate
+              ? (sourceFiber.tag = 17)
+              : ((renderExpirationTime = createUpdate(1073741823)),
+                (renderExpirationTime.tag = 2),
+                enqueueUpdate(sourceFiber, renderExpirationTime)));
+          sourceFiber.expirationTime = 1073741823;
           return;
         }
+        sourceFiber = root.pingCache;
+        null === sourceFiber
+          ? ((sourceFiber = root.pingCache = new PossiblyWeakMap()),
+            (returnFiber = new Set()),
+            sourceFiber.set(thenable, returnFiber))
+          : ((returnFiber = sourceFiber.get(thenable)),
+            void 0 === returnFiber &&
+              ((returnFiber = new Set()),
+              sourceFiber.set(thenable, returnFiber)));
+        returnFiber.has(renderExpirationTime) ||
+          (returnFiber.add(renderExpirationTime),
+          (sourceFiber = pingSuspendedRoot.bind(
+            null,
+            root,
+            thenable,
+            renderExpirationTime
+          )),
+          (sourceFiber = tracing.unstable_wrap(sourceFiber)),
+          thenable.then(sourceFiber, sourceFiber));
         -1 === earliestTimeoutMs
           ? (root = 1073741823)
           : (-1 === startTimeMs &&
@@ -5187,33 +5656,32 @@ function throwException(
   do {
     switch (root.tag) {
       case 3:
-        sourceFiber = value;
         root.effectTag |= 2048;
         root.expirationTime = renderExpirationTime;
         renderExpirationTime = createRootErrorUpdate(
           root,
-          sourceFiber,
+          value,
           renderExpirationTime
         );
         enqueueCapturedUpdate(root, renderExpirationTime);
         return;
       case 1:
         if (
-          ((sourceFiber = value),
-          (returnFiber = root.type),
-          (thenable = root.stateNode),
+          ((thenable = value),
+          (earliestTimeoutMs = root.type),
+          (startTimeMs = root.stateNode),
           0 === (root.effectTag & 64) &&
-            ("function" === typeof returnFiber.getDerivedStateFromError ||
-              (null !== thenable &&
-                "function" === typeof thenable.componentDidCatch &&
+            ("function" === typeof earliestTimeoutMs.getDerivedStateFromError ||
+              (null !== startTimeMs &&
+                "function" === typeof startTimeMs.componentDidCatch &&
                 (null === legacyErrorBoundariesThatAlreadyFailed ||
-                  !legacyErrorBoundariesThatAlreadyFailed.has(thenable)))))
+                  !legacyErrorBoundariesThatAlreadyFailed.has(startTimeMs)))))
         ) {
           root.effectTag |= 2048;
           root.expirationTime = renderExpirationTime;
           renderExpirationTime = createClassErrorUpdate(
             root,
-            sourceFiber,
+            thenable,
             renderExpirationTime
           );
           enqueueCapturedUpdate(root, renderExpirationTime);
@@ -5262,7 +5730,87 @@ function unwindWork(workInProgress) {
       return null;
   }
 }
-var DispatcherWithoutHooks = { readContext: readContext },
+var Dispatcher = {
+    readContext: readContext,
+    useCallback: function(callback, deps) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      workInProgressHook.memoizedState = [callback, deps];
+      return callback;
+    },
+    useContext: function(context, observedBits) {
+      resolveCurrentlyRenderingFiber();
+      return readContext(context, observedBits);
+    },
+    useEffect: function(create, deps) {
+      useEffectImpl(516, UnmountPassive | MountPassive, create, deps);
+    },
+    useImperativeHandle: function(ref, create, deps) {
+      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : [ref];
+      useLayoutEffect(function() {
+        if ("function" === typeof ref) {
+          var _inst = create();
+          ref(_inst);
+          return function() {
+            return ref(null);
+          };
+        }
+        if (null !== ref && void 0 !== ref)
+          return (
+            (_inst = create()),
+            (ref.current = _inst),
+            function() {
+              ref.current = null;
+            }
+          );
+      }, deps);
+    },
+    useDebugValue: function() {
+      resolveCurrentlyRenderingFiber();
+    },
+    useLayoutEffect: useLayoutEffect,
+    useMemo: function(nextCreate, deps) {
+      var fiber = (currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber());
+      workInProgressHook = createWorkInProgressHook();
+      deps = void 0 === deps ? null : deps;
+      var prevState = workInProgressHook.memoizedState;
+      if (
+        null !== prevState &&
+        null !== deps &&
+        areHookInputsEqual(deps, prevState[1])
+      )
+        return prevState[0];
+      currentlyRenderingFiber$1 = null;
+      stashContextDependencies();
+      nextCreate = nextCreate();
+      currentlyRenderingFiber$1 = fiber;
+      unstashContextDependencies();
+      workInProgressHook.memoizedState = [nextCreate, deps];
+      return nextCreate;
+    },
+    useReducer: useReducer,
+    useRef: function(initialValue) {
+      currentlyRenderingFiber$1 = resolveCurrentlyRenderingFiber();
+      workInProgressHook = createWorkInProgressHook();
+      null === workInProgressHook.memoizedState
+        ? ((initialValue = { current: initialValue }),
+          (workInProgressHook.memoizedState = initialValue))
+        : (initialValue = workInProgressHook.memoizedState);
+      return initialValue;
+    },
+    useState: function(initialState) {
+      return useReducer(basicStateReducer, initialState);
+    }
+  },
+  ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher,
   ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner;
 invariant(
   null != tracing.__interactionsRef &&
@@ -5277,6 +5825,7 @@ var isWorking = !1,
   nextRenderDidError = !1,
   nextEffect = null,
   isCommitting$1 = !1,
+  rootWithPendingPassiveEffects = null,
   passiveEffectCallbackHandle = null,
   passiveEffectCallback = null,
   legacyErrorBoundariesThatAlreadyFailed = null;
@@ -5369,6 +5918,7 @@ function commitBeforeMutationLifecycles() {
           case 0:
           case 11:
           case 15:
+            commitHookEffectList(UnmountSnapshot, NoEffect$1, finishedWork);
             break a;
           case 1:
             if (finishedWork.effectTag & 256 && null !== current$$1) {
@@ -5415,6 +5965,7 @@ function commitAllLifeCycles(
         case 0:
         case 11:
         case 15:
+          commitHookEffectList(UnmountLayout, MountLayout, finishedWork);
           break;
         case 1:
           finishedRoot = finishedWork.stateNode;
@@ -5493,15 +6044,39 @@ function commitAllLifeCycles(
       }
     }
     effectTag & 128 &&
-      ((effectTag = nextEffect.ref),
-      null !== effectTag &&
-        ((finishedWork = nextEffect.stateNode),
-        "function" === typeof effectTag
-          ? effectTag(finishedWork)
-          : (effectTag.current = finishedWork)));
+      ((finishedWork = nextEffect.ref),
+      null !== finishedWork &&
+        ((committedExpirationTime = nextEffect.stateNode),
+        "function" === typeof finishedWork
+          ? finishedWork(committedExpirationTime)
+          : (finishedWork.current = committedExpirationTime)));
+    effectTag & 512 && (rootWithPendingPassiveEffects = finishedRoot$jscomp$0);
     nextEffect = nextEffect.nextEffect;
   }
 }
+function commitPassiveEffects(root, firstEffect) {
+  passiveEffectCallback = passiveEffectCallbackHandle = rootWithPendingPassiveEffects = null;
+  var previousIsRendering = isRendering;
+  isRendering = !0;
+  do {
+    if (firstEffect.effectTag & 512) {
+      var didError = !1,
+        error = void 0;
+      try {
+        var finishedWork = firstEffect;
+        commitHookEffectList(UnmountPassive, NoEffect$1, finishedWork);
+        commitHookEffectList(NoEffect$1, MountPassive, finishedWork);
+      } catch (e) {
+        (didError = !0), (error = e);
+      }
+      didError && captureCommitPhaseError(firstEffect, error);
+    }
+    firstEffect = firstEffect.nextEffect;
+  } while (null !== firstEffect);
+  isRendering = previousIsRendering;
+  previousIsRendering = root.expirationTime;
+  0 !== previousIsRendering && requestWork(root, previousIsRendering);
+}
 function flushPassiveEffects() {
   null !== passiveEffectCallback &&
     (scheduler.unstable_cancelCallback(passiveEffectCallbackHandle),
@@ -5573,21 +6148,35 @@ function commitRoot(root, finishedWork) {
   }
   root.current = finishedWork;
   for (nextEffect = childExpirationTimeBeforeCommit; null !== nextEffect; ) {
-    childExpirationTimeBeforeCommit = !1;
-    didError = void 0;
+    didError = !1;
+    error$jscomp$0 = void 0;
     try {
       commitAllLifeCycles(root, committedExpirationTime);
     } catch (e) {
-      (childExpirationTimeBeforeCommit = !0), (didError = e);
+      (didError = !0), (error$jscomp$0 = e);
     }
-    childExpirationTimeBeforeCommit &&
+    didError &&
       (invariant(
         null !== nextEffect,
         "Should have next effect. This error is likely caused by a bug in React. Please file an issue."
       ),
-      captureCommitPhaseError(nextEffect, didError),
+      captureCommitPhaseError(nextEffect, error$jscomp$0),
       null !== nextEffect && (nextEffect = nextEffect.nextEffect));
   }
+  null !== childExpirationTimeBeforeCommit &&
+    null !== rootWithPendingPassiveEffects &&
+    ((childExpirationTimeBeforeCommit = commitPassiveEffects.bind(
+      null,
+      root,
+      childExpirationTimeBeforeCommit
+    )),
+    (childExpirationTimeBeforeCommit = tracing.unstable_wrap(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallbackHandle = scheduler.unstable_scheduleCallback(
+      childExpirationTimeBeforeCommit
+    )),
+    (passiveEffectCallback = childExpirationTimeBeforeCommit));
   isWorking = isCommitting$1 = !1;
   "function" === typeof onCommitFiberRoot &&
     onCommitFiberRoot(finishedWork.stateNode);
@@ -5779,11 +6368,7 @@ function completeUnitOfWork(workInProgress) {
                   : ((current$$1.firstEffect = current$$1.lastEffect = type),
                     (type.nextEffect = null)),
                 (type.effectTag = 8)));
-            if (
-              fiber !== renderExpirationTime ||
-              (0 === (current$$1.effectTag & 1) && fiber)
-            )
-              current$$1.effectTag |= 4;
+            if (fiber || renderExpirationTime) current$$1.effectTag |= 4;
             break;
           case 7:
             break;
@@ -5911,7 +6496,7 @@ function renderRoot(root, isYieldy) {
   );
   flushPassiveEffects();
   isWorking = !0;
-  ReactCurrentOwner$2.currentDispatcher = DispatcherWithoutHooks;
+  ReactCurrentDispatcher.current = Dispatcher;
   var expirationTime = root.nextExpirationTimeToWorkOn;
   if (
     expirationTime !== nextRenderExpirationTime ||
@@ -5964,10 +6549,7 @@ function renderRoot(root, isYieldy) {
         for (; null !== nextUnitOfWork; )
           nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
     } catch (thrownValue) {
-      if (
-        ((lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = null),
-        null === nextUnitOfWork)
-      )
+      if ((resetContextDependences(), resetHooks(), null === nextUnitOfWork))
         (threadID = !0), onUncaughtError(thrownValue);
       else {
         nextUnitOfWork.mode & 4 &&
@@ -5996,7 +6578,9 @@ function renderRoot(root, isYieldy) {
   } while (1);
   tracing.__interactionsRef.current = subscriber;
   isWorking = !1;
-  lastContextWithAllBitsObserved = lastContextDependency = currentlyRenderingFiber = ReactCurrentOwner$2.currentDispatcher = null;
+  ReactCurrentDispatcher.current = null;
+  resetContextDependences();
+  resetHooks();
   if (threadID) (nextRoot = null), (root.finishedWork = null);
   else if (null !== nextUnitOfWork) root.finishedWork = null;
   else {
@@ -6091,38 +6675,34 @@ function computeExpirationForFiber(currentTime, fiber) {
     (lowestPriorityPendingInteractiveExpirationTime = currentTime);
   return currentTime;
 }
-function retrySuspendedRoot(root, boundaryFiber, sourceFiber, suspendedTime) {
-  var retryTime = root.earliestSuspendedTime;
-  var latestSuspendedTime = root.latestSuspendedTime;
-  if (
-    0 !== retryTime &&
-    suspendedTime <= retryTime &&
-    suspendedTime >= latestSuspendedTime
+function pingSuspendedRoot(root, thenable, pingTime) {
+  var pingCache = root.pingCache;
+  null !== pingCache && pingCache.delete(thenable);
+  if (null !== nextRoot && nextRenderExpirationTime === pingTime)
+    nextRoot = null;
+  else if (
+    ((thenable = root.earliestSuspendedTime),
+    (pingCache = root.latestSuspendedTime),
+    0 !== thenable && pingTime <= thenable && pingTime >= pingCache)
   ) {
-    latestSuspendedTime = retryTime = suspendedTime;
     root.didError = !1;
-    var latestPingedTime = root.latestPingedTime;
-    if (0 === latestPingedTime || latestPingedTime > latestSuspendedTime)
-      root.latestPingedTime = latestSuspendedTime;
-    findNextExpirationTimeToWorkOn(latestSuspendedTime, root);
-  } else
-    (retryTime = requestCurrentTime()),
-      (retryTime = computeExpirationForFiber(retryTime, boundaryFiber)),
-      markPendingPriorityLevel(root, retryTime);
-  0 !== (boundaryFiber.mode & 1) &&
-    root === nextRoot &&
-    nextRenderExpirationTime === suspendedTime &&
-    (nextRoot = null);
-  scheduleWorkToRoot(boundaryFiber, retryTime);
-  0 === (boundaryFiber.mode & 1) &&
-    (scheduleWorkToRoot(sourceFiber, retryTime),
-    1 === sourceFiber.tag &&
-      null !== sourceFiber.stateNode &&
-      ((boundaryFiber = createUpdate(retryTime)),
-      (boundaryFiber.tag = 2),
-      enqueueUpdate(sourceFiber, boundaryFiber)));
-  sourceFiber = root.expirationTime;
-  0 !== sourceFiber && requestWork(root, sourceFiber);
+    thenable = root.latestPingedTime;
+    if (0 === thenable || thenable > pingTime) root.latestPingedTime = pingTime;
+    findNextExpirationTimeToWorkOn(pingTime, root);
+    pingTime = root.expirationTime;
+    0 !== pingTime && requestWork(root, pingTime);
+  }
+}
+function retryTimedOutBoundary(boundaryFiber, thenable) {
+  var retryCache = boundaryFiber.stateNode;
+  null !== retryCache && retryCache.delete(thenable);
+  thenable = requestCurrentTime();
+  thenable = computeExpirationForFiber(thenable, boundaryFiber);
+  boundaryFiber = scheduleWorkToRoot(boundaryFiber, thenable);
+  null !== boundaryFiber &&
+    (markPendingPriorityLevel(boundaryFiber, thenable),
+    (thenable = boundaryFiber.expirationTime),
+    0 !== thenable && requestWork(boundaryFiber, thenable));
 }
 function scheduleWorkToRoot(fiber, expirationTime) {
   fiber.expirationTime < expirationTime &&
@@ -6706,6 +7286,7 @@ var roots = new Map(),
           earliestSuspendedTime: 0,
           latestSuspendedTime: 0,
           latestPingedTime: 0,
+          pingCache: null,
           didError: !1,
           pendingCommitExpirationTime: 0,
           finishedWork: null,
@@ -6819,6 +7400,8 @@ var roots = new Map(),
   var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
   return injectInternals(
     Object.assign({}, devToolsConfig, {
+      overrideProps: null,
+      currentDispatcherRef: ReactSharedInternals.ReactCurrentDispatcher,
       findHostInstanceByFiber: function(fiber) {
         fiber = findCurrentHostFiber(fiber);
         return null === fiber ? null : fiber.stateNode;
@@ -6834,7 +7417,7 @@ var roots = new Map(),
   findFiberByHostInstance: getInstanceFromTag,
   getInspectorDataForViewTag: getInspectorDataForViewTag,
   bundleType: 0,
-  version: "16.6.1",
+  version: "16.7.0",
   rendererPackageName: "react-native-renderer"
 });
 var ReactNativeRenderer$2 = { default: ReactNativeRenderer },
--- a/node_modules/react-native/Libraries/Renderer/shims/ReactNativeViewConfigRegistry.js
+++ b/node_modules/react-native/Libraries/Renderer/shims/ReactNativeViewConfigRegistry.js
@@ -15,7 +15,7 @@ import type {
   ViewConfigGetter,
 } from './ReactNativeTypes';
 
-const invariant = require('fbjs/lib/invariant');
+const invariant = require('invariant');
 
 // Event configs
 const customBubblingEventTypes = {};
